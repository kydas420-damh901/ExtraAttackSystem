using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using BepInEx;
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using ServerSync;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using WeaponsAttackAnimationManager.Functions;
using YamlDotNet.Core;
using YamlDotNet.Core.Events;
using YamlDotNet.Core.Tokens;
using YamlDotNet.Helpers;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.BufferedDeserialization;
using YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminators;
using YamlDotNet.Serialization.Callbacks;
using YamlDotNet.Serialization.Converters;
using YamlDotNet.Serialization.EventEmitters;
using YamlDotNet.Serialization.NamingConventions;
using YamlDotNet.Serialization.NodeDeserializers;
using YamlDotNet.Serialization.NodeTypeResolvers;
using YamlDotNet.Serialization.ObjectFactories;
using YamlDotNet.Serialization.ObjectGraphTraversalStrategies;
using YamlDotNet.Serialization.ObjectGraphVisitors;
using YamlDotNet.Serialization.Schemas;
using YamlDotNet.Serialization.TypeInspectors;
using YamlDotNet.Serialization.TypeResolvers;
using YamlDotNet.Serialization.Utilities;
using YamlDotNet.Serialization.ValueDeserializers;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyTitle("WeaponsAttackAnimationManager")]
[assembly: AssemblyDescription("https://thunderstore.io/c/valheim/p/blacks7ar/WeaponsAttackAnimationManager/")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("blacks7ar")]
[assembly: AssemblyProduct("WeaponsAttackAnimationManager")]
[assembly: AssemblyCopyright("Copyright Â©  2024")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("82020035-B36E-48D4-BBCB-4B5F54D5FB35")]
[assembly: AssemblyFileVersion("1.0.3")]
[assembly: TargetFramework(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("1.0.3.0")]
[module: UnverifiableCode]
[module: RefSafetyRules(11)]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class RefSafetyRulesAttribute : Attribute
	{
		public readonly int Version;

		public RefSafetyRulesAttribute(int P_0)
		{
			Version = P_0;
		}
	}
}
namespace WeaponsAttackAnimationManager
{
	[BepInPlugin("blacks7ar.WeaponsAttackAnimationManager", "WeaponsAttackAnimationManager", "1.0.3")]
	public class Plugin : BaseUnityPlugin
	{
		private enum Toggle
		{
			On = 1,
			Off = 0
		}

		private struct AttackAnimations
		{
			[YamlMember(Alias = "Weapon Name", ApplyNamingConventions = false)]
			public string weaponName { get; set; }

			[YamlMember(Alias = "Localized Name", ApplyNamingConventions = false)]
			public string localizedName { get; set; }

			[YamlMember(Alias = "Primary", ApplyNamingConventions = false)]
			public string primaryAnim { get; set; }

			[YamlMember(Alias = "Secondary", ApplyNamingConventions = false)]
			public string secondaryAnim { get; set; }

			public AttackAnimations()
			{
				weaponName = null;
				localizedName = null;
				primaryAnim = null;
				secondaryAnim = null;
			}
		}

		[HarmonyPatch]
		private static class Patches
		{
			[HarmonyPostfix]
			[HarmonyPatch(typeof(Game), "Awake")]
			private static void Awake_Postfix(Game __instance)
			{
				if (!((Object)(object)__instance == (Object)null) && !File.Exists(ymlFullPath))
				{
					Logging.LogWarning("File not found - " + ymlFileName + "!");
					_AttackAnimsList = (from item in ObjectDB.instance.m_items
						select item.GetComponent<ItemDrop>() into component
						where (Object)(object)component != (Object)null && IsPlayerWeapon(component)
						select new AttackAnimations
						{
							weaponName = ((Object)component).name,
							localizedName = component.m_itemData.m_shared.m_name,
							primaryAnim = component.m_itemData.m_shared.m_attack.m_attackAnimation,
							secondaryAnim = component.m_itemData.m_shared.m_secondaryAttack.m_attackAnimation
						}).ToList();
					string contents = new SerializerBuilder().Build().Serialize(_AttackAnimsList);
					File.WriteAllText(ymlFullPath, contents);
					Logging.LogWarning("Creating a new one...");
				}
			}

			[HarmonyPostfix]
			[HarmonyPatch(typeof(ObjectDB), "Awake")]
			private static void Awake_Postfix(ObjectDB __instance)
			{
				//IL_0000: Unknown result type (might be due to invalid IL or missing references)
				//IL_0005: Unknown result type (might be due to invalid IL or missing references)
				Scene activeScene = SceneManager.GetActiveScene();
				if (((Scene)(ref activeScene)).name != "main" || (Object)(object)__instance == (Object)null || __instance.m_items.Count <= 0)
				{
					return;
				}
				foreach (AttackAnimations anim2 in _AttackAnimsList)
				{
					foreach (SharedData item in from item2 in __instance.m_items
						where ((Object)item2).name == anim2.weaponName
						select item2.GetComponent<ItemDrop>().m_itemData.m_shared)
					{
						item.m_attack.m_attackAnimation = anim2.primaryAnim;
						item.m_secondaryAttack.m_attackAnimation = anim2.secondaryAnim;
					}
				}
				__instance.UpdateRegisters();
			}
		}

		private const string modGUID = "blacks7ar.WeaponsAttackAnimationManager";

		public const string modName = "WeaponsAttackAnimationManager";

		public const string modAuthor = "blacks7ar";

		public const string modVersion = "1.0.3";

		public const string modLink = "https://thunderstore.io/c/valheim/p/blacks7ar/WeaponsAttackAnimationManager/";

		private static string ymlFileName = "blacks7ar.WeaponsAttackAnimationManager.yml";

		private static string ymlFullPath;

		private static readonly Harmony _harmony;

		private static readonly ConfigSync _configSync;

		private static ConfigEntry<Toggle> _serverConfigLock;

		private static List<AttackAnimations> _AttackAnimsList;

		private static readonly CustomSyncedValue<string> _AttackAnimsData;

		private ConfigEntry<T> config<T>(string group, string name, T value, ConfigDescription description, bool _synchronizedConfig = true)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			ConfigDescription val = new ConfigDescription(description.Description + (_synchronizedConfig ? " [Synced with Server]" : " [Not Synced with Server]"), description.AcceptableValues, description.Tags);
			ConfigEntry<T> val2 = ((BaseUnityPlugin)this).Config.Bind<T>(group, name, value, val);
			_configSync.AddConfigEntry<T>(val2).SynchronizedConfig = _synchronizedConfig;
			return val2;
		}

		private static void YmlDataWatcher()
		{
			FileSystemWatcher fileSystemWatcher = new FileSystemWatcher(Paths.ConfigPath, ymlFileName);
			fileSystemWatcher.Changed += YmlDataChanged;
			fileSystemWatcher.Created += YmlDataChanged;
			fileSystemWatcher.Renamed += YmlDataChanged;
			fileSystemWatcher.IncludeSubdirectories = true;
			fileSystemWatcher.SynchronizingObject = ThreadingHelper.SynchronizingObject;
			fileSystemWatcher.EnableRaisingEvents = true;
		}

		private static void YmlDataChanged(object sender, FileSystemEventArgs e)
		{
			if (!File.Exists(ymlFullPath))
			{
				return;
			}
			try
			{
				Logging.LogDebug("YmlDataWatcher called..");
				_AttackAnimsData.AssignLocalValue(File.ReadAllText(ymlFullPath));
			}
			catch
			{
				Logging.LogError("There was an issue loading your " + ymlFileName);
				Logging.LogError("Please check your entries for spelling and format!");
			}
		}

		public void Awake()
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Expected O, but got Unknown
			((BaseUnityPlugin)this).Config.SaveOnConfigSet = false;
			_serverConfigLock = config("01- ServerSync", "Lock Configuration", Toggle.On, new ConfigDescription("If On, the configuration is locked and can be changed by server admins only.", (AcceptableValueBase)null, Array.Empty<object>()));
			_configSync.AddLockingConfigEntry<Toggle>(_serverConfigLock);
			if (File.Exists(ymlFullPath))
			{
				_AttackAnimsData.ValueChanged += AttackAnimsDataOnValueChanged;
				_AttackAnimsData.AssignLocalValue(File.ReadAllText(ymlFullPath));
			}
			((BaseUnityPlugin)this).Config.SaveOnConfigSet = true;
			((BaseUnityPlugin)this).Config.Save();
			Assembly executingAssembly = Assembly.GetExecutingAssembly();
			_harmony.PatchAll(executingAssembly);
			YmlDataWatcher();
		}

		private static void AttackAnimsDataOnValueChanged()
		{
			Logging.LogDebug("AttackAnimsDataOnValueChanged called..");
			try
			{
				_AttackAnimsList.Clear();
				_AttackAnimsList = new DeserializerBuilder().Build().Deserialize<List<AttackAnimations>>(_AttackAnimsData.Value);
			}
			catch (Exception arg)
			{
				Logging.LogError($"Failed to deserialize {ymlFileName}: {arg}");
			}
		}

		private void OnDestroy()
		{
			((BaseUnityPlugin)this).Config.Save();
		}

		private static bool IsPlayerWeapon(ItemDrop item)
		{
			if (item.m_itemData.IsWeapon() && Object.op_Implicit((Object)(object)((Component)item).GetComponent<ParticleSystem>()) && item.m_itemData.m_shared.m_icons != null && item.m_itemData.m_shared.m_description != string.Empty)
			{
				return item.m_itemData.m_shared.m_name.StartsWith("$");
			}
			return false;
		}

		static Plugin()
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Expected O, but got Unknown
			string configPath = Paths.ConfigPath;
			char directorySeparatorChar = Path.DirectorySeparatorChar;
			ymlFullPath = configPath + directorySeparatorChar + ymlFileName;
			_harmony = new Harmony("blacks7ar.WeaponsAttackAnimationManager");
			_configSync = new ConfigSync("blacks7ar.WeaponsAttackAnimationManager")
			{
				DisplayName = "WeaponsAttackAnimationManager",
				CurrentVersion = "1.0.3",
				MinimumRequiredVersion = "1.0.3"
			};
			_AttackAnimsList = new List<AttackAnimations>();
			_AttackAnimsData = new CustomSyncedValue<string>(_configSync, "Weapon Animations", "");
		}
	}
}
namespace WeaponsAttackAnimationManager.Functions
{
	public static class Logging
	{
		private static readonly ManualLogSource AALogger = Logger.CreateLogSource("WeaponsAttackAnimationManager");

		public static void LogDebug(string debug)
		{
			AALogger.LogDebug((object)debug);
		}

		public static void LogInfo(string info)
		{
			AALogger.LogInfo((object)info);
		}

		public static void LogWarning(string warning)
		{
			AALogger.LogWarning((object)warning);
		}

		public static void LogError(string error)
		{
			AALogger.LogError((object)error);
		}
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableAttribute : Attribute
	{
		public readonly byte[] NullableFlags;

		public NullableAttribute(byte P_0)
		{
			NullableFlags = new byte[1] { P_0 };
		}

		public NullableAttribute(byte[] P_0)
		{
			NullableFlags = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableContextAttribute : Attribute
	{
		public readonly byte Flag;

		public NullableContextAttribute(byte P_0)
		{
			Flag = P_0;
		}
	}
}
namespace ServerSync
{
	[PublicAPI]
	internal abstract class OwnConfigEntryBase
	{
		public object? LocalBaseValue;

		public bool SynchronizedConfig = true;

		public abstract ConfigEntryBase BaseConfig { get; }
	}
	[PublicAPI]
	internal class SyncedConfigEntry<T> : OwnConfigEntryBase
	{
		public readonly ConfigEntry<T> SourceConfig;

		public override ConfigEntryBase BaseConfig => (ConfigEntryBase)(object)SourceConfig;

		public T Value
		{
			get
			{
				return SourceConfig.Value;
			}
			set
			{
				SourceConfig.Value = value;
			}
		}

		public SyncedConfigEntry(ConfigEntry<T> sourceConfig)
		{
			SourceConfig = sourceConfig;
			base..ctor();
		}

		public void AssignLocalValue(T value)
		{
			if (LocalBaseValue == null)
			{
				Value = value;
			}
			else
			{
				LocalBaseValue = value;
			}
		}
	}
	internal abstract class CustomSyncedValueBase
	{
		public object? LocalBaseValue;

		public readonly string Identifier;

		public readonly Type Type;

		private object? boxedValue;

		protected bool localIsOwner;

		public readonly int Priority;

		public object? BoxedValue
		{
			get
			{
				return boxedValue;
			}
			set
			{
				boxedValue = value;
				this.ValueChanged?.Invoke();
			}
		}

		public event Action? ValueChanged;

		protected CustomSyncedValueBase(ConfigSync configSync, string identifier, Type type, int priority)
		{
			Priority = priority;
			Identifier = identifier;
			Type = type;
			configSync.AddCustomValue(this);
			localIsOwner = configSync.IsSourceOfTruth;
			configSync.SourceOfTruthChanged += delegate(bool truth)
			{
				localIsOwner = truth;
			};
		}
	}
	[PublicAPI]
	internal sealed class CustomSyncedValue<T> : CustomSyncedValueBase
	{
		public T Value
		{
			get
			{
				return (T)base.BoxedValue;
			}
			set
			{
				base.BoxedValue = value;
			}
		}

		public CustomSyncedValue(ConfigSync configSync, string identifier, T value = default(T), int priority = 0)
			: base(configSync, identifier, typeof(T), priority)
		{
			Value = value;
		}

		public void AssignLocalValue(T value)
		{
			if (localIsOwner)
			{
				Value = value;
			}
			else
			{
				LocalBaseValue = value;
			}
		}
	}
	internal class ConfigurationManagerAttributes
	{
		[UsedImplicitly]
		public bool? ReadOnly = false;
	}
	[PublicAPI]
	internal class ConfigSync
	{
		[HarmonyPatch(typeof(ZRpc), "HandlePackage")]
		private static class SnatchCurrentlyHandlingRPC
		{
			public static ZRpc? currentRpc;

			[HarmonyPrefix]
			private static void Prefix(ZRpc __instance)
			{
				currentRpc = __instance;
			}
		}

		[HarmonyPatch(typeof(ZNet), "Awake")]
		internal static class RegisterRPCPatch
		{
			[HarmonyPostfix]
			private static void Postfix(ZNet __instance)
			{
				isServer = __instance.IsServer();
				foreach (ConfigSync configSync2 in configSyncs)
				{
					ZRoutedRpc.instance.Register<ZPackage>(configSync2.Name + " ConfigSync", (Action<long, ZPackage>)configSync2.RPC_FromOtherClientConfigSync);
					if (isServer)
					{
						configSync2.InitialSyncDone = true;
						Debug.Log((object)("Registered '" + configSync2.Name + " ConfigSync' RPC - waiting for incoming connections"));
					}
				}
				if (isServer)
				{
					((MonoBehaviour)__instance).StartCoroutine(WatchAdminListChanges());
				}
				static void SendAdmin(List<ZNetPeer> peers, bool isAdmin)
				{
					ZPackage package = ConfigsToPackage(null, null, new PackageEntry[1]
					{
						new PackageEntry
						{
							section = "Internal",
							key = "lockexempt",
							type = typeof(bool),
							value = isAdmin
						}
					});
					ConfigSync configSync = configSyncs.First();
					if (configSync != null)
					{
						((MonoBehaviour)ZNet.instance).StartCoroutine(configSync.sendZPackage(peers, package));
					}
				}
				static IEnumerator WatchAdminListChanges()
				{
					MethodInfo listContainsId = AccessTools.DeclaredMethod(typeof(ZNet), "ListContainsId", (Type[])null, (Type[])null);
					SyncedList adminList = (SyncedList)AccessTools.DeclaredField(typeof(ZNet), "m_adminList").GetValue(ZNet.instance);
					List<string> CurrentList = new List<string>(adminList.GetList());
					while (true)
					{
						yield return (object)new WaitForSeconds(30f);
						if (!adminList.GetList().SequenceEqual(CurrentList))
						{
							CurrentList = new List<string>(adminList.GetList());
							List<ZNetPeer> adminPeer = ZNet.instance.GetPeers().Where(delegate(ZNetPeer p)
							{
								string hostName = p.m_rpc.GetSocket().GetHostName();
								return ((object)listContainsId == null) ? adminList.Contains(hostName) : ((bool)listContainsId.Invoke(ZNet.instance, new object[2] { adminList, hostName }));
							}).ToList();
							List<ZNetPeer> nonAdminPeer = ZNet.instance.GetPeers().Except(adminPeer).ToList();
							SendAdmin(nonAdminPeer, isAdmin: false);
							SendAdmin(adminPeer, isAdmin: true);
						}
					}
				}
			}
		}

		[HarmonyPatch(typeof(ZNet), "OnNewConnection")]
		private static class RegisterClientRPCPatch
		{
			[HarmonyPostfix]
			private static void Postfix(ZNet __instance, ZNetPeer peer)
			{
				if (__instance.IsServer())
				{
					return;
				}
				foreach (ConfigSync configSync in configSyncs)
				{
					peer.m_rpc.Register<ZPackage>(configSync.Name + " ConfigSync", (Action<ZRpc, ZPackage>)configSync.RPC_FromServerConfigSync);
				}
			}
		}

		private class ParsedConfigs
		{
			public readonly Dictionary<OwnConfigEntryBase, object?> configValues = new Dictionary<OwnConfigEntryBase, object>();

			public readonly Dictionary<CustomSyncedValueBase, object?> customValues = new Dictionary<CustomSyncedValueBase, object>();
		}

		[HarmonyPatch(typeof(ZNet), "Shutdown")]
		private class ResetConfigsOnShutdown
		{
			[HarmonyPostfix]
			private static void Postfix()
			{
				ProcessingServerUpdate = true;
				foreach (ConfigSync configSync in configSyncs)
				{
					configSync.resetConfigsFromServer();
					configSync.IsSourceOfTruth = true;
					configSync.InitialSyncDone = false;
				}
				ProcessingServerUpdate = false;
			}
		}

		[HarmonyPatch(typeof(ZNet), "RPC_PeerInfo")]
		private class SendConfigsAfterLogin
		{
			private class BufferingSocket : ZPlayFabSocket, ISocket
			{
				public volatile bool finished = false;

				public volatile int versionMatchQueued = -1;

				public readonly List<ZPackage> Package = new List<ZPackage>();

				public readonly ISocket Original;

				public BufferingSocket(ISocket original)
				{
					Original = original;
					((ZPlayFabSocket)this)..ctor();
				}

				public bool IsConnected()
				{
					return Original.IsConnected();
				}

				public ZPackage Recv()
				{
					return Original.Recv();
				}

				public int GetSendQueueSize()
				{
					return Original.GetSendQueueSize();
				}

				public int GetCurrentSendRate()
				{
					return Original.GetCurrentSendRate();
				}

				public bool IsHost()
				{
					return Original.IsHost();
				}

				public void Dispose()
				{
					Original.Dispose();
				}

				public bool GotNewData()
				{
					return Original.GotNewData();
				}

				public void Close()
				{
					Original.Close();
				}

				public string GetEndPointString()
				{
					return Original.GetEndPointString();
				}

				public void GetAndResetStats(out int totalSent, out int totalRecv)
				{
					Original.GetAndResetStats(ref totalSent, ref totalRecv);
				}

				public void GetConnectionQuality(out float localQuality, out float remoteQuality, out int ping, out float outByteSec, out float inByteSec)
				{
					Original.GetConnectionQuality(ref localQuality, ref remoteQuality, ref ping, ref outByteSec, ref inByteSec);
				}

				public ISocket Accept()
				{
					return Original.Accept();
				}

				public int GetHostPort()
				{
					return Original.GetHostPort();
				}

				public bool Flush()
				{
					return Original.Flush();
				}

				public string GetHostName()
				{
					return Original.GetHostName();
				}

				public void VersionMatch()
				{
					if (finished)
					{
						Original.VersionMatch();
					}
					else
					{
						versionMatchQueued = Package.Count;
					}
				}

				public void Send(ZPackage pkg)
				{
					//IL_0057: Unknown result type (might be due to invalid IL or missing references)
					//IL_005d: Expected O, but got Unknown
					int pos = pkg.GetPos();
					pkg.SetPos(0);
					int num = pkg.ReadInt();
					if ((num == StringExtensionMethods.GetStableHashCode("PeerInfo") || num == StringExtensionMethods.GetStableHashCode("RoutedRPC") || num == StringExtensionMethods.GetStableHashCode("ZDOData")) && !finished)
					{
						ZPackage val = new ZPackage(pkg.GetArray());
						val.SetPos(pos);
						Package.Add(val);
					}
					else
					{
						pkg.SetPos(pos);
						Original.Send(pkg);
					}
				}
			}

			[HarmonyPriority(800)]
			[HarmonyPrefix]
			private static void Prefix(ref Dictionary<Assembly, BufferingSocket>? __state, ZNet __instance, ZRpc rpc)
			{
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_007e: Invalid comparison between Unknown and I4
				if (!__instance.IsServer())
				{
					return;
				}
				BufferingSocket bufferingSocket = new BufferingSocket(rpc.GetSocket());
				AccessTools.DeclaredField(typeof(ZRpc), "m_socket").SetValue(rpc, bufferingSocket);
				object? obj = AccessTools.DeclaredMethod(typeof(ZNet), "GetPeer", new Type[1] { typeof(ZRpc) }, (Type[])null).Invoke(__instance, new object[1] { rpc });
				ZNetPeer val = (ZNetPeer)((obj is ZNetPeer) ? obj : null);
				if (val != null && (int)ZNet.m_onlineBackend > 0)
				{
					FieldInfo fieldInfo = AccessTools.DeclaredField(typeof(ZNetPeer), "m_socket");
					object? value = fieldInfo.GetValue(val);
					ZPlayFabSocket val2 = (ZPlayFabSocket)((value is ZPlayFabSocket) ? value : null);
					if (val2 != null)
					{
						typeof(ZPlayFabSocket).GetField("m_remotePlayerId").SetValue(bufferingSocket, val2.m_remotePlayerId);
					}
					fieldInfo.SetValue(val, bufferingSocket);
				}
				if (__state == null)
				{
					__state = new Dictionary<Assembly, BufferingSocket>();
				}
				__state[Assembly.GetExecutingAssembly()] = bufferingSocket;
			}

			[HarmonyPostfix]
			private static void Postfix(Dictionary<Assembly, BufferingSocket> __state, ZNet __instance, ZRpc rpc)
			{
				ZRpc rpc2 = rpc;
				ZNet __instance2 = __instance;
				Dictionary<Assembly, BufferingSocket> __state2 = __state;
				ZNetPeer peer;
				if (__instance2.IsServer())
				{
					object obj = AccessTools.DeclaredMethod(typeof(ZNet), "GetPeer", new Type[1] { typeof(ZRpc) }, (Type[])null).Invoke(__instance2, new object[1] { rpc2 });
					peer = (ZNetPeer)((obj is ZNetPeer) ? obj : null);
					if (peer == null)
					{
						SendBufferedData();
					}
					else
					{
						((MonoBehaviour)__instance2).StartCoroutine(sendAsync());
					}
				}
				void SendBufferedData()
				{
					if (rpc2.GetSocket() is BufferingSocket bufferingSocket)
					{
						AccessTools.DeclaredField(typeof(ZRpc), "m_socket").SetValue(rpc2, bufferingSocket.Original);
						object? obj2 = AccessTools.DeclaredMethod(typeof(ZNet), "GetPeer", new Type[1] { typeof(ZRpc) }, (Type[])null).Invoke(__instance2, new object[1] { rpc2 });
						ZNetPeer val = (ZNetPeer)((obj2 is ZNetPeer) ? obj2 : null);
						if (val != null)
						{
							AccessTools.DeclaredField(typeof(ZNetPeer), "m_socket").SetValue(val, bufferingSocket.Original);
						}
					}
					BufferingSocket bufferingSocket2 = __state2[Assembly.GetExecutingAssembly()];
					bufferingSocket2.finished = true;
					for (int i = 0; i < bufferingSocket2.Package.Count; i++)
					{
						if (i == bufferingSocket2.versionMatchQueued)
						{
							bufferingSocket2.Original.VersionMatch();
						}
						bufferingSocket2.Original.Send(bufferingSocket2.Package[i]);
					}
					if (bufferingSocket2.Package.Count == bufferingSocket2.versionMatchQueued)
					{
						bufferingSocket2.Original.VersionMatch();
					}
				}
				IEnumerator sendAsync()
				{
					foreach (ConfigSync configSync in configSyncs)
					{
						List<PackageEntry> entries = new List<PackageEntry>();
						if (configSync.CurrentVersion != null)
						{
							entries.Add(new PackageEntry
							{
								section = "Internal",
								key = "serverversion",
								type = typeof(string),
								value = configSync.CurrentVersion
							});
						}
						MethodInfo listContainsId = AccessTools.DeclaredMethod(typeof(ZNet), "ListContainsId", (Type[])null, (Type[])null);
						SyncedList adminList = (SyncedList)AccessTools.DeclaredField(typeof(ZNet), "m_adminList").GetValue(ZNet.instance);
						entries.Add(new PackageEntry
						{
							section = "Internal",
							key = "lockexempt",
							type = typeof(bool),
							value = (((object)listContainsId == null) ? ((object)adminList.Contains(rpc2.GetSocket().GetHostName())) : listContainsId.Invoke(ZNet.instance, new object[2]
							{
								adminList,
								rpc2.GetSocket().GetHostName()
							}))
						});
						ZPackage package = ConfigsToPackage(configSync.allConfigs.Select((OwnConfigEntryBase c) => c.BaseConfig), configSync.allCustomValues, entries, partial: false);
						yield return ((MonoBehaviour)__instance2).StartCoroutine(configSync.sendZPackage(new List<ZNetPeer> { peer }, package));
					}
					SendBufferedData();
				}
			}
		}

		private class PackageEntry
		{
			public string section = null;

			public string key = null;

			public Type type = null;

			public object? value;
		}

		[HarmonyPatch(typeof(ConfigEntryBase), "GetSerializedValue")]
		private static class PreventSavingServerInfo
		{
			[HarmonyPrefix]
			private static bool Prefix(ConfigEntryBase __instance, ref string __result)
			{
				OwnConfigEntryBase ownConfigEntryBase = configData(__instance);
				if (ownConfigEntryBase == null || isWritableConfig(ownConfigEntryBase))
				{
					return true;
				}
				__result = TomlTypeConverter.ConvertToString(ownConfigEntryBase.LocalBaseValue, __instance.SettingType);
				return false;
			}
		}

		[HarmonyPatch(typeof(ConfigEntryBase), "SetSerializedValue")]
		private static class PreventConfigRereadChangingValues
		{
			[HarmonyPrefix]
			private static bool Prefix(ConfigEntryBase __instance, string value)
			{
				OwnConfigEntryBase ownConfigEntryBase = configData(__instance);
				if (ownConfigEntryBase == null || ownConfigEntryBase.LocalBaseValue == null)
				{
					return true;
				}
				try
				{
					ownConfigEntryBase.LocalBaseValue = TomlTypeConverter.ConvertToValue(value, __instance.SettingType);
				}
				catch (Exception ex)
				{
					Debug.LogWarning((object)$"Config value of setting \"{__instance.Definition}\" could not be parsed and will be ignored. Reason: {ex.Message}; Value: {value}");
				}
				return false;
			}
		}

		private class InvalidDeserializationTypeException : Exception
		{
			public string expected = null;

			public string received = null;

			public string field = "";
		}

		public static bool ProcessingServerUpdate;

		public readonly string Name;

		public string? DisplayName;

		public string? CurrentVersion;

		public string? MinimumRequiredVersion;

		public bool ModRequired = false;

		private bool? forceConfigLocking;

		private bool isSourceOfTruth = true;

		private static readonly HashSet<ConfigSync> configSyncs;

		private readonly HashSet<OwnConfigEntryBase> allConfigs = new HashSet<OwnConfigEntryBase>();

		private HashSet<CustomSyncedValueBase> allCustomValues = new HashSet<CustomSyncedValueBase>();

		private static bool isServer;

		private static bool lockExempt;

		private OwnConfigEntryBase? lockedConfig = null;

		private const byte PARTIAL_CONFIGS = 1;

		private const byte FRAGMENTED_CONFIG = 2;

		private const byte COMPRESSED_CONFIG = 4;

		private readonly Dictionary<string, SortedDictionary<int, byte[]>> configValueCache = new Dictionary<string, SortedDictionary<int, byte[]>>();

		private readonly List<KeyValuePair<long, string>> cacheExpirations = new List<KeyValuePair<long, string>>();

		private static long packageCounter;

		public bool IsLocked
		{
			get
			{
				bool? flag = forceConfigLocking;
				bool num;
				if (!flag.HasValue)
				{
					if (lockedConfig == null)
					{
						goto IL_0052;
					}
					num = ((IConvertible)lockedConfig.BaseConfig.BoxedValue).ToInt32(CultureInfo.InvariantCulture) != 0;
				}
				else
				{
					num = flag.GetValueOrDefault();
				}
				if (!num)
				{
					goto IL_0052;
				}
				int result = ((!lockExempt) ? 1 : 0);
				goto IL_0053;
				IL_0053:
				return (byte)result != 0;
				IL_0052:
				result = 0;
				goto IL_0053;
			}
			set
			{
				forceConfigLocking = value;
			}
		}

		public bool IsAdmin => lockExempt || isSourceOfTruth;

		public bool IsSourceOfTruth
		{
			get
			{
				return isSourceOfTruth;
			}
			private set
			{
				if (value != isSourceOfTruth)
				{
					isSourceOfTruth = value;
					this.SourceOfTruthChanged?.Invoke(value);
				}
			}
		}

		public bool InitialSyncDone { get; private set; } = false;


		public event Action<bool>? SourceOfTruthChanged;

		private event Action? lockedConfigChanged;

		static ConfigSync()
		{
			ProcessingServerUpdate = false;
			configSyncs = new HashSet<ConfigSync>();
			lockExempt = false;
			packageCounter = 0L;
			RuntimeHelpers.RunClassConstructor(typeof(VersionCheck).TypeHandle);
		}

		public ConfigSync(string name)
		{
			Name = name;
			configSyncs.Add(this);
			new VersionCheck(this);
		}

		public SyncedConfigEntry<T> AddConfigEntry<T>(ConfigEntry<T> configEntry)
		{
			ConfigEntry<T> configEntry2 = configEntry;
			OwnConfigEntryBase ownConfigEntryBase = configData((ConfigEntryBase)(object)configEntry2);
			SyncedConfigEntry<T> syncedEntry = ownConfigEntryBase as SyncedConfigEntry<T>;
			if (syncedEntry == null)
			{
				syncedEntry = new SyncedConfigEntry<T>(configEntry2);
				AccessTools.DeclaredField(typeof(ConfigDescription), "<Tags>k__BackingField").SetValue(((ConfigEntryBase)configEntry2).Description, new object[1]
				{
					new ConfigurationManagerAttributes()
				}.Concat(((ConfigEntryBase)configEntry2).Description.Tags ?? Array.Empty<object>()).Concat(new SyncedConfigEntry<T>[1] { syncedEntry }).ToArray());
				configEntry2.SettingChanged += delegate
				{
					if (!ProcessingServerUpdate && syncedEntry.SynchronizedConfig)
					{
						Broadcast(ZRoutedRpc.Everybody, (ConfigEntryBase)configEntry2);
					}
				};
				allConfigs.Add(syncedEntry);
			}
			return syncedEntry;
		}

		public SyncedConfigEntry<T> AddLockingConfigEntry<T>(ConfigEntry<T> lockingConfig) where T : IConvertible
		{
			if (lockedConfig != null)
			{
				throw new Exception("Cannot initialize locking ConfigEntry twice");
			}
			lockedConfig = AddConfigEntry<T>(lockingConfig);
			lockingConfig.SettingChanged += delegate
			{
				this.lockedConfigChanged?.Invoke();
			};
			return (SyncedConfigEntry<T>)lockedConfig;
		}

		internal void AddCustomValue(CustomSyncedValueBase customValue)
		{
			CustomSyncedValueBase customValue2 = customValue;
			if (allCustomValues.Select((CustomSyncedValueBase v) => v.Identifier).Concat(new string[1] { "serverversion" }).Contains(customValue2.Identifier))
			{
				throw new Exception("Cannot have multiple settings with the same name or with a reserved name (serverversion)");
			}
			allCustomValues.Add(customValue2);
			allCustomValues = new HashSet<CustomSyncedValueBase>(allCustomValues.OrderByDescending((CustomSyncedValueBase v) => v.Priority));
			customValue2.ValueChanged += delegate
			{
				if (!ProcessingServerUpdate)
				{
					Broadcast(ZRoutedRpc.Everybody, customValue2);
				}
			};
		}

		private void RPC_FromServerConfigSync(ZRpc rpc, ZPackage package)
		{
			lockedConfigChanged += serverLockedSettingChanged;
			IsSourceOfTruth = false;
			if (HandleConfigSyncRPC(0L, package, clientUpdate: false))
			{
				InitialSyncDone = true;
			}
		}

		private void RPC_FromOtherClientConfigSync(long sender, ZPackage package)
		{
			HandleConfigSyncRPC(sender, package, clientUpdate: true);
		}

		private bool HandleConfigSyncRPC(long sender, ZPackage package, bool clientUpdate)
		{
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Expected O, but got Unknown
			//IL_0250: Unknown result type (might be due to invalid IL or missing references)
			//IL_0257: Expected O, but got Unknown
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f1: Expected O, but got Unknown
			try
			{
				if (isServer && IsLocked)
				{
					ZRpc? currentRpc = SnatchCurrentlyHandlingRPC.currentRpc;
					object obj;
					if (currentRpc == null)
					{
						obj = null;
					}
					else
					{
						ISocket socket = currentRpc.GetSocket();
						obj = ((socket != null) ? socket.GetHostName() : null);
					}
					string text = (string)obj;
					if (text != null)
					{
						MethodInfo methodInfo = AccessTools.DeclaredMethod(typeof(ZNet), "ListContainsId", (Type[])null, (Type[])null);
						SyncedList val = (SyncedList)AccessTools.DeclaredField(typeof(ZNet), "m_adminList").GetValue(ZNet.instance);
						if (!(((object)methodInfo == null) ? val.Contains(text) : ((bool)methodInfo.Invoke(ZNet.instance, new object[2] { val, text }))))
						{
							return false;
						}
					}
				}
				cacheExpirations.RemoveAll(delegate(KeyValuePair<long, string> kv)
				{
					if (kv.Key < DateTimeOffset.Now.Ticks)
					{
						configValueCache.Remove(kv.Value);
						return true;
					}
					return false;
				});
				byte b = package.ReadByte();
				if ((b & 2u) != 0)
				{
					long num = package.ReadLong();
					string text2 = sender.ToString() + num;
					if (!configValueCache.TryGetValue(text2, out SortedDictionary<int, byte[]> value))
					{
						value = new SortedDictionary<int, byte[]>();
						configValueCache[text2] = value;
						cacheExpirations.Add(new KeyValuePair<long, string>(DateTimeOffset.Now.AddSeconds(60.0).Ticks, text2));
					}
					int key = package.ReadInt();
					int num2 = package.ReadInt();
					value.Add(key, package.ReadByteArray());
					if (value.Count < num2)
					{
						return false;
					}
					configValueCache.Remove(text2);
					package = new ZPackage(value.Values.SelectMany((byte[] a) => a).ToArray());
					b = package.ReadByte();
				}
				ProcessingServerUpdate = true;
				if ((b & 4u) != 0)
				{
					byte[] buffer = package.ReadByteArray();
					MemoryStream stream = new MemoryStream(buffer);
					MemoryStream memoryStream = new MemoryStream();
					using (DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress))
					{
						deflateStream.CopyTo(memoryStream);
					}
					package = new ZPackage(memoryStream.ToArray());
					b = package.ReadByte();
				}
				if ((b & 1) == 0)
				{
					resetConfigsFromServer();
				}
				ParsedConfigs parsedConfigs = ReadConfigsFromPackage(package);
				ConfigFile val2 = null;
				bool saveOnConfigSet = false;
				foreach (KeyValuePair<OwnConfigEntryBase, object> configValue in parsedConfigs.configValues)
				{
					if (!isServer && configValue.Key.LocalBaseValue == null)
					{
						configValue.Key.LocalBaseValue = configValue.Key.BaseConfig.BoxedValue;
					}
					if (val2 == null)
					{
						val2 = configValue.Key.BaseConfig.ConfigFile;
						saveOnConfigSet = val2.SaveOnConfigSet;
						val2.SaveOnConfigSet = false;
					}
					configValue.Key.BaseConfig.BoxedValue = configValue.Value;
				}
				if (val2 != null)
				{
					val2.SaveOnConfigSet = saveOnConfigSet;
				}
				foreach (KeyValuePair<CustomSyncedValueBase, object> customValue in parsedConfigs.customValues)
				{
					if (!isServer)
					{
						CustomSyncedValueBase key2 = customValue.Key;
						if (key2.LocalBaseValue == null)
						{
							key2.LocalBaseValue = customValue.Key.BoxedValue;
						}
					}
					customValue.Key.BoxedValue = customValue.Value;
				}
				Debug.Log((object)string.Format("Received {0} configs and {1} custom values from {2} for mod {3}", parsedConfigs.configValues.Count, parsedConfigs.customValues.Count, (isServer || clientUpdate) ? $"client {sender}" : "the server", DisplayName ?? Name));
				if (!isServer)
				{
					serverLockedSettingChanged();
				}
				return true;
			}
			finally
			{
				ProcessingServerUpdate = false;
			}
		}

		private ParsedConfigs ReadConfigsFromPackage(ZPackage package)
		{
			ParsedConfigs parsedConfigs = new ParsedConfigs();
			Dictionary<string, OwnConfigEntryBase> dictionary = allConfigs.Where((OwnConfigEntryBase c) => c.SynchronizedConfig).ToDictionary((OwnConfigEntryBase c) => c.BaseConfig.Definition.Section + "_" + c.BaseConfig.Definition.Key, (OwnConfigEntryBase c) => c);
			Dictionary<string, CustomSyncedValueBase> dictionary2 = allCustomValues.ToDictionary((CustomSyncedValueBase c) => c.Identifier, (CustomSyncedValueBase c) => c);
			int num = package.ReadInt();
			for (int i = 0; i < num; i++)
			{
				string text = package.ReadString();
				string text2 = package.ReadString();
				string text3 = package.ReadString();
				Type type = Type.GetType(text3);
				if (text3 == "" || type != null)
				{
					object obj;
					try
					{
						obj = ((text3 == "") ? null : ReadValueWithTypeFromZPackage(package, type));
					}
					catch (InvalidDeserializationTypeException ex)
					{
						Debug.LogWarning((object)("Got unexpected struct internal type " + ex.received + " for field " + ex.field + " struct " + text3 + " for " + text2 + " in section " + text + " for mod " + (DisplayName ?? Name) + ", expecting " + ex.expected));
						continue;
					}
					OwnConfigEntryBase value2;
					if (text == "Internal")
					{
						CustomSyncedValueBase value;
						if (text2 == "serverversion")
						{
							if (obj?.ToString() != CurrentVersion)
							{
								Debug.LogWarning((object)("Received server version is not equal: server version = " + (obj?.ToString() ?? "null") + "; local version = " + (CurrentVersion ?? "unknown")));
							}
						}
						else if (text2 == "lockexempt")
						{
							if (obj is bool flag)
							{
								lockExempt = flag;
							}
						}
						else if (dictionary2.TryGetValue(text2, out value))
						{
							if ((text3 == "" && (!value.Type.IsValueType || Nullable.GetUnderlyingType(value.Type) != null)) || GetZPackageTypeString(value.Type) == text3)
							{
								parsedConfigs.customValues[value] = obj;
								continue;
							}
							Debug.LogWarning((object)("Got unexpected type " + text3 + " for internal value " + text2 + " for mod " + (DisplayName ?? Name) + ", expecting " + value.Type.AssemblyQualifiedName));
						}
					}
					else if (dictionary.TryGetValue(text + "_" + text2, out value2))
					{
						Type type2 = configType(value2.BaseConfig);
						if ((text3 == "" && (!type2.IsValueType || Nullable.GetUnderlyingType(type2) != null)) || GetZPackageTypeString(type2) == text3)
						{
							parsedConfigs.configValues[value2] = obj;
							continue;
						}
						Debug.LogWarning((object)("Got unexpected type " + text3 + " for " + text2 + " in section " + text + " for mod " + (DisplayName ?? Name) + ", expecting " + type2.AssemblyQualifiedName));
					}
					else
					{
						Debug.LogWarning((object)("Received unknown config entry " + text2 + " in section " + text + " for mod " + (DisplayName ?? Name) + ". This may happen if client and server versions of the mod do not match."));
					}
					continue;
				}
				Debug.LogWarning((object)("Got invalid type " + text3 + ", abort reading of received configs"));
				return new ParsedConfigs();
			}
			return parsedConfigs;
		}

		private static bool isWritableConfig(OwnConfigEntryBase config)
		{
			OwnConfigEntryBase config2 = config;
			ConfigSync configSync = configSyncs.FirstOrDefault((ConfigSync cs) => cs.allConfigs.Contains(config2));
			if (configSync == null)
			{
				return true;
			}
			return configSync.IsSourceOfTruth || !config2.SynchronizedConfig || config2.LocalBaseValue == null || (!configSync.IsLocked && (config2 != configSync.lockedConfig || lockExempt));
		}

		private void serverLockedSettingChanged()
		{
			foreach (OwnConfigEntryBase allConfig in allConfigs)
			{
				configAttribute<ConfigurationManagerAttributes>(allConfig.BaseConfig).ReadOnly = !isWritableConfig(allConfig);
			}
		}

		private void resetConfigsFromServer()
		{
			ConfigFile val = null;
			bool saveOnConfigSet = false;
			foreach (OwnConfigEntryBase item in allConfigs.Where((OwnConfigEntryBase config) => config.LocalBaseValue != null))
			{
				if (val == null)
				{
					val = item.BaseConfig.ConfigFile;
					saveOnConfigSet = val.SaveOnConfigSet;
					val.SaveOnConfigSet = false;
				}
				item.BaseConfig.BoxedValue = item.LocalBaseValue;
				item.LocalBaseValue = null;
			}
			if (val != null)
			{
				val.SaveOnConfigSet = saveOnConfigSet;
			}
			foreach (CustomSyncedValueBase item2 in allCustomValues.Where((CustomSyncedValueBase config) => config.LocalBaseValue != null))
			{
				item2.BoxedValue = item2.LocalBaseValue;
				item2.LocalBaseValue = null;
			}
			lockedConfigChanged -= serverLockedSettingChanged;
			serverLockedSettingChanged();
		}

		private IEnumerator<bool> distributeConfigToPeers(ZNetPeer peer, ZPackage package)
		{
			ZNetPeer peer2 = peer;
			ZRoutedRpc rpc = ZRoutedRpc.instance;
			if (rpc == null)
			{
				yield break;
			}
			byte[] data = package.GetArray();
			if (data != null && data.LongLength > 250000)
			{
				int fragments = (int)(1 + (data.LongLength - 1) / 250000);
				long packageIdentifier = ++packageCounter;
				int fragment = 0;
				while (fragment < fragments)
				{
					foreach (bool item in waitForQueue())
					{
						yield return item;
					}
					if (peer2.m_socket.IsConnected())
					{
						ZPackage fragmentedPackage = new ZPackage();
						fragmentedPackage.Write((byte)2);
						fragmentedPackage.Write(packageIdentifier);
						fragmentedPackage.Write(fragment);
						fragmentedPackage.Write(fragments);
						fragmentedPackage.Write(data.Skip(250000 * fragment).Take(250000).ToArray());
						SendPackage(fragmentedPackage);
						if (fragment != fragments - 1)
						{
							yield return true;
						}
						int num = fragment + 1;
						fragment = num;
						continue;
					}
					break;
				}
				yield break;
			}
			foreach (bool item2 in waitForQueue())
			{
				yield return item2;
			}
			SendPackage(package);
			void SendPackage(ZPackage pkg)
			{
				string text = Name + " ConfigSync";
				if (isServer)
				{
					peer2.m_rpc.Invoke(text, new object[1] { pkg });
				}
				else
				{
					rpc.InvokeRoutedRPC(peer2.m_server ? 0 : peer2.m_uid, text, new object[1] { pkg });
				}
			}
			IEnumerable<bool> waitForQueue()
			{
				float timeout = Time.time + 30f;
				while (peer2.m_socket.GetSendQueueSize() > 20000)
				{
					if (Time.time > timeout)
					{
						Debug.Log((object)$"Disconnecting {peer2.m_uid} after 30 seconds config sending timeout");
						peer2.m_rpc.Invoke("Error", new object[1] { (object)(ConnectionStatus)5 });
						ZNet.instance.Disconnect(peer2);
						break;
					}
					yield return false;
				}
			}
		}

		private IEnumerator sendZPackage(long target, ZPackage package)
		{
			if (!Object.op_Implicit((Object)(object)ZNet.instance))
			{
				return Enumerable.Empty<object>().GetEnumerator();
			}
			List<ZNetPeer> list = (List<ZNetPeer>)AccessTools.DeclaredField(typeof(ZRoutedRpc), "m_peers").GetValue(ZRoutedRpc.instance);
			if (target != ZRoutedRpc.Everybody)
			{
				list = list.Where((ZNetPeer p) => p.m_uid == target).ToList();
			}
			return sendZPackage(list, package);
		}

		private IEnumerator sendZPackage(List<ZNetPeer> peers, ZPackage package)
		{
			ZPackage package2 = package;
			if (!Object.op_Implicit((Object)(object)ZNet.instance))
			{
				yield break;
			}
			byte[] rawData = package2.GetArray();
			if (rawData != null && rawData.LongLength > 10000)
			{
				ZPackage compressedPackage = new ZPackage();
				compressedPackage.Write((byte)4);
				MemoryStream output = new MemoryStream();
				using (DeflateStream deflateStream = new DeflateStream(output, CompressionLevel.Optimal))
				{
					deflateStream.Write(rawData, 0, rawData.Length);
				}
				compressedPackage.Write(output.ToArray());
				package2 = compressedPackage;
			}
			List<IEnumerator<bool>> writers = (from peer in peers
				where peer.IsReady()
				select peer into p
				select distributeConfigToPeers(p, package2)).ToList();
			writers.RemoveAll((IEnumerator<bool> writer) => !writer.MoveNext());
			while (writers.Count > 0)
			{
				yield return null;
				writers.RemoveAll((IEnumerator<bool> writer) => !writer.MoveNext());
			}
		}

		private void Broadcast(long target, params ConfigEntryBase[] configs)
		{
			if (!IsLocked || isServer)
			{
				ZPackage package = ConfigsToPackage(configs);
				ZNet instance = ZNet.instance;
				if (instance != null)
				{
					((MonoBehaviour)instance).StartCoroutine(sendZPackage(target, package));
				}
			}
		}

		private void Broadcast(long target, params CustomSyncedValueBase[] customValues)
		{
			if (!IsLocked || isServer)
			{
				ZPackage package = ConfigsToPackage(null, customValues);
				ZNet instance = ZNet.instance;
				if (instance != null)
				{
					((MonoBehaviour)instance).StartCoroutine(sendZPackage(target, package));
				}
			}
		}

		private static OwnConfigEntryBase? configData(ConfigEntryBase config)
		{
			return config.Description.Tags?.OfType<OwnConfigEntryBase>().SingleOrDefault();
		}

		public static SyncedConfigEntry<T>? ConfigData<T>(ConfigEntry<T> config)
		{
			return ((ConfigEntryBase)config).Description.Tags?.OfType<SyncedConfigEntry<T>>().SingleOrDefault();
		}

		private static T configAttribute<T>(ConfigEntryBase config)
		{
			return config.Description.Tags.OfType<T>().First();
		}

		private static Type configType(ConfigEntryBase config)
		{
			return configType(config.SettingType);
		}

		private static Type configType(Type type)
		{
			return type.IsEnum ? Enum.GetUnderlyingType(type) : type;
		}

		private static ZPackage ConfigsToPackage(IEnumerable<ConfigEntryBase>? configs = null, IEnumerable<CustomSyncedValueBase>? customValues = null, IEnumerable<PackageEntry>? packageEntries = null, bool partial = true)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Expected O, but got Unknown
			List<ConfigEntryBase> list = configs?.Where((ConfigEntryBase config) => configData(config).SynchronizedConfig).ToList() ?? new List<ConfigEntryBase>();
			List<CustomSyncedValueBase> list2 = customValues?.ToList() ?? new List<CustomSyncedValueBase>();
			ZPackage val = new ZPackage();
			val.Write((byte)(partial ? 1 : 0));
			val.Write(list.Count + list2.Count + (packageEntries?.Count() ?? 0));
			foreach (PackageEntry item in packageEntries ?? Array.Empty<PackageEntry>())
			{
				AddEntryToPackage(val, item);
			}
			foreach (CustomSyncedValueBase item2 in list2)
			{
				AddEntryToPackage(val, new PackageEntry
				{
					section = "Internal",
					key = item2.Identifier,
					type = item2.Type,
					value = item2.BoxedValue
				});
			}
			foreach (ConfigEntryBase item3 in list)
			{
				AddEntryToPackage(val, new PackageEntry
				{
					section = item3.Definition.Section,
					key = item3.Definition.Key,
					type = configType(item3),
					value = item3.BoxedValue
				});
			}
			return val;
		}

		private static void AddEntryToPackage(ZPackage package, PackageEntry entry)
		{
			package.Write(entry.section);
			package.Write(entry.key);
			package.Write((entry.value == null) ? "" : GetZPackageTypeString(entry.type));
			AddValueToZPackage(package, entry.value);
		}

		private static string GetZPackageTypeString(Type type)
		{
			return type.AssemblyQualifiedName;
		}

		private static void AddValueToZPackage(ZPackage package, object? value)
		{
			Type type = value?.GetType();
			if (value is Enum)
			{
				value = ((IConvertible)value).ToType(Enum.GetUnderlyingType(value.GetType()), CultureInfo.InvariantCulture);
			}
			else
			{
				if (value is ICollection collection)
				{
					package.Write(collection.Count);
					{
						foreach (object item in collection)
						{
							AddValueToZPackage(package, item);
						}
						return;
					}
				}
				if ((object)type != null && type.IsValueType && !type.IsPrimitive)
				{
					FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
					package.Write(fields.Length);
					FieldInfo[] array = fields;
					foreach (FieldInfo fieldInfo in array)
					{
						package.Write(GetZPackageTypeString(fieldInfo.FieldType));
						AddValueToZPackage(package, fieldInfo.GetValue(value));
					}
					return;
				}
			}
			ZRpc.Serialize(new object[1] { value }, ref package);
		}

		private static object ReadValueWithTypeFromZPackage(ZPackage package, Type type)
		{
			if ((object)type != null && type.IsValueType && !type.IsPrimitive && !type.IsEnum)
			{
				FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				int num = package.ReadInt();
				if (num != fields.Length)
				{
					throw new InvalidDeserializationTypeException
					{
						received = $"(field count: {num})",
						expected = $"(field count: {fields.Length})"
					};
				}
				object uninitializedObject = FormatterServices.GetUninitializedObject(type);
				FieldInfo[] array = fields;
				foreach (FieldInfo fieldInfo in array)
				{
					string text = package.ReadString();
					if (text != GetZPackageTypeString(fieldInfo.FieldType))
					{
						throw new InvalidDeserializationTypeException
						{
							received = text,
							expected = GetZPackageTypeString(fieldInfo.FieldType),
							field = fieldInfo.Name
						};
					}
					fieldInfo.SetValue(uninitializedObject, ReadValueWithTypeFromZPackage(package, fieldInfo.FieldType));
				}
				return uninitializedObject;
			}
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<, >))
			{
				int num2 = package.ReadInt();
				IDictionary dictionary = (IDictionary)Activator.CreateInstance(type);
				Type type2 = typeof(KeyValuePair<, >).MakeGenericType(type.GenericTypeArguments);
				FieldInfo field = type2.GetField("key", BindingFlags.Instance | BindingFlags.NonPublic);
				FieldInfo field2 = type2.GetField("value", BindingFlags.Instance | BindingFlags.NonPublic);
				for (int j = 0; j < num2; j++)
				{
					object obj = ReadValueWithTypeFromZPackage(package, type2);
					dictionary.Add(field.GetValue(obj), field2.GetValue(obj));
				}
				return dictionary;
			}
			if (type != typeof(List<string>) && type.IsGenericType)
			{
				Type type3 = typeof(ICollection<>).MakeGenericType(type.GenericTypeArguments[0]);
				if ((object)type3 != null && type3.IsAssignableFrom(type))
				{
					int num3 = package.ReadInt();
					object obj2 = Activator.CreateInstance(type);
					MethodInfo method = type3.GetMethod("Add");
					for (int k = 0; k < num3; k++)
					{
						method.Invoke(obj2, new object[1] { ReadValueWithTypeFromZPackage(package, type.GenericTypeArguments[0]) });
					}
					return obj2;
				}
			}
			ParameterInfo parameterInfo = (ParameterInfo)FormatterServices.GetUninitializedObject(typeof(ParameterInfo));
			AccessTools.DeclaredField(typeof(ParameterInfo), "ClassImpl").SetValue(parameterInfo, type);
			List<object> source = new List<object>();
			ZRpc.Deserialize(new ParameterInfo[2] { null, parameterInfo }, package, ref source);
			return source.First();
		}
	}
	[PublicAPI]
	[HarmonyPatch]
	internal class VersionCheck
	{
		private static readonly HashSet<VersionCheck> versionChecks;

		private static readonly Dictionary<string, string> notProcessedNames;

		public string Name;

		private string? displayName;

		private string? currentVersion;

		private string? minimumRequiredVersion;

		public bool ModRequired = true;

		private string? ReceivedCurrentVersion;

		private string? ReceivedMinimumRequiredVersion;

		private readonly List<ZRpc> ValidatedClients = new List<ZRpc>();

		private ConfigSync? ConfigSync;

		public string DisplayName
		{
			get
			{
				return displayName ?? Name;
			}
			set
			{
				displayName = value;
			}
		}

		public string CurrentVersion
		{
			get
			{
				return currentVersion ?? "0.0.0";
			}
			set
			{
				currentVersion = value;
			}
		}

		public string MinimumRequiredVersion
		{
			get
			{
				return minimumRequiredVersion ?? (ModRequired ? CurrentVersion : "0.0.0");
			}
			set
			{
				minimumRequiredVersion = value;
			}
		}

		private static void PatchServerSync()
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Expected O, but got Unknown
			Patches patchInfo = PatchProcessor.GetPatchInfo((MethodBase)AccessTools.DeclaredMethod(typeof(ZNet), "Awake", (Type[])null, (Type[])null));
			if (patchInfo != null && patchInfo.Postfixes.Count((Patch p) => p.PatchMethod.DeclaringType == typeof(ConfigSync.RegisterRPCPatch)) > 0)
			{
				return;
			}
			Harmony val = new Harmony("org.bepinex.helpers.ServerSync");
			foreach (Type item in from t in typeof(ConfigSync).GetNestedTypes(BindingFlags.NonPublic).Concat(new Type[1] { typeof(VersionCheck) })
				where t.IsClass
				select t)
			{
				val.PatchAll(item);
			}
		}

		static VersionCheck()
		{
			versionChecks = new HashSet<VersionCheck>();
			notProcessedNames = new Dictionary<string, string>();
			typeof(ThreadingHelper).GetMethod("StartSyncInvoke").Invoke(ThreadingHelper.Instance, new object[1]
			{
				new Action(PatchServerSync)
			});
		}

		public VersionCheck(string name)
		{
			Name = name;
			ModRequired = true;
			versionChecks.Add(this);
		}

		public VersionCheck(ConfigSync configSync)
		{
			ConfigSync = configSync;
			Name = ConfigSync.Name;
			versionChecks.Add(this);
		}

		public void Initialize()
		{
			ReceivedCurrentVersion = null;
			ReceivedMinimumRequiredVersion = null;
			if (ConfigSync != null)
			{
				Name = ConfigSync.Name;
				DisplayName = ConfigSync.DisplayName;
				CurrentVersion = ConfigSync.CurrentVersion;
				MinimumRequiredVersion = ConfigSync.MinimumRequiredVersion;
				ModRequired = ConfigSync.ModRequired;
			}
		}

		private bool IsVersionOk()
		{
			if (ReceivedMinimumRequiredVersion == null || ReceivedCurrentVersion == null)
			{
				return !ModRequired;
			}
			bool flag = new System.Version(CurrentVersion) >= new System.Version(ReceivedMinimumRequiredVersion);
			bool flag2 = new System.Version(ReceivedCurrentVersion) >= new System.Version(MinimumRequiredVersion);
			return flag && flag2;
		}

		private string ErrorClient()
		{
			if (ReceivedMinimumRequiredVersion == null)
			{
				return DisplayName + " is not installed on the server.";
			}
			return (new System.Version(CurrentVersion) >= new System.Version(ReceivedMinimumRequiredVersion)) ? (DisplayName + " may not be higher than version " + ReceivedCurrentVersion + ". You have version " + CurrentVersion + ".") : (DisplayName + " needs to be at least version " + ReceivedMinimumRequiredVersion + ". You have version " + CurrentVersion + ".");
		}

		private string ErrorServer(ZRpc rpc)
		{
			return "Disconnect: The client (" + rpc.GetSocket().GetHostName() + ") doesn't have the correct " + DisplayName + " version " + MinimumRequiredVersion;
		}

		private string Error(ZRpc? rpc = null)
		{
			return (rpc == null) ? ErrorClient() : ErrorServer(rpc);
		}

		private static VersionCheck[] GetFailedClient()
		{
			return versionChecks.Where((VersionCheck check) => !check.IsVersionOk()).ToArray();
		}

		private static VersionCheck[] GetFailedServer(ZRpc rpc)
		{
			ZRpc rpc2 = rpc;
			return versionChecks.Where((VersionCheck check) => check.ModRequired && !check.ValidatedClients.Contains(rpc2)).ToArray();
		}

		private static void Logout()
		{
			Game.instance.Logout(true, true);
			AccessTools.DeclaredField(typeof(ZNet), "m_connectionStatus").SetValue(null, (object)(ConnectionStatus)3);
		}

		private static void DisconnectClient(ZRpc rpc)
		{
			rpc.Invoke("Error", new object[1] { 3 });
		}

		private static void CheckVersion(ZRpc rpc, ZPackage pkg)
		{
			CheckVersion(rpc, pkg, null);
		}

		private static void CheckVersion(ZRpc rpc, ZPackage pkg, Action<ZRpc, ZPackage>? original)
		{
			string text = pkg.ReadString();
			string text2 = pkg.ReadString();
			string text3 = pkg.ReadString();
			bool flag = false;
			foreach (VersionCheck versionCheck in versionChecks)
			{
				if (!(text != versionCheck.Name))
				{
					Debug.Log((object)("Received " + versionCheck.DisplayName + " version " + text3 + " and minimum version " + text2 + " from the " + (ZNet.instance.IsServer() ? "client" : "server") + "."));
					versionCheck.ReceivedMinimumRequiredVersion = text2;
					versionCheck.ReceivedCurrentVersion = text3;
					if (ZNet.instance.IsServer() && versionCheck.IsVersionOk())
					{
						versionCheck.ValidatedClients.Add(rpc);
					}
					flag = true;
				}
			}
			if (flag)
			{
				return;
			}
			pkg.SetPos(0);
			if (original != null)
			{
				original(rpc, pkg);
				if (pkg.GetPos() == 0)
				{
					notProcessedNames.Add(text, text3);
				}
			}
		}

		[HarmonyPatch(typeof(ZNet), "RPC_PeerInfo")]
		[HarmonyPrefix]
		private static bool RPC_PeerInfo(ZRpc rpc, ZNet __instance)
		{
			VersionCheck[] array = (__instance.IsServer() ? GetFailedServer(rpc) : GetFailedClient());
			if (array.Length == 0)
			{
				return true;
			}
			VersionCheck[] array2 = array;
			foreach (VersionCheck versionCheck in array2)
			{
				Debug.LogWarning((object)versionCheck.Error(rpc));
			}
			if (__instance.IsServer())
			{
				DisconnectClient(rpc);
			}
			else
			{
				Logout();
			}
			return false;
		}

		[HarmonyPatch(typeof(ZNet), "OnNewConnection")]
		[HarmonyPrefix]
		private static void RegisterAndCheckVersion(ZNetPeer peer, ZNet __instance)
		{
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Expected O, but got Unknown
			notProcessedNames.Clear();
			IDictionary dictionary = (IDictionary)typeof(ZRpc).GetField("m_functions", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(peer.m_rpc);
			if (dictionary.Contains(StringExtensionMethods.GetStableHashCode("ServerSync VersionCheck")))
			{
				object obj = dictionary[StringExtensionMethods.GetStableHashCode("ServerSync VersionCheck")];
				Action<ZRpc, ZPackage> action = (Action<ZRpc, ZPackage>)obj.GetType().GetField("m_action", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(obj);
				peer.m_rpc.Register<ZPackage>("ServerSync VersionCheck", (Action<ZRpc, ZPackage>)delegate(ZRpc rpc, ZPackage pkg)
				{
					CheckVersion(rpc, pkg, action);
				});
			}
			else
			{
				peer.m_rpc.Register<ZPackage>("ServerSync VersionCheck", (Action<ZRpc, ZPackage>)CheckVersion);
			}
			foreach (VersionCheck versionCheck in versionChecks)
			{
				versionCheck.Initialize();
				if (versionCheck.ModRequired || __instance.IsServer())
				{
					Debug.Log((object)("Sending " + versionCheck.DisplayName + " version " + versionCheck.CurrentVersion + " and minimum version " + versionCheck.MinimumRequiredVersion + " to the " + (__instance.IsServer() ? "client" : "server") + "."));
					ZPackage val = new ZPackage();
					val.Write(versionCheck.Name);
					val.Write(versionCheck.MinimumRequiredVersion);
					val.Write(versionCheck.CurrentVersion);
					peer.m_rpc.Invoke("ServerSync VersionCheck", new object[1] { val });
				}
			}
		}

		[HarmonyPatch(typeof(ZNet), "Disconnect")]
		[HarmonyPrefix]
		private static void RemoveDisconnected(ZNetPeer peer, ZNet __instance)
		{
			if (!__instance.IsServer())
			{
				return;
			}
			foreach (VersionCheck versionCheck in versionChecks)
			{
				versionCheck.ValidatedClients.Remove(peer.m_rpc);
			}
		}

		[HarmonyPatch(typeof(FejdStartup), "ShowConnectError")]
		[HarmonyPostfix]
		private static void ShowConnectionError(FejdStartup __instance)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Invalid comparison between Unknown and I4
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_01de: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_020a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_021e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0229: Unknown result type (might be due to invalid IL or missing references)
			if (!__instance.m_connectionFailedPanel.activeSelf || (int)ZNet.GetConnectionStatus() != 3)
			{
				return;
			}
			bool flag = false;
			VersionCheck[] failedClient = GetFailedClient();
			if (failedClient.Length != 0)
			{
				string text = string.Join("\n", failedClient.Select((VersionCheck check) => check.Error()));
				TMP_Text connectionFailedError = __instance.m_connectionFailedError;
				connectionFailedError.text = connectionFailedError.text + "\n" + text;
				flag = true;
			}
			foreach (KeyValuePair<string, string> item in notProcessedNames.OrderBy<KeyValuePair<string, string>, string>((KeyValuePair<string, string> kv) => kv.Key))
			{
				if (!__instance.m_connectionFailedError.text.Contains(item.Key))
				{
					TMP_Text connectionFailedError2 = __instance.m_connectionFailedError;
					connectionFailedError2.text = connectionFailedError2.text + "\nServer expects you to have " + item.Key + " (Version: " + item.Value + ") installed.";
					flag = true;
				}
			}
			if (flag)
			{
				RectTransform component = ((Component)__instance.m_connectionFailedPanel.transform.Find("Image")).GetComponent<RectTransform>();
				Vector2 sizeDelta = component.sizeDelta;
				sizeDelta.x = 675f;
				component.sizeDelta = sizeDelta;
				__instance.m_connectionFailedError.ForceMeshUpdate(false, false);
				float num = __instance.m_connectionFailedError.renderedHeight + 105f;
				RectTransform component2 = ((Component)((Component)component).transform.Find("ButtonOk")).GetComponent<RectTransform>();
				component2.anchoredPosition = new Vector2(component2.anchoredPosition.x, component2.anchoredPosition.y - (num - component.sizeDelta.y) / 2f);
				sizeDelta = component.sizeDelta;
				sizeDelta.y = num;
				component.sizeDelta = sizeDelta;
			}
		}
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
}
namespace YamlDotNet
{
	internal sealed class CultureInfoAdapter : CultureInfo
	{
		private readonly IFormatProvider provider;

		public CultureInfoAdapter(CultureInfo baseCulture, IFormatProvider provider)
			: base(baseCulture.Name)
		{
			this.provider = provider;
		}

		public override object? GetFormat(Type formatType)
		{
			return provider.GetFormat(formatType);
		}
	}
	internal static class PropertyInfoExtensions
	{
		public static object? ReadValue(this PropertyInfo property, object target)
		{
			return property.GetValue(target, null);
		}
	}
	internal static class ReflectionExtensions
	{
		private static readonly Func<PropertyInfo, bool> IsInstance = (PropertyInfo property) => !(property.GetMethod ?? property.SetMethod).IsStatic;

		private static readonly Func<PropertyInfo, bool> IsInstancePublic = (PropertyInfo property) => IsInstance(property) && (property.GetMethod ?? property.SetMethod).IsPublic;

		public static Type? BaseType(this Type type)
		{
			return type.GetTypeInfo().BaseType;
		}

		public static bool IsValueType(this Type type)
		{
			return type.GetTypeInfo().IsValueType;
		}

		public static bool IsGenericType(this Type type)
		{
			return type.GetTypeInfo().IsGenericType;
		}

		public static bool IsGenericTypeDefinition(this Type type)
		{
			return type.GetTypeInfo().IsGenericTypeDefinition;
		}

		public static bool IsInterface(this Type type)
		{
			return type.GetTypeInfo().IsInterface;
		}

		public static bool IsEnum(this Type type)
		{
			return type.GetTypeInfo().IsEnum;
		}

		public static bool HasDefaultConstructor(this Type type, bool allowPrivateConstructors)
		{
			TypeInfo typeInfo = type.GetTypeInfo();
			if (!typeInfo.IsValueType)
			{
				return typeInfo.DeclaredConstructors.Any((ConstructorInfo c) => (c.IsPublic || (allowPrivateConstructors && c.IsPrivate)) && !c.IsStatic && c.GetParameters().Length == 0);
			}
			return true;
		}

		public static bool IsAssignableFrom(this Type type, Type source)
		{
			return type.IsAssignableFrom(source.GetTypeInfo());
		}

		public static bool IsAssignableFrom(this Type type, TypeInfo source)
		{
			return type.GetTypeInfo().IsAssignableFrom(source);
		}

		public static TypeCode GetTypeCode(this Type type)
		{
			if (type.IsEnum())
			{
				type = Enum.GetUnderlyingType(type);
			}
			if (type == typeof(bool))
			{
				return TypeCode.Boolean;
			}
			if (type == typeof(char))
			{
				return TypeCode.Char;
			}
			if (type == typeof(sbyte))
			{
				return TypeCode.SByte;
			}
			if (type == typeof(byte))
			{
				return TypeCode.Byte;
			}
			if (type == typeof(short))
			{
				return TypeCode.Int16;
			}
			if (type == typeof(ushort))
			{
				return TypeCode.UInt16;
			}
			if (type == typeof(int))
			{
				return TypeCode.Int32;
			}
			if (type == typeof(uint))
			{
				return TypeCode.UInt32;
			}
			if (type == typeof(long))
			{
				return TypeCode.Int64;
			}
			if (type == typeof(ulong))
			{
				return TypeCode.UInt64;
			}
			if (type == typeof(float))
			{
				return TypeCode.Single;
			}
			if (type == typeof(double))
			{
				return TypeCode.Double;
			}
			if (type == typeof(decimal))
			{
				return TypeCode.Decimal;
			}
			if (type == typeof(DateTime))
			{
				return TypeCode.DateTime;
			}
			if (type == typeof(string))
			{
				return TypeCode.String;
			}
			return TypeCode.Object;
		}

		public static bool IsDbNull(this object value)
		{
			return value?.GetType()?.FullName == "System.DBNull";
		}

		public static Type[] GetGenericArguments(this Type type)
		{
			return type.GetTypeInfo().GenericTypeArguments;
		}

		public static PropertyInfo? GetPublicProperty(this Type type, string name)
		{
			return type.GetRuntimeProperty(name);
		}

		public static FieldInfo? GetPublicStaticField(this Type type, string name)
		{
			return type.GetRuntimeField(name);
		}

		public static IEnumerable<PropertyInfo> GetProperties(this Type type, bool includeNonPublic)
		{
			Func<PropertyInfo, bool> predicate = (includeNonPublic ? IsInstance : IsInstancePublic);
			if (!type.IsInterface())
			{
				return type.GetRuntimeProperties().Where(predicate);
			}
			return new Type[1] { type }.Concat(type.GetInterfaces()).SelectMany((Type i) => i.GetRuntimeProperties().Where(predicate));
		}

		public static IEnumerable<PropertyInfo> GetPublicProperties(this Type type)
		{
			return type.GetProperties(includeNonPublic: false);
		}

		public static IEnumerable<FieldInfo> GetPublicFields(this Type type)
		{
			return from f in type.GetRuntimeFields()
				where !f.IsStatic && f.IsPublic
				select f;
		}

		public static IEnumerable<MethodInfo> GetPublicStaticMethods(this Type type)
		{
			return from m in type.GetRuntimeMethods()
				where m.IsPublic && m.IsStatic
				select m;
		}

		public static MethodInfo GetPrivateStaticMethod(this Type type, string name)
		{
			string name2 = name;
			return type.GetRuntimeMethods().FirstOrDefault((MethodInfo m) => !m.IsPublic && m.IsStatic && m.Name.Equals(name2)) ?? throw new MissingMethodException("Expected to find a method named '" + name2 + "' in '" + type.FullName + "'.");
		}

		public static MethodInfo? GetPublicStaticMethod(this Type type, string name, params Type[] parameterTypes)
		{
			string name2 = name;
			Type[] parameterTypes2 = parameterTypes;
			return type.GetRuntimeMethods().FirstOrDefault(delegate(MethodInfo m)
			{
				if (m.IsPublic && m.IsStatic && m.Name.Equals(name2))
				{
					ParameterInfo[] parameters = m.GetParameters();
					if (parameters.Length == parameterTypes2.Length)
					{
						return parameters.Zip(parameterTypes2, (ParameterInfo pi, Type pt) => pi.ParameterType == pt).All((bool r) => r);
					}
					return false;
				}
				return false;
			});
		}

		public static MethodInfo? GetPublicInstanceMethod(this Type type, string name)
		{
			string name2 = name;
			return type.GetRuntimeMethods().FirstOrDefault((MethodInfo m) => m.IsPublic && !m.IsStatic && m.Name.Equals(name2));
		}

		public static MethodInfo? GetGetMethod(this PropertyInfo property, bool nonPublic)
		{
			MethodInfo methodInfo = property.GetMethod;
			if (!nonPublic && !methodInfo.IsPublic)
			{
				methodInfo = null;
			}
			return methodInfo;
		}

		public static MethodInfo? GetSetMethod(this PropertyInfo property)
		{
			return property.SetMethod;
		}

		public static IEnumerable<Type> GetInterfaces(this Type type)
		{
			return type.GetTypeInfo().ImplementedInterfaces;
		}

		public static bool IsInstanceOf(this Type type, object o)
		{
			if (!(o.GetType() == type))
			{
				return o.GetType().GetTypeInfo().IsSubclassOf(type);
			}
			return true;
		}

		public static Attribute[] GetAllCustomAttributes<TAttribute>(this PropertyInfo member)
		{
			List<Attribute> list = new List<Attribute>();
			Type type = member.DeclaringType;
			while (type != null)
			{
				type.GetPublicProperty(member.Name);
				list.AddRange(member.GetCustomAttributes(typeof(TAttribute)));
				type = type.BaseType();
			}
			return list.ToArray();
		}
	}
	internal static class StandardRegexOptions
	{
		public const RegexOptions Compiled = RegexOptions.Compiled;
	}
}
namespace YamlDotNet.Serialization
{
	internal abstract class BuilderSkeleton<TBuilder> where TBuilder : BuilderSkeleton<TBuilder>
	{
		internal INamingConvention namingConvention = NullNamingConvention.Instance;

		internal INamingConvention enumNamingConvention = NullNamingConvention.Instance;

		internal ITypeResolver typeResolver;

		internal readonly YamlAttributeOverrides overrides;

		internal readonly LazyComponentRegistrationList<Nothing, IYamlTypeConverter> typeConverterFactories;

		internal readonly LazyComponentRegistrationList<ITypeInspector, ITypeInspector> typeInspectorFactories;

		internal bool ignoreFields;

		internal bool includeNonPublicProperties;

		internal Settings settings;

		internal YamlFormatter yamlFormatter = YamlFormatter.Default;

		protected abstract TBuilder Self { get; }

		internal BuilderSkeleton(ITypeResolver typeResolver)
		{
			overrides = new YamlAttributeOverrides();
			typeConverterFactories = new LazyComponentRegistrationList<Nothing, IYamlTypeConverter>
			{
				{
					typeof(YamlDotNet.Serialization.Converters.GuidConverter),
					(Nothing _) => new YamlDotNet.Serialization.Converters.GuidConverter(jsonCompatible: false)
				},
				{
					typeof(SystemTypeConverter),
					(Nothing _) => new SystemTypeConverter()
				}
			};
			typeInspectorFactories = new LazyComponentRegistrationList<ITypeInspector, ITypeInspector>();
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			settings = new Settings();
		}

		public TBuilder IgnoreFields()
		{
			ignoreFields = true;
			return Self;
		}

		public TBuilder IncludeNonPublicProperties()
		{
			includeNonPublicProperties = true;
			return Self;
		}

		public TBuilder EnablePrivateConstructors()
		{
			settings.AllowPrivateConstructors = true;
			return Self;
		}

		public TBuilder WithNamingConvention(INamingConvention namingConvention)
		{
			this.namingConvention = namingConvention ?? throw new ArgumentNullException("namingConvention");
			return Self;
		}

		public TBuilder WithEnumNamingConvention(INamingConvention enumNamingConvention)
		{
			this.enumNamingConvention = enumNamingConvention;
			return Self;
		}

		public TBuilder WithTypeResolver(ITypeResolver typeResolver)
		{
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			return Self;
		}

		public abstract TBuilder WithTagMapping(TagName tag, Type type);

		public TBuilder WithAttributeOverride<TClass>(Expression<Func<TClass, object>> propertyAccessor, Attribute attribute)
		{
			overrides.Add(propertyAccessor, attribute);
			return Self;
		}

		public TBuilder WithAttributeOverride(Type type, string member, Attribute attribute)
		{
			overrides.Add(type, member, attribute);
			return Self;
		}

		public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter)
		{
			return WithTypeConverter(typeConverter, delegate(IRegistrationLocationSelectionSyntax<IYamlTypeConverter> w)
			{
				w.OnTop();
			});
		}

		public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter, Action<IRegistrationLocationSelectionSyntax<IYamlTypeConverter>> where)
		{
			IYamlTypeConverter typeConverter2 = typeConverter;
			if (typeConverter2 == null)
			{
				throw new ArgumentNullException("typeConverter");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeConverterFactories.CreateRegistrationLocationSelector(typeConverter2.GetType(), (Nothing _) => typeConverter2));
			return Self;
		}

		public TBuilder WithTypeConverter<TYamlTypeConverter>(WrapperFactory<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IYamlTypeConverter>> where) where TYamlTypeConverter : IYamlTypeConverter
		{
			WrapperFactory<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory2 = typeConverterFactory;
			if (typeConverterFactory2 == null)
			{
				throw new ArgumentNullException("typeConverterFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeConverterFactories.CreateTrackingRegistrationLocationSelector(typeof(TYamlTypeConverter), (IYamlTypeConverter wrapped, Nothing _) => typeConverterFactory2(wrapped)));
			return Self;
		}

		public TBuilder WithoutTypeConverter<TYamlTypeConverter>() where TYamlTypeConverter : IYamlTypeConverter
		{
			return WithoutTypeConverter(typeof(TYamlTypeConverter));
		}

		public TBuilder WithoutTypeConverter(Type converterType)
		{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType");
			}
			typeConverterFactories.Remove(converterType);
			return Self;
		}

		public TBuilder WithTypeInspector<TTypeInspector>(Func<ITypeInspector, TTypeInspector> typeInspectorFactory) where TTypeInspector : ITypeInspector
		{
			return WithTypeInspector(typeInspectorFactory, delegate(IRegistrationLocationSelectionSyntax<ITypeInspector> w)
			{
				w.OnTop();
			});
		}

		public TBuilder WithTypeInspector<TTypeInspector>(Func<ITypeInspector, TTypeInspector> typeInspectorFactory, Action<IRegistrationLocationSelectionSyntax<ITypeInspector>> where) where TTypeInspector : ITypeInspector
		{
			Func<ITypeInspector, TTypeInspector> typeInspectorFactory2 = typeInspectorFactory;
			if (typeInspectorFactory2 == null)
			{
				throw new ArgumentNullException("typeInspectorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeInspectorFactories.CreateRegistrationLocationSelector(typeof(TTypeInspector), (ITypeInspector inner) => typeInspectorFactory2(inner)));
			return Self;
		}

		public TBuilder WithTypeInspector<TTypeInspector>(WrapperFactory<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<ITypeInspector>> where) where TTypeInspector : ITypeInspector
		{
			WrapperFactory<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory2 = typeInspectorFactory;
			if (typeInspectorFactory2 == null)
			{
				throw new ArgumentNullException("typeInspectorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeInspectorFactories.CreateTrackingRegistrationLocationSelector(typeof(TTypeInspector), (ITypeInspector wrapped, ITypeInspector inner) => typeInspectorFactory2(wrapped, inner)));
			return Self;
		}

		public TBuilder WithoutTypeInspector<TTypeInspector>() where TTypeInspector : ITypeInspector
		{
			return WithoutTypeInspector(typeof(TTypeInspector));
		}

		public TBuilder WithoutTypeInspector(Type inspectorType)
		{
			if (inspectorType == null)
			{
				throw new ArgumentNullException("inspectorType");
			}
			typeInspectorFactories.Remove(inspectorType);
			return Self;
		}

		public TBuilder WithYamlFormatter(YamlFormatter formatter)
		{
			yamlFormatter = formatter ?? throw new ArgumentNullException("formatter");
			return Self;
		}

		protected IEnumerable<IYamlTypeConverter> BuildTypeConverters()
		{
			return typeConverterFactories.BuildComponentList();
		}
	}
	internal delegate TComponent WrapperFactory<TComponentBase, TComponent>(TComponentBase wrapped) where TComponent : TComponentBase;
	internal delegate TComponent WrapperFactory<TArgument, TComponentBase, TComponent>(TComponentBase wrapped, TArgument argument) where TComponent : TComponentBase;
	[Flags]
	internal enum DefaultValuesHandling
	{
		Preserve = 0,
		OmitNull = 1,
		OmitDefaults = 2,
		OmitEmptyCollections = 4
	}
	internal sealed class Deserializer : IDeserializer
	{
		private readonly IValueDeserializer valueDeserializer;

		public Deserializer()
			: this(new DeserializerBuilder().BuildValueDeserializer())
		{
		}

		private Deserializer(IValueDeserializer valueDeserializer)
		{
			this.valueDeserializer = valueDeserializer ?? throw new ArgumentNullException("valueDeserializer");
		}

		public static Deserializer FromValueDeserializer(IValueDeserializer valueDeserializer)
		{
			return new Deserializer(valueDeserializer);
		}

		public T Deserialize<T>(string input)
		{
			using StringReader input2 = new StringReader(input);
			return Deserialize<T>(input2);
		}

		public T Deserialize<T>(TextReader input)
		{
			return Deserialize<T>(new Parser(input));
		}

		public T Deserialize<T>(IParser parser)
		{
			return (T)Deserialize(parser, typeof(T));
		}

		public object? Deserialize(string input)
		{
			return Deserialize(input, typeof(object));
		}

		public object? Deserialize(TextReader input)
		{
			return Deserialize(input, typeof(object));
		}

		public object? Deserialize(IParser parser)
		{
			return Deserialize(parser, typeof(object));
		}

		public object? Deserialize(string input, Type type)
		{
			using StringReader input2 = new StringReader(input);
			return Deserialize(input2, type);
		}

		public object? Deserialize(TextReader input, Type type)
		{
			return Deserialize(new Parser(input), type);
		}

		public object? Deserialize(IParser parser, Type type)
		{
			if (parser == null)
			{
				throw new ArgumentNullException("parser");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			YamlDotNet.Core.Events.StreamStart @event;
			bool flag = parser.TryConsume<YamlDotNet.Core.Events.StreamStart>(out @event);
			YamlDotNet.Core.Events.DocumentStart event2;
			bool flag2 = parser.TryConsume<YamlDotNet.Core.Events.DocumentStart>(out event2);
			object result = null;
			if (!parser.Accept<YamlDotNet.Core.Events.DocumentEnd>(out var _) && !parser.Accept<YamlDotNet.Core.Events.StreamEnd>(out var _))
			{
				using SerializerState serializerState = new SerializerState();
				result = valueDeserializer.DeserializeValue(parser, type, serializerState, valueDeserializer);
				serializerState.OnDeserialization();
			}
			if (flag2)
			{
				parser.Consume<YamlDotNet.Core.Events.DocumentEnd>();
			}
			if (flag)
			{
				parser.Consume<YamlDotNet.Core.Events.StreamEnd>();
			}
			return result;
		}
	}
	internal sealed class DeserializerBuilder : BuilderSkeleton<DeserializerBuilder>
	{
		private Lazy<IObjectFactory> objectFactory;

		private readonly LazyComponentRegistrationList<Nothing, INodeDeserializer> nodeDeserializerFactories;

		private readonly LazyComponentRegistrationList<Nothing, INodeTypeResolver> nodeTypeResolverFactories;

		private readonly Dictionary<TagName, Type> tagMappings;

		private readonly Dictionary<Type, Type> typeMappings;

		private readonly ITypeConverter typeConverter;

		private bool ignoreUnmatched;

		private bool duplicateKeyChecking;

		private bool attemptUnknownTypeDeserialization;

		protected override DeserializerBuilder Self => this;

		public DeserializerBuilder()
			: base((ITypeResolver)new StaticTypeResolver())
		{
			typeMappings = new Dictionary<Type, Type>();
			objectFactory = new Lazy<IObjectFactory>(() => new DefaultObjectFactory(typeMappings, settings), isThreadSafe: true);
			tagMappings = new Dictionary<TagName, Type>
			{
				{
					FailsafeSchema.Tags.Map,
					typeof(Dictionary<object, object>)
				},
				{
					FailsafeSchema.Tags.Str,
					typeof(string)
				},
				{
					JsonSchema.Tags.Bool,
					typeof(bool)
				},
				{
					JsonSchema.Tags.Float,
					typeof(double)
				},
				{
					JsonSchema.Tags.Int,
					typeof(int)
				},
				{
					DefaultSchema.Tags.Timestamp,
					typeof(DateTime)
				}
			};
			typeInspectorFactories.Add(typeof(CachedTypeInspector), (ITypeInspector inner) => new CachedTypeInspector(inner));
			typeInspectorFactories.Add(typeof(NamingConventionTypeInspector), (ITypeInspector inner) => (!(namingConvention is NullNamingConvention)) ? new NamingConventionTypeInspector(inner, namingConvention) : inner);
			typeInspectorFactories.Add(typeof(YamlAttributesTypeInspector), (ITypeInspector inner) => new YamlAttributesTypeInspector(inner));
			typeInspectorFactories.Add(typeof(YamlAttributeOverridesInspector), (ITypeInspector inner) => (overrides == null) ? inner : new YamlAttributeOverridesInspector(inner, overrides.Clone()));
			typeInspectorFactories.Add(typeof(ReadableAndWritablePropertiesTypeInspector), (ITypeInspector inner) => new ReadableAndWritablePropertiesTypeInspector(inner));
			nodeDeserializerFactories = new LazyComponentRegistrationList<Nothing, INodeDeserializer>
			{
				{
					typeof(YamlConvertibleNodeDeserializer),
					(Nothing _) => new YamlConvertibleNodeDeserializer(objectFactory.Value)
				},
				{
					typeof(YamlSerializableNodeDeserializer),
					(Nothing _) => new YamlSerializableNodeDeserializer(objectFactory.Value)
				},
				{
					typeof(TypeConverterNodeDeserializer),
					(Nothing _) => new TypeConverterNodeDeserializer(BuildTypeConverters())
				},
				{
					typeof(NullNodeDeserializer),
					(Nothing _) => new NullNodeDeserializer()
				},
				{
					typeof(ScalarNodeDeserializer),
					(Nothing _) => new ScalarNodeDeserializer(attemptUnknownTypeDeserialization, typeConverter, yamlFormatter, enumNamingConvention)
				},
				{
					typeof(ArrayNodeDeserializer),
					(Nothing _) => new ArrayNodeDeserializer(enumNamingConvention)
				},
				{
					typeof(DictionaryNodeDeserializer),
					(Nothing _) => new DictionaryNodeDeserializer(objectFactory.Value, duplicateKeyChecking)
				},
				{
					typeof(CollectionNodeDeserializer),
					(Nothing _) => new CollectionNodeDeserializer(objectFactory.Value, enumNamingConvention)
				},
				{
					typeof(EnumerableNodeDeserializer),
					(Nothing _) => new EnumerableNodeDeserializer()
				},
				{
					typeof(ObjectNodeDeserializer),
					(Nothing _) => new ObjectNodeDeserializer(objectFactory.Value, BuildTypeInspector(), ignoreUnmatched, duplicateKeyChecking, typeConverter, enumNamingConvention)
				}
			};
			nodeTypeResolverFactories = new LazyComponentRegistrationList<Nothing, INodeTypeResolver>
			{
				{
					typeof(MappingNodeTypeResolver),
					(Nothing _) => new MappingNodeTypeResolver(typeMappings)
				},
				{
					typeof(YamlConvertibleTypeResolver),
					(Nothing _) => new YamlConvertibleTypeResolver()
				},
				{
					typeof(YamlSerializableTypeResolver),
					(Nothing _) => new YamlSerializableTypeResolver()
				},
				{
					typeof(TagNodeTypeResolver),
					(Nothing _) => new TagNodeTypeResolver(tagMappings)
				},
				{
					typeof(PreventUnknownTagsNodeTypeResolver),
					(Nothing _) => new PreventUnknownTagsNodeTypeResolver()
				},
				{
					typeof(DefaultContainersNodeTypeResolver),
					(Nothing _) => new DefaultContainersNodeTypeResolver()
				}
			};
			typeConverter = new ReflectionTypeConverter();
		}

		internal ITypeInspector BuildTypeInspector()
		{
			ITypeInspector typeInspector = new WritablePropertiesTypeInspector(typeResolver, includeNonPublicProperties);
			if (!ignoreFields)
			{
				typeInspector = new CompositeTypeInspector(new ReadableFieldsTypeInspector(typeResolver), typeInspector);
			}
			return typeInspectorFactories.BuildComponentChain(typeInspector);
		}

		public DeserializerBuilder WithAttemptingUnquotedStringTypeDeserialization()
		{
			attemptUnknownTypeDeserialization = true;
			return this;
		}

		public DeserializerBuilder WithObjectFactory(IObjectFactory objectFactory)
		{
			IObjectFactory objectFactory2 = objectFactory;
			if (objectFactory2 == null)
			{
				throw new ArgumentNullException("objectFactory");
			}
			this.objectFactory = new Lazy<IObjectFactory>(() => objectFactory2, isThreadSafe: true);
			return this;
		}

		public DeserializerBuilder WithObjectFactory(Func<Type, object> objectFactory)
		{
			if (objectFactory == null)
			{
				throw new ArgumentNullException("objectFactory");
			}
			return WithObjectFactory(new LambdaObjectFactory(objectFactory));
		}

		public DeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer)
		{
			return WithNodeDeserializer(nodeDeserializer, delegate(IRegistrationLocationSelectionSyntax<INodeDeserializer> w)
			{
				w.OnTop();
			});
		}

		public DeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer, Action<IRegistrationLocationSelectionSyntax<INodeDeserializer>> where)
		{
			INodeDeserializer nodeDeserializer2 = nodeDeserializer;
			if (nodeDeserializer2 == null)
			{
				throw new ArgumentNullException("nodeDeserializer");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeDeserializerFactories.CreateRegistrationLocationSelector(nodeDeserializer2.GetType(), (Nothing _) => nodeDeserializer2));
			return this;
		}

		public DeserializerBuilder WithNodeDeserializer<TNodeDeserializer>(WrapperFactory<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory, Action<ITrackingRegistrationLocationSelectionSyntax<INodeDeserializer>> where) where TNodeDeserializer : INodeDeserializer
		{
			WrapperFactory<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory2 = nodeDeserializerFactory;
			if (nodeDeserializerFactory2 == null)
			{
				throw new ArgumentNullException("nodeDeserializerFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeDeserializerFactories.CreateTrackingRegistrationLocationSelector(typeof(TNodeDeserializer), (INodeDeserializer wrapped, Nothing _) => nodeDeserializerFactory2(wrapped)));
			return this;
		}

		public DeserializerBuilder WithoutNodeDeserializer<TNodeDeserializer>() where TNodeDeserializer : INodeDeserializer
		{
			return WithoutNodeDeserializer(typeof(TNodeDeserializer));
		}

		public DeserializerBuilder WithoutNodeDeserializer(Type nodeDeserializerType)
		{
			if (nodeDeserializerType == null)
			{
				throw new ArgumentNullException("nodeDeserializerType");
			}
			nodeDeserializerFactories.Remove(nodeDeserializerType);
			return this;
		}

		public DeserializerBuilder WithTypeDiscriminatingNodeDeserializer(Action<ITypeDiscriminatingNodeDeserializerOptions> configureTypeDiscriminatingNodeDeserializerOptions, int maxDepth = -1, int maxLength = -1)
		{
			TypeDiscriminatingNodeDeserializerOptions typeDiscriminatingNodeDeserializerOptions = new TypeDiscriminatingNodeDeserializerOptions();
			configureTypeDiscriminatingNodeDeserializerOptions(typeDiscriminatingNodeDeserializerOptions);
			TypeDiscriminatingNodeDeserializer nodeDeserializer = new TypeDiscriminatingNodeDeserializer(nodeDeserializerFactories.BuildComponentList(), typeDiscriminatingNodeDeserializerOptions.discriminators, maxDepth, maxLength);
			return WithNodeDeserializer(nodeDeserializer, delegate(IRegistrationLocationSelectionSyntax<INodeDeserializer> s)
			{
				s.Before<DictionaryNodeDeserializer>();
			});
		}

		public DeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver)
		{
			return WithNodeTypeResolver(nodeTypeResolver, delegate(IRegistrationLocationSelectionSyntax<INodeTypeResolver> w)
			{
				w.OnTop();
			});
		}

		public DeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver, Action<IRegistrationLocationSelectionSyntax<INodeTypeResolver>> where)
		{
			INodeTypeResolver nodeTypeResolver2 = nodeTypeResolver;
			if (nodeTypeResolver2 == null)
			{
				throw new ArgumentNullException("nodeTypeResolver");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeTypeResolverFactories.CreateRegistrationLocationSelector(nodeTypeResolver2.GetType(), (Nothing _) => nodeTypeResolver2));
			return this;
		}

		public DeserializerBuilder WithNodeTypeResolver<TNodeTypeResolver>(WrapperFactory<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory, Action<ITrackingRegistrationLocationSelectionSyntax<INodeTypeResolver>> where) where TNodeTypeResolver : INodeTypeResolver
		{
			WrapperFactory<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory2 = nodeTypeResolverFactory;
			if (nodeTypeResolverFactory2 == null)
			{
				throw new ArgumentNullException("nodeTypeResolverFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeTypeResolverFactories.CreateTrackingRegistrationLocationSelector(typeof(TNodeTypeResolver), (INodeTypeResolver wrapped, Nothing _) => nodeTypeResolverFactory2(wrapped)));
			return this;
		}

		public DeserializerBuilder WithoutNodeTypeResolver<TNodeTypeResolver>() where TNodeTypeResolver : INodeTypeResolver
		{
			return WithoutNodeTypeResolver(typeof(TNodeTypeResolver));
		}

		public DeserializerBuilder WithoutNodeTypeResolver(Type nodeTypeResolverType)
		{
			if (nodeTypeResolverType == null)
			{
				throw new ArgumentNullException("nodeTypeResolverType");
			}
			nodeTypeResolverFactories.Remove(nodeTypeResolverType);
			return this;
		}

		public override DeserializerBuilder WithTagMapping(TagName tag, Type type)
		{
			if (tag.IsEmpty)
			{
				throw new ArgumentException("Non-specific tags cannot be maped");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (tagMappings.TryGetValue(tag, out Type value))
			{
				throw new ArgumentException($"Type already has a registered type '{value.FullName}' for tag '{tag}'", "tag");
			}
			tagMappings.Add(tag, type);
			return this;
		}

		public DeserializerBuilder WithTypeMapping<TInterface, TConcrete>() where TConcrete : TInterface
		{
			Type typeFromHandle = typeof(TInterface);
			Type typeFromHandle2 = typeof(TConcrete);
			if (!typeFromHandle.IsAssignableFrom(typeFromHandle2))
			{
				throw new InvalidOperationException("The type '" + typeFromHandle2.Name + "' does not implement interface '" + typeFromHandle.Name + "'.");
			}
			if (typeMappings.ContainsKey(typeFromHandle))
			{
				typeMappings[typeFromHandle] = typeFromHandle2;
			}
			else
			{
				typeMappings.Add(typeFromHandle, typeFromHandle2);
			}
			return this;
		}

		public DeserializerBuilder WithoutTagMapping(TagName tag)
		{
			if (tag.IsEmpty)
			{
				throw new ArgumentException("Non-specific tags cannot be maped");
			}
			if (!tagMappings.Remove(tag))
			{
				throw new KeyNotFoundException($"Tag '{tag}' is not registered");
			}
			return this;
		}

		public DeserializerBuilder IgnoreUnmatchedProperties()
		{
			ignoreUnmatched = true;
			return this;
		}

		public DeserializerBuilder WithDuplicateKeyChecking()
		{
			duplicateKeyChecking = true;
			return this;
		}

		public IDeserializer Build()
		{
			return Deserializer.FromValueDeserializer(BuildValueDeserializer());
		}

		public IValueDeserializer BuildValueDeserializer()
		{
			return new AliasValueDeserializer(new NodeValueDeserializer(nodeDeserializerFactories.BuildComponentList(), nodeTypeResolverFactories.BuildComponentList(), typeConverter, enumNamingConvention));
		}
	}
	internal sealed class EmissionPhaseObjectGraphVisitorArgs
	{
		private readonly IEnumerable<IObjectGraphVisitor<Nothing>> preProcessingPhaseVisitors;

		public IObjectGraphVisitor<IEmitter> InnerVisitor { get; private set; }

		public IEventEmitter EventEmitter { get; private set; }

		public ObjectSerializer NestedObjectSerializer { get; private set; }

		public IEnumerable<IYamlTypeConverter> TypeConverters { get; private set; }

		public EmissionPhaseObjectGraphVisitorArgs(IObjectGraphVisitor<IEmitter> innerVisitor, IEventEmitter eventEmitter, IEnumerable<IObjectGraphVisitor<Nothing>> preProcessingPhaseVisitors, IEnumerable<IYamlTypeConverter> typeConverters, ObjectSerializer nestedObjectSerializer)
		{
			InnerVisitor = innerVisitor ?? throw new ArgumentNullException("innerVisitor");
			EventEmitter = eventEmitter ?? throw new ArgumentNullException("eventEmitter");
			this.preProcessingPhaseVisitors = preProcessingPhaseVisitors ?? throw new ArgumentNullException("preProcessingPhaseVisitors");
			TypeConverters = typeConverters ?? throw new ArgumentNullException("typeConverters");
			NestedObjectSerializer = nestedObjectSerializer ?? throw new ArgumentNullException("nestedObjectSerializer");
		}

		public T GetPreProcessingPhaseObjectGraphVisitor<T>() where T : IObjectGraphVisitor<Nothing>
		{
			return preProcessingPhaseVisitors.OfType<T>().Single();
		}
	}
	internal abstract class EventInfo
	{
		public IObjectDescriptor Source { get; }

		protected EventInfo(IObjectDescriptor source)
		{
			Source = source ?? throw new ArgumentNullException("source");
		}
	}
	internal class AliasEventInfo : EventInfo
	{
		public AnchorName Alias { get; }

		public bool NeedsExpansion { get; set; }

		public AliasEventInfo(IObjectDescriptor source, AnchorName alias)
			: base(source)
		{
			if (alias.IsEmpty)
			{
				throw new ArgumentNullException("alias");
			}
			Alias = alias;
		}
	}
	internal class ObjectEventInfo : EventInfo
	{
		public AnchorName Anchor { get; set; }

		public TagName Tag { get; set; }

		protected ObjectEventInfo(IObjectDescriptor source)
			: base(source)
		{
		}
	}
	internal sealed class ScalarEventInfo : ObjectEventInfo
	{
		public string RenderedValue { get; set; }

		public ScalarStyle Style { get; set; }

		public bool IsPlainImplicit { get; set; }

		public bool IsQuotedImplicit { get; set; }

		public ScalarEventInfo(IObjectDescriptor source)
			: base(source)
		{
			Style = source.ScalarStyle;
			RenderedValue = string.Empty;
		}
	}
	internal sealed class MappingStartEventInfo : ObjectEventInfo
	{
		public bool IsImplicit { get; set; }

		public MappingStyle Style { get; set; }

		public MappingStartEventInfo(IObjectDescriptor source)
			: base(source)
		{
		}
	}
	internal sealed class MappingEndEventInfo : EventInfo
	{
		public MappingEndEventInfo(IObjectDescriptor source)
			: base(source)
		{
		}
	}
	internal sealed class SequenceStartEventInfo : ObjectEventInfo
	{
		public bool IsImplicit { get; set; }

		public SequenceStyle Style { get; set; }

		public SequenceStartEventInfo(IObjectDescriptor source)
			: base(source)
		{
		}
	}
	internal sealed class SequenceEndEventInfo : EventInfo
	{
		public SequenceEndEventInfo(IObjectDescriptor source)
			: base(source)
		{
		}
	}
	internal interface IAliasProvider
	{
		AnchorName GetAlias(object target);
	}
	internal interface IDeserializer
	{
		T Deserialize<T>(string input);

		T Deserialize<T>(TextReader input);

		T Deserialize<T>(IParser parser);

		object? Deserialize(string input);

		object? Deserialize(TextReader input);

		object? Deserialize(IParser parser);

		object? Deserialize(string input, Type type);

		object? Deserialize(TextReader input, Type type);

		object? Deserialize(IParser parser, Type type);
	}
	internal interface IEventEmitter
	{
		void Emit(AliasEventInfo eventInfo, IEmitter emitter);

		void Emit(ScalarEventInfo eventInfo, IEmitter emitter);

		void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);

		void Emit(MappingEndEventInfo eventInfo, IEmitter emitter);

		void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);

		void Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
	}
	internal interface INamingConvention
	{
		string Apply(string value);

		string Reverse(string value);
	}
	internal interface INodeDeserializer
	{
		bool Deserialize(IParser reader, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value);
	}
	internal interface INodeTypeResolver
	{
		bool Resolve(NodeEvent? nodeEvent, ref Type currentType);
	}
	internal interface IObjectAccessor
	{
		void Set(string name, object target, object value);

		object? Read(string name, object target);
	}
	internal interface IObjectDescriptor
	{
		object? Value { get; }

		Type Type { get; }

		Type StaticType { get; }

		ScalarStyle ScalarStyle { get; }
	}
	internal static class ObjectDescriptorExtensions
	{
		public static object NonNullValue(this IObjectDescriptor objectDescriptor)
		{
			return objectDescriptor.Value ?? throw new InvalidOperationException("Attempted to use a IObjectDescriptor of type '" + objectDescriptor.Type.FullName + "' whose Value is null at a point whete it is invalid to do so. This may indicate a bug in YamlDotNet.");
		}
	}
	internal interface IObjectFactory
	{
		object Create(Type type);

		object? CreatePrimitive(Type type);

		bool GetDictionary(IObjectDescriptor descriptor, out IDictionary? dictionary, out Type[]? genericArguments);

		Type GetValueType(Type type);

		void ExecuteOnDeserializing(object value);

		void ExecuteOnDeserialized(object value);

		void ExecuteOnSerializing(object value);

		void ExecuteOnSerialized(object value);
	}
	internal interface IObjectGraphTraversalStrategy
	{
		void Traverse<TContext>(IObjectDescriptor graph, IObjectGraphVisitor<TContext> visitor, TContext context);
	}
	internal interface IObjectGraphVisitor<TContext>
	{
		bool Enter(IObjectDescriptor value, TContext context);

		bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, TContext context);

		bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, TContext context);

		void VisitScalar(IObjectDescriptor scalar, TContext context);

		void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, TContext context);

		void VisitMappingEnd(IObjectDescriptor mapping, TContext context);

		void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, TContext context);

		void VisitSequenceEnd(IObjectDescriptor sequence, TContext context);
	}
	internal interface IPropertyDescriptor
	{
		string Name { get; }

		bool CanWrite { get; }

		Type Type { get; }

		Type? TypeOverride { get; set; }

		int Order { get; set; }

		ScalarStyle ScalarStyle { get; set; }

		T? GetCustomAttribute<T>() where T : Attribute;

		IObjectDescriptor Read(object target);

		void Write(object target, object? value);
	}
	internal interface IRegistrationLocationSelectionSyntax<TBaseRegistrationType>
	{
		void InsteadOf<TRegistrationType>() where TRegistrationType : TBaseRegistrationType;

		void Before<TRegistrationType>() where TRegistrationType : TBaseRegistrationType;

		void After<TRegistrationType>() where TRegistrationType : TBaseRegistrationType;

		void OnTop();

		void OnBottom();
	}
	internal interface ITrackingRegistrationLocationSelectionSyntax<TBaseRegistrationType>
	{
		void InsteadOf<TRegistrationType>() where TRegistrationType : TBaseRegistrationType;
	}
	internal interface ISerializer
	{
		string Serialize(object? graph);

		string Serialize(object? graph, Type type);

		void Serialize(TextWriter writer, object? graph);

		void Serialize(TextWriter writer, object? graph, Type type);

		void Serialize(IEmitter emitter, object? graph);

		void Serialize(IEmitter emitter, object? graph, Type type);
	}
	internal interface ITypeInspector
	{
		IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container);

		IPropertyDescriptor GetProperty(Type type, object? container, string name, [MaybeNullWhen(true)] bool ignoreUnmatched);
	}
	internal interface ITypeResolver
	{
		Type Resolve(Type staticType, object? actualValue);
	}
	internal interface IValueDeserializer
	{
		object? DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
	}
	internal interface IValuePromise
	{
		event Action<object?> ValueAvailable;
	}
	internal interface IValueSerializer
	{
		void SerializeValue(IEmitter emitter, object? value, Type? type);
	}
	internal interface IYamlConvertible
	{
		void Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);

		void Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
	}
	internal delegate object? ObjectDeserializer(Type type);
	internal delegate void ObjectSerializer(object? value, Type? type = null);
	[Obsolete("Please use IYamlConvertible instead")]
	internal interface IYamlSerializable
	{
		void ReadYaml(IParser parser);

		void WriteYaml(IEmitter emitter);
	}
	internal interface IYamlTypeConverter
	{
		bool Accepts(Type type);

		object? ReadYaml(IParser parser, Type type);

		void WriteYaml(IEmitter emitter, object? value, Type type);
	}
	internal sealed class LazyComponentRegistrationList<TArgument, TComponent> : IEnumerable<Func<TArgument, TComponent>>, IEnumerable
	{
		public sealed class LazyComponentRegistration
		{
			public readonly Type ComponentType;

			public readonly Func<TArgument, TComponent> Factory;

			public LazyComponentRegistration(Type componentType, Func<TArgument, TComponent> factory)
			{
				ComponentType = componentType;
				Factory = factory;
			}
		}

		public sealed class TrackingLazyComponentRegistration
		{
			public readonly Type ComponentType;

			public readonly Func<TComponent, TArgument, TComponent> Factory;

			public TrackingLazyComponentRegistration(Type componentType, Func<TComponent, TArgument, TComponent> factory)
			{
				ComponentType = componentType;
				Factory = factory;
			}
		}

		private class RegistrationLocationSelector : IRegistrationLocationSelectionSyntax<TComponent>
		{
			private readonly LazyComponentRegistrationList<TArgument, TComponent> registrations;

			private readonly LazyComponentRegistration newRegistration;

			public RegistrationLocationSelector(LazyComponentRegistrationList<TArgument, TComponent> registrations, LazyComponentRegistration newRegistration)
			{
				this.registrations = registrations;
				this.newRegistration = newRegistration;
			}

			void IRegistrationLocationSelectionSyntax<TComponent>.InsteadOf<TRegistrationType>()
			{
				if (newRegistration.ComponentType != typeof(TRegistrationType))
				{
					registrations.EnsureNoDuplicateRegistrationType(newRegistration.ComponentType);
				}
				int index = registrations.EnsureRegistrationExists<TRegistrationType>();
				registrations.entries[index] = newRegistration;
			}

			void IRegistrationLocationSelectionSyntax<TComponent>.After<TRegistrationType>()
			{
				registrations.EnsureNoDuplicateRegistrationType(newRegistration.ComponentType);
				int num = registrations.EnsureRegistrationExists<TRegistrationType>();
				registrations.entries.Insert(num + 1, newRegistration);
			}

			void IRegistrationLocationSelectionSyntax<TComponent>.Before<TRegistrationType>()
			{
				registrations.EnsureNoDuplicateRegistrationType(newRegistration.ComponentType);
				int index = registrations.EnsureRegistrationExists<TRegistrationType>();
				registrations.entries.Insert(index, newRegistration);
			}

			void IRegistrationLocationSelectionSyntax<TComponent>.OnBottom()
			{
				registrations.EnsureNoDuplicateRegistrationType(newRegistration.ComponentType);
				registrations.entries.Add(newRegistration);
			}

			void IRegistrationLocationSelectionSyntax<TComponent>.OnTop()
			{
				registrations.EnsureNoDuplicateRegistrationType(newRegistration.ComponentType);
				registrations.entries.Insert(0, newRegistration);
			}
		}

		private class TrackingRegistrationLocationSelector : ITrackingRegistrationLocationSelectionSyntax<TComponent>
		{
			private readonly LazyComponentRegistrationList<TArgument, TComponent> registrations;

			private readonly TrackingLazyComponentRegistration newRegistration;

			public TrackingRegistrationLocationSelector(LazyComponentRegistrationList<TArgument, TComponent> registrations, TrackingLazyComponentRegistration newRegistration)
			{
				this.registrations = registrations;
				this.newRegistration = newRegistration;
			}

			void ITrackingRegistrationLocationSelectionSyntax<TComponent>.InsteadOf<TRegistrationType>()
			{
				if (newRegistration.ComponentType != typeof(TRegistrationType))
				{
					registrations.EnsureNoDuplicateRegistrationType(newRegistration.ComponentType);
				}
				int index = registrations.EnsureRegistrationExists<TRegistrationType>();
				Func<TArgument, TComponent> innerComponentFactory = registrations.entries[index].Factory;
				registrations.entries[index] = new LazyComponentRegistration(newRegistration.ComponentType, (TArgument arg) => newRegistration.Factory(innerComponentFactory(arg), arg));
			}
		}

		private readonly List<LazyComponentRegistration> entries = new List<LazyComponentRegistration>();

		public int Count => entries.Count;

		public IEnumerable<Func<TArgument, TComponent>> InReverseOrder
		{
			get
			{
				int i = entries.Count - 1;
				while (i >= 0)
				{
					yield return entries[i].Factory;
					int num = i - 1;
					i = num;
				}
			}
		}

		public LazyComponentRegistrationList<TArgument, TComponent> Clone()
		{
			LazyComponentRegistrationList<TArgument, TComponent> lazyComponentRegistrationList = new LazyComponentRegistrationList<TArgument, TComponent>();
			foreach (LazyComponentRegistration entry in entries)
			{
				lazyComponentRegistrationList.entries.Add(entry);
			}
			return lazyComponentRegistrationList;
		}

		public void Clear()
		{
			entries.Clear();
		}

		public void Add(Type componentType, Func<TArgument, TComponent> factory)
		{
			entries.Add(new LazyComponentRegistration(componentType, factory));
		}

		public void Remove(Type componentType)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				if (entries[i].ComponentType == componentType)
				{
					entries.RemoveAt(i);
					return;
				}
			}
			throw new KeyNotFoundException("A component registration of type '" + componentType.FullName + "' was not found.");
		}

		public IRegistrationLocationSelectionSyntax<TComponent> CreateRegistrationLocationSelector(Type componentType, Func<TArgument, TComponent> factory)
		{
			return new RegistrationLocationSelector(this, new LazyComponentRegistration(componentType, factory));
		}

		public ITrackingRegistrationLocationSelectionSyntax<TComponent> CreateTrackingRegistrationLocationSelector(Type componentType, Func<TComponent, TArgument, TComponent> factory)
		{
			return new TrackingRegistrationLocationSelector(this, new TrackingLazyComponentRegistration(componentType, factory));
		}

		public IEnumerator<Func<TArgument, TComponent>> GetEnumerator()
		{
			return entries.Select((LazyComponentRegistration e) => e.Factory).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		private int IndexOfRegistration(Type registrationType)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				if (registrationType == entries[i].ComponentType)
				{
					return i;
				}
			}
			return -1;
		}

		private void EnsureNoDuplicateRegistrationType(Type componentType)
		{
			if (IndexOfRegistration(componentType) != -1)
			{
				throw new InvalidOperationException("A component of type '" + componentType.FullName + "' has already been registered.");
			}
		}

		private int EnsureRegistrationExists<TRegistrationType>()
		{
			int num = IndexOfRegistration(typeof(TRegistrationType));
			if (num == -1)
			{
				throw new InvalidOperationException("A component of type '" + typeof(TRegistrationType).FullName + "' has not been registered.");
			}
			return num;
		}
	}
	internal static class LazyComponentRegistrationListExtensions
	{
		public static TComponent BuildComponentChain<TComponent>(this LazyComponentRegistrationList<TComponent, TComponent> registrations, TComponent innerComponent)
		{
			return registrations.InReverseOrder.Aggregate(innerComponent, (TComponent inner, Func<TComponent, TComponent> factory) => factory(inner));
		}

		public static TComponent BuildComponentChain<TArgument, TComponent>(this LazyComponentRegistrationList<TArgument, TComponent> registrations, TComponent innerComponent, Func<TComponent, TArgument> argumentBuilder)
		{
			Func<TComponent, TArgument> argumentBuilder2 = argumentBuilder;
			return registrations.InReverseOrder.Aggregate(innerComponent, (TComponent inner, Func<TArgument, TComponent> factory) => factory(argumentBuilder2(inner)));
		}

		public static List<TComponent> BuildComponentList<TComponent>(this LazyComponentRegistrationList<Nothing, TComponent> registrations)
		{
			return registrations.Select((Func<Nothing, TComponent> factory) => factory(default(Nothing))).ToList();
		}

		public static List<TComponent> BuildComponentList<TArgument, TComponent>(this LazyComponentRegistrationList<TArgument, TComponent> registrations, TArgument argument)
		{
			TArgument argument2 = argument;
			return registrations.Select((Func<TArgument, TComponent> factory) => factory(argument2)).ToList();
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct Nothing
	{
	}
	internal sealed class ObjectDescriptor : IObjectDescriptor
	{
		public object? Value { get; private set; }

		public Type Type { get; private set; }

		public Type StaticType { get; private set; }

		public ScalarStyle ScalarStyle { get; private set; }

		public ObjectDescriptor(object? value, Type type, Type staticType)
			: this(value, type, staticType, ScalarStyle.Any)
		{
		}

		public ObjectDescriptor(object? value, Type type, Type staticType, ScalarStyle scalarStyle)
		{
			Value = value;
			Type = type ?? throw new ArgumentNullException("type");
			StaticType = staticType ?? throw new ArgumentNullException("staticType");
			ScalarStyle = scalarStyle;
		}
	}
	internal delegate IObjectGraphTraversalStrategy ObjectGraphTraversalStrategyFactory(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable<IYamlTypeConverter> typeConverters, int maximumRecursion);
	internal sealed class PropertyDescriptor : IPropertyDescriptor
	{
		private readonly IPropertyDescriptor baseDescriptor;

		public string Name { get; set; }

		public Type Type => baseDescriptor.Type;

		public Type? TypeOverride
		{
			get
			{
				return baseDescriptor.TypeOverride;
			}
			set
			{
				baseDescriptor.TypeOverride = value;
			}
		}

		public int Order { get; set; }

		public ScalarStyle ScalarStyle
		{
			get
			{
				return baseDescriptor.ScalarStyle;
			}
			set
			{
				baseDescriptor.ScalarStyle = value;
			}
		}

		public bool CanWrite => baseDescriptor.CanWrite;

		public PropertyDescriptor(IPropertyDescriptor baseDescriptor)
		{
			this.baseDescriptor = baseDescriptor;
			Name = baseDescriptor.Name;
		}

		public void Write(object target, object? value)
		{
			baseDescriptor.Write(target, value);
		}

		public T? GetCustomAttribute<T>() where T : Attribute
		{
			return baseDescriptor.GetCustomAttribute<T>();
		}

		public IObjectDescriptor Read(object target)
		{
			return baseDescriptor.Read(target);
		}
	}
	internal sealed class Serializer : ISerializer
	{
		private readonly IValueSerializer valueSerializer;

		private readonly EmitterSettings emitterSettings;

		public Serializer()
			: this(new SerializerBuilder().BuildValueSerializer(), EmitterSettings.Default)
		{
		}

		private Serializer(IValueSerializer valueSerializer, EmitterSettings emitterSettings)
		{
			this.valueSerializer = valueSerializer ?? throw new ArgumentNullException("valueSerializer");
			this.emitterSettings = emitterSettings ?? throw new ArgumentNullException("emitterSettings");
		}

		public static Serializer FromValueSerializer(IValueSerializer valueSerializer, EmitterSettings emitterSettings)
		{
			return new Serializer(valueSerializer, emitterSettings);
		}

		public string Serialize(object? graph)
		{
			using StringWriter stringWriter = new StringWriter();
			Serialize(stringWriter, graph);
			return stringWriter.ToString();
		}

		public string Serialize(object? graph, Type type)
		{
			using StringWriter stringWriter = new StringWriter();
			Serialize(stringWriter, graph, type);
			return stringWriter.ToString();
		}

		public void Serialize(TextWriter writer, object? graph)
		{
			Serialize(new Emitter(writer, emitterSettings), graph);
		}

		public void Serialize(TextWriter writer, object? graph, Type type)
		{
			Serialize(new Emitter(writer, emitterSettings), graph, type);
		}

		public void Serialize(IEmitter emitter, object? graph)
		{
			if (emitter == null)
			{
				throw new ArgumentNullException("emitter");
			}
			EmitDocument(emitter, graph, null);
		}

		public void Serialize(IEmitter emitter, object? graph, Type type)
		{
			if (emitter == null)
			{
				throw new ArgumentNullException("emitter");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			EmitDocument(emitter, graph, type);
		}

		private void EmitDocument(IEmitter emitter, object? graph, Type? type)
		{
			emitter.Emit(new YamlDotNet.Core.Events.StreamStart());
			emitter.Emit(new YamlDotNet.Core.Events.DocumentStart());
			valueSerializer.SerializeValue(emitter, graph, type);
			emitter.Emit(new YamlDotNet.Core.Events.DocumentEnd(isImplicit: true));
			emitter.Emit(new YamlDotNet.Core.Events.StreamEnd());
		}
	}
	internal sealed class SerializerBuilder : BuilderSkeleton<SerializerBuilder>
	{
		private class ValueSerializer : IValueSerializer
		{
			private readonly IObjectGraphTraversalStrategy traversalStrategy;

			private readonly IEventEmitter eventEmitter;

			private readonly IEnumerable<IYamlTypeConverter> typeConverters;

			private readonly LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;

			private readonly LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>> emissionPhaseObjectGraphVisitorFactories;

			public ValueSerializer(IObjectGraphTraversalStrategy traversalStrategy, IEventEmitter eventEmitter, IEnumerable<IYamlTypeConverter> typeConverters, LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitorFactories, LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>> emissionPhaseObjectGraphVisitorFactories)
			{
				this.traversalStrategy = traversalStrategy;
				this.eventEmitter = eventEmitter;
				this.typeConverters = typeConverters;
				this.preProcessingPhaseObjectGraphVisitorFactories = preProcessingPhaseObjectGraphVisitorFactories;
				this.emissionPhaseObjectGraphVisitorFactories = emissionPhaseObjectGraphVisitorFactories;
			}

			public void SerializeValue(IEmitter emitter, object? value, Type? type)
			{
				IEmitter emitter2 = emitter;
				Type type2 = type ?? ((value != null) ? value.GetType() : typeof(object));
				Type staticType = type ?? typeof(object);
				ObjectDescriptor graph = new ObjectDescriptor(value, type2, staticType);
				List<IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitors = preProcessingPhaseObjectGraphVisitorFactories.BuildComponentList(typeConverters);
				foreach (IObjectGraphVisitor<Nothing> item in preProcessingPhaseObjectGraphVisitors)
				{
					traversalStrategy.Traverse(graph, item, default(Nothing));
				}
				IObjectGraphVisitor<IEmitter> visitor = emissionPhaseObjectGraphVisitorFactories.BuildComponentChain<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>>(new EmittingObjectGraphVisitor(eventEmitter), (IObjectGraphVisitor<IEmitter> inner) => new EmissionPhaseObjectGraphVisitorArgs(inner, eventEmitter, preProcessingPhaseObjectGraphVisitors, typeConverters, NestedObjectSerializer));
				traversalStrategy.Traverse(graph, visitor, emitter2);
				void NestedObjectSerializer(object? v, Type? t)
				{
					SerializeValue(emitter2, v, t);
				}
			}
		}

		private ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory;

		private readonly LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;

		private readonly LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>> emissionPhaseObjectGraphVisitorFactories;

		private readonly LazyComponentRegistrationList<IEventEmitter, IEventEmitter> eventEmitterFactories;

		private readonly IDictionary<Type, TagName> tagMappings = new Dictionary<Type, TagName>();

		private readonly IObjectFactory objectFactory;

		private int maximumRecursion = 50;

		private EmitterSettings emitterSettings = EmitterSettings.Default;

		private DefaultValuesHandling defaultValuesHandlingConfiguration;

		private ScalarStyle defaultScalarStyle;

		private bool quoteNecessaryStrings;

		private bool quoteYaml1_1Strings;

		protected override SerializerBuilder Self => this;

		public SerializerBuilder()
			: base((ITypeResolver)new DynamicTypeResolver())
		{
			typeInspectorFactories.Add(typeof(CachedTypeInspector), (ITypeInspector inner) => new CachedTypeInspector(inner));
			typeInspectorFactories.Add(typeof(NamingConventionTypeInspector), (ITypeInspector inner) => (!(namingConvention is NullNamingConvention)) ? new NamingConventionTypeInspector(inner, namingConvention) : inner);
			typeInspectorFactories.Add(typeof(YamlAttributesTypeInspector), (ITypeInspector inner) => new YamlAttributesTypeInspector(inner));
			typeInspectorFactories.Add(typeof(YamlAttributeOverridesInspector), (ITypeInspector inner) => (overrides == null) ? inner : new YamlAttributeOverridesInspector(inner, overrides.Clone()));
			preProcessingPhaseObjectGraphVisitorFactories = new LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> { 
			{
				typeof(AnchorAssigner),
				(IEnumerable<IYamlTypeConverter> typeConverters) => new AnchorAssigner(typeConverters)
			} };
			emissionPhaseObjectGraphVisitorFactories = new LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>>
			{
				{
					typeof(CustomSerializationObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new CustomSerializationObjectGraphVisitor(args.InnerVisitor, args.TypeConverters, args.NestedObjectSerializer)
				},
				{
					typeof(AnchorAssigningObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new AnchorAssigningObjectGraphVisitor(args.InnerVisitor, args.EventEmitter, args.GetPreProcessingPhaseObjectGraphVisitor<AnchorAssigner>())
				},
				{
					typeof(DefaultValuesObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new DefaultValuesObjectGraphVisitor(defaultValuesHandlingConfiguration, args.InnerVisitor, new DefaultObjectFactory())
				},
				{
					typeof(CommentsObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new CommentsObjectGraphVisitor(args.InnerVisitor)
				}
			};
			eventEmitterFactories = new LazyComponentRegistrationList<IEventEmitter, IEventEmitter> { 
			{
				typeof(TypeAssigningEventEmitter),
				(IEventEmitter inner) => new TypeAssigningEventEmitter(inner, requireTagWhenStaticAndActualTypesAreDifferent: false, tagMappings, quoteNecessaryStrings, quoteYaml1_1Strings, defaultScalarStyle, yamlFormatter, enumNamingConvention)
			} };
			objectFactory = new DefaultObjectFactory();
			objectGraphTraversalStrategyFactory = (ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable<IYamlTypeConverter> typeConverters, int maximumRecursion) => new FullObjectGraphTraversalStrategy(typeInspector, typeResolver, maximumRecursion, namingConvention, objectFactory);
		}

		public SerializerBuilder WithQuotingNecessaryStrings(bool quoteYaml1_1Strings = false)
		{
			quoteNecessaryStrings = true;
			this.quoteYaml1_1Strings = quoteYaml1_1Strings;
			return this;
		}

		public SerializerBuilder WithDefaultScalarStyle(ScalarStyle style)
		{
			defaultScalarStyle = style;
			return this;
		}

		public SerializerBuilder WithMaximumRecursion(int maximumRecursion)
		{
			if (maximumRecursion <= 0)
			{
				throw new ArgumentOutOfRangeException("maximumRecursion", $"The maximum recursion specified ({maximumRecursion}) is invalid. It should be a positive integer.");
			}
			this.maximumRecursion = maximumRecursion;
			return this;
		}

		public SerializerBuilder WithEventEmitter<TEventEmitter>(Func<IEventEmitter, TEventEmitter> eventEmitterFactory) where TEventEmitter : IEventEmitter
		{
			return WithEventEmitter(eventEmitterFactory, delegate(IRegistrationLocationSelectionSyntax<IEventEmitter> w)
			{
				w.OnTop();
			});
		}

		public SerializerBuilder WithEventEmitter<TEventEmitter>(Func<IEventEmitter, TEventEmitter> eventEmitterFactory, Action<IRegistrationLocationSelectionSyntax<IEventEmitter>> where) where TEventEmitter : IEventEmitter
		{
			Func<IEventEmitter, TEventEmitter> eventEmitterFactory2 = eventEmitterFactory;
			if (eventEmitterFactory2 == null)
			{
				throw new ArgumentNullException("eventEmitterFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(eventEmitterFactories.CreateRegistrationLocationSelector(typeof(TEventEmitter), (IEventEmitter inner) => eventEmitterFactory2(inner)));
			return Self;
		}

		public SerializerBuilder WithEventEmitter<TEventEmitter>(WrapperFactory<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IEventEmitter>> where) where TEventEmitter : IEventEmitter
		{
			WrapperFactory<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory2 = eventEmitterFactory;
			if (eventEmitterFactory2 == null)
			{
				throw new ArgumentNullException("eventEmitterFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(eventEmitterFactories.CreateTrackingRegistrationLocationSelector(typeof(TEventEmitter), (IEventEmitter wrapped, IEventEmitter inner) => eventEmitterFactory2(wrapped, inner)));
			return Self;
		}

		public SerializerBuilder WithoutEventEmitter<TEventEmitter>() where TEventEmitter : IEventEmitter
		{
			return WithoutEventEmitter(typeof(TEventEmitter));
		}

		public SerializerBuilder WithoutEventEmitter(Type eventEmitterType)
		{
			if (eventEmitterType == null)
			{
				throw new ArgumentNullException("eventEmitterType");
			}
			eventEmitterFactories.Remove(eventEmitterType);
			return this;
		}

		public override SerializerBuilder WithTagMapping(TagName tag, Type type)
		{
			if (tag.IsEmpty)
			{
				throw new ArgumentException("Non-specific tags cannot be maped");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (tagMappings.TryGetValue(type, out var value))
			{
				throw new ArgumentException($"Type already has a registered tag '{value}' for type '{type.FullName}'", "type");
			}
			tagMappings.Add(type, tag);
			return this;
		}

		public SerializerBuilder WithoutTagMapping(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (!tagMappings.Remove(type))
			{
				throw new KeyNotFoundException("Tag for type '" + type.FullName + "' is not registered");
			}
			return this;
		}

		public SerializerBuilder EnsureRoundtrip()
		{
			objectGraphTraversalStrategyFactory = (ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable<IYamlTypeConverter> typeConverters, int maximumRecursion) => new RoundtripObjectGraphTraversalStrategy(typeConverters, typeInspector, typeResolver, maximumRecursion, namingConvention, settings, objectFactory);
			WithEventEmitter((IEventEmitter inner) => new TypeAssigningEventEmitter(inner, requireTagWhenStaticAndActualTypesAreDifferent: true, tagMappings, quoteNecessaryStrings, quoteYaml1_1Strings, defaultScalarStyle, yamlFormatter, enumNamingConvention), delegate(IRegistrationLocationSelectionSyntax<IEventEmitter> loc)
			{
				loc.InsteadOf<TypeAssigningEventEmitter>();
			});
			return WithTypeInspector((ITypeInspector inner) => new ReadableAndWritablePropertiesTypeInspector(inner), delegate(IRegistrationLocationSelectionSyntax<ITypeInspector> loc)
			{
				loc.OnBottom();
			});
		}

		public SerializerBuilder DisableAliases()
		{
			preProcessingPhaseObjectGraphVisitorFactories.Remove(typeof(AnchorAssigner));
			emissionPhaseObjectGraphVisitorFactories.Remove(typeof(AnchorAssigningObjectGraphVisitor));
			return this;
		}

		[Obsolete("The default behavior is now to always emit default values, thefore calling this method has no effect. This behavior is now controlled by ConfigureDefaultValuesHandling.", true)]
		public SerializerBuilder EmitDefaults()
		{
			return ConfigureDefaultValuesHandling(DefaultValuesHandling.Preserve);
		}

		public SerializerBuilder ConfigureDefaultValuesHandling(DefaultValuesHandling configuration)
		{
			defaultValuesHandlingConfiguration = configuration;
			return this;
		}

		public SerializerBuilder JsonCompatible()
		{
			emitterSettings = emitterSettings.WithMaxSimpleKeyLength(int.MaxValue).WithoutAnchorName();
			return WithTypeConverter(new YamlDotNet.Serialization.Converters.GuidConverter(jsonCompatible: true), delegate(IRegistrationLocationSelectionSyntax<IYamlTypeConverter> w)
			{
				w.InsteadOf<YamlDotNet.Serialization.Converters.GuidConverter>();
			}).WithTypeConverter(new YamlDotNet.Serialization.Converters.DateTimeConverter(DateTimeKind.Utc, null, true)).WithEventEmitter((IEventEmitter inner) => new JsonEventEmitter(inner, yamlFormatter, enumNamingConvention), delegate(IRegistrationLocationSelectionSyntax<IEventEmitter> loc)
			{
				loc.InsteadOf<TypeAssigningEventEmitter>();
			});
		}

		public SerializerBuilder WithNewLine(string newLine)
		{
			emitterSettings = emitterSettings.WithNewLine(newLine);
			return this;
		}

		public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(TObjectGraphVisitor objectGraphVisitor) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			return WithPreProcessingPhaseObjectGraphVisitor(objectGraphVisitor, delegate(IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>> w)
			{
				w.OnTop();
			});
		}

		public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<IEnumerable<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			return WithPreProcessingPhaseObjectGraphVisitor(objectGraphVisitorFactory, delegate(IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>> w)
			{
				w.OnTop();
			});
		}

		public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(TObjectGraphVisitor objectGraphVisitor, Action<IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			TObjectGraphVisitor objectGraphVisitor2 = objectGraphVisitor;
			if (objectGraphVisitor2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitor");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IEnumerable<IYamlTypeConverter> _) => objectGraphVisitor2));
			return this;
		}

		public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<IEnumerable<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			Func<IEnumerable<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IEnumerable<IYamlTypeConverter> typeConverters) => objectGraphVisitorFactory2(typeConverters)));
			return this;
		}

		public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(WrapperFactory<IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			WrapperFactory<IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateTrackingRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IObjectGraphVisitor<Nothing> wrapped, IEnumerable<IYamlTypeConverter> _) => objectGraphVisitorFactory2(wrapped)));
			return this;
		}

		public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(WrapperFactory<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			WrapperFactory<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateTrackingRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IObjectGraphVisitor<Nothing> wrapped, IEnumerable<IYamlTypeConverter> typeConverters) => objectGraphVisitorFactory2(wrapped, typeConverters)));
			return this;
		}

		public SerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>() where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			return WithoutPreProcessingPhaseObjectGraphVisitor(typeof(TObjectGraphVisitor));
		}

		public SerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor(Type objectGraphVisitorType)
		{
			if (objectGraphVisitorType == null)
			{
				throw new ArgumentNullException("objectGraphVisitorType");
			}
			preProcessingPhaseObjectGraphVisitorFactories.Remove(objectGraphVisitorType);
			return this;
		}

		public SerializerBuilder WithObjectGraphTraversalStrategyFactory(ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory)
		{
			this.objectGraphTraversalStrategyFactory = objectGraphTraversalStrategyFactory;
			return this;
		}

		public SerializerBuilder WithEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory) where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			return WithEmissionPhaseObjectGraphVisitor(objectGraphVisitorFactory, delegate(IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<IEmitter>> w)
			{
				w.OnTop();
			});
		}

		public SerializerBuilder WithEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory, Action<IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<IEmitter>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			Func<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(emissionPhaseObjectGraphVisitorFactories.CreateRegistrationLocationSelector(typeof(TObjectGraphVisitor), (EmissionPhaseObjectGraphVisitorArgs args) => objectGraphVisitorFactory2(args)));
			return this;
		}

		public SerializerBuilder WithEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>(WrapperFactory<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IObjectGraphVisitor<IEmitter>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			WrapperFactory<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(emissionPhaseObjectGraphVisitorFactories.CreateTrackingRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IObjectGraphVisitor<IEmitter> wrapped, EmissionPhaseObjectGraphVisitorArgs args) => objectGraphVisitorFactory2(wrapped, args)));
			return this;
		}

		public SerializerBuilder WithoutEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>() where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			return WithoutEmissionPhaseObjectGraphVisitor(typeof(TObjectGraphVisitor));
		}

		public SerializerBuilder WithoutEmissionPhaseObjectGraphVisitor(Type objectGraphVisitorType)
		{
			if (objectGraphVisitorType == null)
			{
				throw new ArgumentNullException("objectGraphVisitorType");
			}
			emissionPhaseObjectGraphVisitorFactories.Remove(objectGraphVisitorType);
			return this;
		}

		public SerializerBuilder WithIndentedSequences()
		{
			emitterSettings = emitterSettings.WithIndentedSequences();
			return this;
		}

		public ISerializer Build()
		{
			return Serializer.FromValueSerializer(BuildValueSerializer(), emitterSettings);
		}

		public IValueSerializer BuildValueSerializer()
		{
			IEnumerable<IYamlTypeConverter> typeConverters = BuildTypeConverters();
			ITypeInspector typeInspector = BuildTypeInspector();
			IObjectGraphTraversalStrategy traversalStrategy = objectGraphTraversalStrategyFactory(typeInspector, typeResolver, typeConverters, maximumRecursion);
			IEventEmitter eventEmitter = eventEmitterFactories.BuildComponentChain(new WriterEventEmitter());
			return new ValueSerializer(traversalStrategy, eventEmitter, typeConverters, preProcessingPhaseObjectGraphVisitorFactories.Clone(), emissionPhaseObjectGraphVisitorFactories.Clone());
		}

		internal ITypeInspector BuildTypeInspector()
		{
			ITypeInspector typeInspector = new ReadablePropertiesTypeInspector(typeResolver, includeNonPublicProperties);
			if (!ignoreFields)
			{
				typeInspector = new CompositeTypeInspector(new ReadableFieldsTypeInspector(typeResolver), typeInspector);
			}
			return typeInspectorFactories.BuildComponentChain(typeInspector);
		}
	}
	internal class Settings
	{
		public bool AllowPrivateConstructors { get; set; }
	}
	internal abstract class StaticBuilderSkeleton<TBuilder> where TBuilder : StaticBuilderSkeleton<TBuilder>
	{
		internal INamingConvention namingConvention = NullNamingConvention.Instance;

		internal INamingConvention enumNamingConvention = NullNamingConvention.Instance;

		internal ITypeResolver typeResolver;

		internal readonly LazyComponentRegistrationList<Nothing, IYamlTypeConverter> typeConverterFactories;

		internal readonly LazyComponentRegistrationList<ITypeInspector, ITypeInspector> typeInspectorFactories;

		internal bool includeNonPublicProperties;

		internal Settings settings;

		internal YamlFormatter yamlFormatter = YamlFormatter.Default;

		protected abstract TBuilder Self { get; }

		internal StaticBuilderSkeleton(ITypeResolver typeResolver)
		{
			typeConverterFactories = new LazyComponentRegistrationList<Nothing, IYamlTypeConverter> { 
			{
				typeof(YamlDotNet.Serialization.Converters.GuidConverter),
				(Nothing _) => new YamlDotNet.Serialization.Converters.GuidConverter(jsonCompatible: false)
			} };
			typeInspectorFactories = new LazyComponentRegistrationList<ITypeInspector, ITypeInspector>();
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			settings = new Settings();
		}

		public TBuilder WithNamingConvention(INamingConvention namingConvention)
		{
			this.namingConvention = namingConvention ?? throw new ArgumentNullException("namingConvention");
			return Self;
		}

		public TBuilder WithEnumNamingConvention(INamingConvention enumNamingConvention)
		{
			this.enumNamingConvention = enumNamingConvention ?? throw new ArgumentNullException("enumNamingConvention");
			return Self;
		}

		public TBuilder WithTypeResolver(ITypeResolver typeResolver)
		{
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			return Self;
		}

		public abstract TBuilder WithTagMapping(TagName tag, Type type);

		public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter)
		{
			return WithTypeConverter(typeConverter, delegate(IRegistrationLocationSelectionSyntax<IYamlTypeConverter> w)
			{
				w.OnTop();
			});
		}

		public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter, Action<IRegistrationLocationSelectionSyntax<IYamlTypeConverter>> where)
		{
			IYamlTypeConverter typeConverter2 = typeConverter;
			if (typeConverter2 == null)
			{
				throw new ArgumentNullException("typeConverter");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeConverterFactories.CreateRegistrationLocationSelector(typeConverter2.GetType(), (Nothing _) => typeConverter2));
			return Self;
		}

		public TBuilder WithTypeConverter<TYamlTypeConverter>(WrapperFactory<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IYamlTypeConverter>> where) where TYamlTypeConverter : IYamlTypeConverter
		{
			WrapperFactory<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory2 = typeConverterFactory;
			if (typeConverterFactory2 == null)
			{
				throw new ArgumentNullException("typeConverterFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeConverterFactories.CreateTrackingRegistrationLocationSelector(typeof(TYamlTypeConverter), (IYamlTypeConverter wrapped, Nothing _) => typeConverterFactory2(wrapped)));
			return Self;
		}

		public TBuilder WithoutTypeConverter<TYamlTypeConverter>() where TYamlTypeConverter : IYamlTypeConverter
		{
			return WithoutTypeConverter(typeof(TYamlTypeConverter));
		}

		public TBuilder WithoutTypeConverter(Type converterType)
		{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType");
			}
			typeConverterFactories.Remove(converterType);
			return Self;
		}

		public TBuilder WithTypeInspector<TTypeInspector>(Func<ITypeInspector, TTypeInspector> typeInspectorFactory) where TTypeInspector : ITypeInspector
		{
			return WithTypeInspector(typeInspectorFactory, delegate(IRegistrationLocationSelectionSyntax<ITypeInspector> w)
			{
				w.OnTop();
			});
		}

		public TBuilder WithTypeInspector<TTypeInspector>(Func<ITypeInspector, TTypeInspector> typeInspectorFactory, Action<IRegistrationLocationSelectionSyntax<ITypeInspector>> where) where TTypeInspector : ITypeInspector
		{
			Func<ITypeInspector, TTypeInspector> typeInspectorFactory2 = typeInspectorFactory;
			if (typeInspectorFactory2 == null)
			{
				throw new ArgumentNullException("typeInspectorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeInspectorFactories.CreateRegistrationLocationSelector(typeof(TTypeInspector), (ITypeInspector inner) => typeInspectorFactory2(inner)));
			return Self;
		}

		public TBuilder WithTypeInspector<TTypeInspector>(WrapperFactory<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<ITypeInspector>> where) where TTypeInspector : ITypeInspector
		{
			WrapperFactory<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory2 = typeInspectorFactory;
			if (typeInspectorFactory2 == null)
			{
				throw new ArgumentNullException("typeInspectorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(typeInspectorFactories.CreateTrackingRegistrationLocationSelector(typeof(TTypeInspector), (ITypeInspector wrapped, ITypeInspector inner) => typeInspectorFactory2(wrapped, inner)));
			return Self;
		}

		public TBuilder WithoutTypeInspector<TTypeInspector>() where TTypeInspector : ITypeInspector
		{
			return WithoutTypeInspector(typeof(TTypeInspector));
		}

		public TBuilder WithoutTypeInspector(Type inspectorType)
		{
			if (inspectorType == null)
			{
				throw new ArgumentNullException("inspectorType");
			}
			typeInspectorFactories.Remove(inspectorType);
			return Self;
		}

		public TBuilder WithYamlFormatter(YamlFormatter formatter)
		{
			yamlFormatter = formatter ?? throw new ArgumentNullException("formatter");
			return Self;
		}

		protected IEnumerable<IYamlTypeConverter> BuildTypeConverters()
		{
			return typeConverterFactories.BuildComponentList();
		}
	}
	internal abstract class StaticContext
	{
		public virtual bool IsKnownType(Type type)
		{
			throw new NotImplementedException();
		}

		public virtual ITypeResolver GetTypeResolver()
		{
			throw new NotImplementedException();
		}

		public virtual StaticObjectFactory GetFactory()
		{
			throw new NotImplementedException();
		}

		public virtual ITypeInspector GetTypeInspector()
		{
			throw new NotImplementedException();
		}
	}
	internal sealed class StaticDeserializerBuilder : StaticBuilderSkeleton<StaticDeserializerBuilder>
	{
		private readonly StaticContext context;

		private readonly StaticObjectFactory factory;

		private readonly LazyComponentRegistrationList<Nothing, INodeDeserializer> nodeDeserializerFactories;

		private readonly LazyComponentRegistrationList<Nothing, INodeTypeResolver> nodeTypeResolverFactories;

		private readonly Dictionary<TagName, Type> tagMappings;

		private readonly ITypeConverter typeConverter;

		private readonly Dictionary<Type, Type> typeMappings;

		private bool ignoreUnmatched;

		private bool duplicateKeyChecking;

		private bool attemptUnknownTypeDeserialization;

		protected override StaticDeserializerBuilder Self => this;

		public StaticDeserializerBuilder(StaticContext context)
			: base(context.GetTypeResolver())
		{
			this.context = context;
			factory = context.GetFactory();
			typeMappings = new Dictionary<Type, Type>();
			tagMappings = new Dictionary<TagName, Type>
			{
				{
					FailsafeSchema.Tags.Map,
					typeof(Dictionary<object, object>)
				},
				{
					FailsafeSchema.Tags.Str,
					typeof(string)
				},
				{
					JsonSchema.Tags.Bool,
					typeof(bool)
				},
				{
					JsonSchema.Tags.Float,
					typeof(double)
				},
				{
					JsonSchema.Tags.Int,
					typeof(int)
				},
				{
					DefaultSchema.Tags.Timestamp,
					typeof(DateTime)
				}
			};
			typeInspectorFactories.Add(typeof(CachedTypeInspector), (ITypeInspector inner) => new CachedTypeInspector(inner));
			typeInspectorFactories.Add(typeof(NamingConventionTypeInspector), (ITypeInspector inner) => (!(namingConvention is NullNamingConvention)) ? new NamingConventionTypeInspector(inner, namingConvention) : inner);
			typeInspectorFactories.Add(typeof(YamlAttributesTypeInspector), (ITypeInspector inner) => new YamlAttributesTypeInspector(inner));
			nodeDeserializerFactories = new LazyComponentRegistrationList<Nothing, INodeDeserializer>
			{
				{
					typeof(YamlConvertibleNodeDeserializer),
					(Nothing _) => new YamlConvertibleNodeDeserializer(factory)
				},
				{
					typeof(YamlSerializableNodeDeserializer),
					(Nothing _) => new YamlSerializableNodeDeserializer(factory)
				},
				{
					typeof(TypeConverterNodeDeserializer),
					(Nothing _) => new TypeConverterNodeDeserializer(BuildTypeConverters())
				},
				{
					typeof(NullNodeDeserializer),
					(Nothing _) => new NullNodeDeserializer()
				},
				{
					typeof(ScalarNodeDeserializer),
					(Nothing _) => new ScalarNodeDeserializer(attemptUnknownTypeDeserialization, typeConverter, yamlFormatter, enumNamingConvention)
				},
				{
					typeof(StaticArrayNodeDeserializer),
					(Nothing _) => new StaticArrayNodeDeserializer(factory)
				},
				{
					typeof(StaticDictionaryNodeDeserializer),
					(Nothing _) => new StaticDictionaryNodeDeserializer(factory, duplicateKeyChecking)
				},
				{
					typeof(StaticCollectionNodeDeserializer),
					(Nothing _) => new StaticCollectionNodeDeserializer(factory)
				},
				{
					typeof(ObjectNodeDeserializer),
					(Nothing _) => new ObjectNodeDeserializer(factory, BuildTypeInspector(), ignoreUnmatched, duplicateKeyChecking, typeConverter, enumNamingConvention)
				}
			};
			nodeTypeResolverFactories = new LazyComponentRegistrationList<Nothing, INodeTypeResolver>
			{
				{
					typeof(MappingNodeTypeResolver),
					(Nothing _) => new MappingNodeTypeResolver(typeMappings)
				},
				{
					typeof(YamlConvertibleTypeResolver),
					(Nothing _) => new YamlConvertibleTypeResolver()
				},
				{
					typeof(YamlSerializableTypeResolver),
					(Nothing _) => new YamlSerializableTypeResolver()
				},
				{
					typeof(TagNodeTypeResolver),
					(Nothing _) => new TagNodeTypeResolver(tagMappings)
				},
				{
					typeof(PreventUnknownTagsNodeTypeResolver),
					(Nothing _) => new PreventUnknownTagsNodeTypeResolver()
				},
				{
					typeof(DefaultContainersNodeTypeResolver),
					(Nothing _) => new DefaultContainersNodeTypeResolver()
				}
			};
			typeConverter = new NullTypeConverter();
		}

		internal ITypeInspector BuildTypeInspector()
		{
			ITypeInspector typeInspector = context.GetTypeInspector();
			return typeInspectorFactories.BuildComponentChain(typeInspector);
		}

		public StaticDeserializerBuilder WithAttemptingUnquotedStringTypeDeserialization()
		{
			attemptUnknownTypeDeserialization = true;
			return this;
		}

		public StaticDeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer)
		{
			return WithNodeDeserializer(nodeDeserializer, delegate(IRegistrationLocationSelectionSyntax<INodeDeserializer> w)
			{
				w.OnTop();
			});
		}

		public StaticDeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer, Action<IRegistrationLocationSelectionSyntax<INodeDeserializer>> where)
		{
			INodeDeserializer nodeDeserializer2 = nodeDeserializer;
			if (nodeDeserializer2 == null)
			{
				throw new ArgumentNullException("nodeDeserializer");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeDeserializerFactories.CreateRegistrationLocationSelector(nodeDeserializer2.GetType(), (Nothing _) => nodeDeserializer2));
			return this;
		}

		public StaticDeserializerBuilder WithNodeDeserializer<TNodeDeserializer>(WrapperFactory<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory, Action<ITrackingRegistrationLocationSelectionSyntax<INodeDeserializer>> where) where TNodeDeserializer : INodeDeserializer
		{
			WrapperFactory<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory2 = nodeDeserializerFactory;
			if (nodeDeserializerFactory2 == null)
			{
				throw new ArgumentNullException("nodeDeserializerFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeDeserializerFactories.CreateTrackingRegistrationLocationSelector(typeof(TNodeDeserializer), (INodeDeserializer wrapped, Nothing _) => nodeDeserializerFactory2(wrapped)));
			return this;
		}

		public StaticDeserializerBuilder WithoutNodeDeserializer<TNodeDeserializer>() where TNodeDeserializer : INodeDeserializer
		{
			return WithoutNodeDeserializer(typeof(TNodeDeserializer));
		}

		public StaticDeserializerBuilder WithoutNodeDeserializer(Type nodeDeserializerType)
		{
			if (nodeDeserializerType == null)
			{
				throw new ArgumentNullException("nodeDeserializerType");
			}
			nodeDeserializerFactories.Remove(nodeDeserializerType);
			return this;
		}

		public StaticDeserializerBuilder WithTypeDiscriminatingNodeDeserializer(Action<ITypeDiscriminatingNodeDeserializerOptions> configureTypeDiscriminatingNodeDeserializerOptions, int maxDepth = -1, int maxLength = -1)
		{
			TypeDiscriminatingNodeDeserializerOptions typeDiscriminatingNodeDeserializerOptions = new TypeDiscriminatingNodeDeserializerOptions();
			configureTypeDiscriminatingNodeDeserializerOptions(typeDiscriminatingNodeDeserializerOptions);
			TypeDiscriminatingNodeDeserializer nodeDeserializer = new TypeDiscriminatingNodeDeserializer(nodeDeserializerFactories.BuildComponentList(), typeDiscriminatingNodeDeserializerOptions.discriminators, maxDepth, maxLength);
			return WithNodeDeserializer(nodeDeserializer, delegate(IRegistrationLocationSelectionSyntax<INodeDeserializer> s)
			{
				s.Before<DictionaryNodeDeserializer>();
			});
		}

		public StaticDeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver)
		{
			return WithNodeTypeResolver(nodeTypeResolver, delegate(IRegistrationLocationSelectionSyntax<INodeTypeResolver> w)
			{
				w.OnTop();
			});
		}

		public StaticDeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver, Action<IRegistrationLocationSelectionSyntax<INodeTypeResolver>> where)
		{
			INodeTypeResolver nodeTypeResolver2 = nodeTypeResolver;
			if (nodeTypeResolver2 == null)
			{
				throw new ArgumentNullException("nodeTypeResolver");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeTypeResolverFactories.CreateRegistrationLocationSelector(nodeTypeResolver2.GetType(), (Nothing _) => nodeTypeResolver2));
			return this;
		}

		public StaticDeserializerBuilder WithNodeTypeResolver<TNodeTypeResolver>(WrapperFactory<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory, Action<ITrackingRegistrationLocationSelectionSyntax<INodeTypeResolver>> where) where TNodeTypeResolver : INodeTypeResolver
		{
			WrapperFactory<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory2 = nodeTypeResolverFactory;
			if (nodeTypeResolverFactory2 == null)
			{
				throw new ArgumentNullException("nodeTypeResolverFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(nodeTypeResolverFactories.CreateTrackingRegistrationLocationSelector(typeof(TNodeTypeResolver), (INodeTypeResolver wrapped, Nothing _) => nodeTypeResolverFactory2(wrapped)));
			return this;
		}

		public StaticDeserializerBuilder WithoutNodeTypeResolver<TNodeTypeResolver>() where TNodeTypeResolver : INodeTypeResolver
		{
			return WithoutNodeTypeResolver(typeof(TNodeTypeResolver));
		}

		public StaticDeserializerBuilder WithoutNodeTypeResolver(Type nodeTypeResolverType)
		{
			if (nodeTypeResolverType == null)
			{
				throw new ArgumentNullException("nodeTypeResolverType");
			}
			nodeTypeResolverFactories.Remove(nodeTypeResolverType);
			return this;
		}

		public override StaticDeserializerBuilder WithTagMapping(TagName tag, Type type)
		{
			if (tag.IsEmpty)
			{
				throw new ArgumentException("Non-specific tags cannot be maped");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (tagMappings.TryGetValue(tag, out Type value))
			{
				throw new ArgumentException($"Type already has a registered type '{value.FullName}' for tag '{tag}'", "tag");
			}
			tagMappings.Add(tag, type);
			return this;
		}

		public StaticDeserializerBuilder WithTypeMapping<TInterface, TConcrete>() where TConcrete : TInterface
		{
			Type typeFromHandle = typeof(TInterface);
			Type typeFromHandle2 = typeof(TConcrete);
			if (!typeFromHandle.IsAssignableFrom(typeFromHandle2))
			{
				throw new InvalidOperationException("The type '" + typeFromHandle2.Name + "' does not implement interface '" + typeFromHandle.Name + "'.");
			}
			if (typeMappings.ContainsKey(typeFromHandle))
			{
				typeMappings[typeFromHandle] = typeFromHandle2;
			}
			else
			{
				typeMappings.Add(typeFromHandle, typeFromHandle2);
			}
			return this;
		}

		public StaticDeserializerBuilder WithoutTagMapping(TagName tag)
		{
			if (tag.IsEmpty)
			{
				throw new ArgumentException("Non-specific tags cannot be maped");
			}
			if (!tagMappings.Remove(tag))
			{
				throw new KeyNotFoundException($"Tag '{tag}' is not registered");
			}
			return this;
		}

		public StaticDeserializerBuilder IgnoreUnmatchedProperties()
		{
			ignoreUnmatched = true;
			return this;
		}

		public StaticDeserializerBuilder WithDuplicateKeyChecking()
		{
			duplicateKeyChecking = true;
			return this;
		}

		public IDeserializer Build()
		{
			return Deserializer.FromValueDeserializer(BuildValueDeserializer());
		}

		public IValueDeserializer BuildValueDeserializer()
		{
			return new AliasValueDeserializer(new NodeValueDeserializer(nodeDeserializerFactories.BuildComponentList(), nodeTypeResolverFactories.BuildComponentList(), typeConverter, enumNamingConvention));
		}
	}
	internal sealed class StaticSerializerBuilder : StaticBuilderSkeleton<StaticSerializerBuilder>
	{
		private class ValueSerializer : IValueSerializer
		{
			private readonly IObjectGraphTraversalStrategy traversalStrategy;

			private readonly IEventEmitter eventEmitter;

			private readonly IEnumerable<IYamlTypeConverter> typeConverters;

			private readonly LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;

			private readonly LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>> emissionPhaseObjectGraphVisitorFactories;

			public ValueSerializer(IObjectGraphTraversalStrategy traversalStrategy, IEventEmitter eventEmitter, IEnumerable<IYamlTypeConverter> typeConverters, LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitorFactories, LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>> emissionPhaseObjectGraphVisitorFactories)
			{
				this.traversalStrategy = traversalStrategy;
				this.eventEmitter = eventEmitter;
				this.typeConverters = typeConverters;
				this.preProcessingPhaseObjectGraphVisitorFactories = preProcessingPhaseObjectGraphVisitorFactories;
				this.emissionPhaseObjectGraphVisitorFactories = emissionPhaseObjectGraphVisitorFactories;
			}

			public void SerializeValue(IEmitter emitter, object? value, Type? type)
			{
				IEmitter emitter2 = emitter;
				Type type2 = type ?? ((value != null) ? value.GetType() : typeof(object));
				Type staticType = type ?? typeof(object);
				ObjectDescriptor graph = new ObjectDescriptor(value, type2, staticType);
				List<IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitors = preProcessingPhaseObjectGraphVisitorFactories.BuildComponentList(typeConverters);
				foreach (IObjectGraphVisitor<Nothing> item in preProcessingPhaseObjectGraphVisitors)
				{
					traversalStrategy.Traverse(graph, item, default(Nothing));
				}
				IObjectGraphVisitor<IEmitter> visitor = emissionPhaseObjectGraphVisitorFactories.BuildComponentChain<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>>(new EmittingObjectGraphVisitor(eventEmitter), (IObjectGraphVisitor<IEmitter> inner) => new EmissionPhaseObjectGraphVisitorArgs(inner, eventEmitter, preProcessingPhaseObjectGraphVisitors, typeConverters, NestedObjectSerializer));
				traversalStrategy.Traverse(graph, visitor, emitter2);
				void NestedObjectSerializer(object? v, Type? t)
				{
					SerializeValue(emitter2, v, t);
				}
			}
		}

		private readonly StaticContext context;

		private readonly StaticObjectFactory factory;

		private ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory;

		private readonly LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;

		private readonly LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>> emissionPhaseObjectGraphVisitorFactories;

		private readonly LazyComponentRegistrationList<IEventEmitter, IEventEmitter> eventEmitterFactories;

		private readonly IDictionary<Type, TagName> tagMappings = new Dictionary<Type, TagName>();

		private int maximumRecursion = 50;

		private EmitterSettings emitterSettings = EmitterSettings.Default;

		private DefaultValuesHandling defaultValuesHandlingConfiguration;

		private bool quoteNecessaryStrings;

		private bool quoteYaml1_1Strings;

		private ScalarStyle defaultScalarStyle;

		protected override StaticSerializerBuilder Self => this;

		public StaticSerializerBuilder(StaticContext context)
			: base((ITypeResolver)new DynamicTypeResolver())
		{
			this.context = context;
			factory = context.GetFactory();
			typeInspectorFactories.Add(typeof(CachedTypeInspector), (ITypeInspector inner) => new CachedTypeInspector(inner));
			typeInspectorFactories.Add(typeof(NamingConventionTypeInspector), (ITypeInspector inner) => (!(namingConvention is NullNamingConvention)) ? new NamingConventionTypeInspector(inner, namingConvention) : inner);
			typeInspectorFactories.Add(typeof(YamlAttributesTypeInspector), (ITypeInspector inner) => new YamlAttributesTypeInspector(inner));
			preProcessingPhaseObjectGraphVisitorFactories = new LazyComponentRegistrationList<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>> { 
			{
				typeof(AnchorAssigner),
				(IEnumerable<IYamlTypeConverter> typeConverters) => new AnchorAssigner(typeConverters)
			} };
			emissionPhaseObjectGraphVisitorFactories = new LazyComponentRegistrationList<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>>
			{
				{
					typeof(CustomSerializationObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new CustomSerializationObjectGraphVisitor(args.InnerVisitor, args.TypeConverters, args.NestedObjectSerializer)
				},
				{
					typeof(AnchorAssigningObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new AnchorAssigningObjectGraphVisitor(args.InnerVisitor, args.EventEmitter, args.GetPreProcessingPhaseObjectGraphVisitor<AnchorAssigner>())
				},
				{
					typeof(DefaultValuesObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new DefaultValuesObjectGraphVisitor(defaultValuesHandlingConfiguration, args.InnerVisitor, factory)
				},
				{
					typeof(CommentsObjectGraphVisitor),
					(EmissionPhaseObjectGraphVisitorArgs args) => new CommentsObjectGraphVisitor(args.InnerVisitor)
				}
			};
			eventEmitterFactories = new LazyComponentRegistrationList<IEventEmitter, IEventEmitter> { 
			{
				typeof(TypeAssigningEventEmitter),
				(IEventEmitter inner) => new TypeAssigningEventEmitter(inner, requireTagWhenStaticAndActualTypesAreDifferent: false, tagMappings, quoteNecessaryStrings, quoteYaml1_1Strings, defaultScalarStyle, yamlFormatter, enumNamingConvention)
			} };
			objectGraphTraversalStrategyFactory = (ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable<IYamlTypeConverter> typeConverters, int maximumRecursion) => new FullObjectGraphTraversalStrategy(typeInspector, typeResolver, maximumRecursion, namingConvention, factory);
		}

		public StaticSerializerBuilder WithQuotingNecessaryStrings(bool quoteYaml1_1Strings = false)
		{
			quoteNecessaryStrings = true;
			this.quoteYaml1_1Strings = quoteYaml1_1Strings;
			return this;
		}

		public StaticSerializerBuilder WithQuotingNecessaryStrings()
		{
			quoteNecessaryStrings = true;
			return this;
		}

		public StaticSerializerBuilder WithDefaultScalarStyle(ScalarStyle style)
		{
			defaultScalarStyle = style;
			return this;
		}

		public StaticSerializerBuilder WithMaximumRecursion(int maximumRecursion)
		{
			if (maximumRecursion <= 0)
			{
				throw new ArgumentOutOfRangeException("maximumRecursion", $"The maximum recursion specified ({maximumRecursion}) is invalid. It should be a positive integer.");
			}
			this.maximumRecursion = maximumRecursion;
			return this;
		}

		public StaticSerializerBuilder WithEventEmitter<TEventEmitter>(Func<IEventEmitter, TEventEmitter> eventEmitterFactory) where TEventEmitter : IEventEmitter
		{
			return WithEventEmitter(eventEmitterFactory, delegate(IRegistrationLocationSelectionSyntax<IEventEmitter> w)
			{
				w.OnTop();
			});
		}

		public StaticSerializerBuilder WithEventEmitter<TEventEmitter>(Func<IEventEmitter, TEventEmitter> eventEmitterFactory, Action<IRegistrationLocationSelectionSyntax<IEventEmitter>> where) where TEventEmitter : IEventEmitter
		{
			Func<IEventEmitter, TEventEmitter> eventEmitterFactory2 = eventEmitterFactory;
			if (eventEmitterFactory2 == null)
			{
				throw new ArgumentNullException("eventEmitterFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(eventEmitterFactories.CreateRegistrationLocationSelector(typeof(TEventEmitter), (IEventEmitter inner) => eventEmitterFactory2(inner)));
			return Self;
		}

		public StaticSerializerBuilder WithEventEmitter<TEventEmitter>(WrapperFactory<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IEventEmitter>> where) where TEventEmitter : IEventEmitter
		{
			WrapperFactory<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory2 = eventEmitterFactory;
			if (eventEmitterFactory2 == null)
			{
				throw new ArgumentNullException("eventEmitterFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(eventEmitterFactories.CreateTrackingRegistrationLocationSelector(typeof(TEventEmitter), (IEventEmitter wrapped, IEventEmitter inner) => eventEmitterFactory2(wrapped, inner)));
			return Self;
		}

		public StaticSerializerBuilder WithoutEventEmitter<TEventEmitter>() where TEventEmitter : IEventEmitter
		{
			return WithoutEventEmitter(typeof(TEventEmitter));
		}

		public StaticSerializerBuilder WithoutEventEmitter(Type eventEmitterType)
		{
			if (eventEmitterType == null)
			{
				throw new ArgumentNullException("eventEmitterType");
			}
			eventEmitterFactories.Remove(eventEmitterType);
			return this;
		}

		public override StaticSerializerBuilder WithTagMapping(TagName tag, Type type)
		{
			if (tag.IsEmpty)
			{
				throw new ArgumentException("Non-specific tags cannot be maped");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (tagMappings.TryGetValue(type, out var value))
			{
				throw new ArgumentException($"Type already has a registered tag '{value}' for type '{type.FullName}'", "type");
			}
			tagMappings.Add(type, tag);
			return this;
		}

		public StaticSerializerBuilder WithoutTagMapping(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (!tagMappings.Remove(type))
			{
				throw new KeyNotFoundException("Tag for type '" + type.FullName + "' is not registered");
			}
			return this;
		}

		public StaticSerializerBuilder EnsureRoundtrip()
		{
			objectGraphTraversalStrategyFactory = (ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable<IYamlTypeConverter> typeConverters, int maximumRecursion) => new RoundtripObjectGraphTraversalStrategy(typeConverters, typeInspector, typeResolver, maximumRecursion, namingConvention, settings, factory);
			WithEventEmitter((IEventEmitter inner) => new TypeAssigningEventEmitter(inner, requireTagWhenStaticAndActualTypesAreDifferent: true, tagMappings, quoteNecessaryStrings, quoteYaml1_1Strings: false, ScalarStyle.Plain, YamlFormatter.Default, enumNamingConvention), delegate(IRegistrationLocationSelectionSyntax<IEventEmitter> loc)
			{
				loc.InsteadOf<TypeAssigningEventEmitter>();
			});
			return WithTypeInspector((ITypeInspector inner) => new ReadableAndWritablePropertiesTypeInspector(inner), delegate(IRegistrationLocationSelectionSyntax<ITypeInspector> loc)
			{
				loc.OnBottom();
			});
		}

		public StaticSerializerBuilder DisableAliases()
		{
			preProcessingPhaseObjectGraphVisitorFactories.Remove(typeof(AnchorAssigner));
			emissionPhaseObjectGraphVisitorFactories.Remove(typeof(AnchorAssigningObjectGraphVisitor));
			return this;
		}

		[Obsolete("The default behavior is now to always emit default values, thefore calling this method has no effect. This behavior is now controlled by ConfigureDefaultValuesHandling.", true)]
		public StaticSerializerBuilder EmitDefaults()
		{
			return ConfigureDefaultValuesHandling(DefaultValuesHandling.Preserve);
		}

		public StaticSerializerBuilder ConfigureDefaultValuesHandling(DefaultValuesHandling configuration)
		{
			defaultValuesHandlingConfiguration = configuration;
			return this;
		}

		public StaticSerializerBuilder JsonCompatible()
		{
			emitterSettings = emitterSettings.WithMaxSimpleKeyLength(int.MaxValue).WithoutAnchorName();
			return WithTypeConverter(new YamlDotNet.Serialization.Converters.GuidConverter(jsonCompatible: true), delegate(IRegistrationLocationSelectionSyntax<IYamlTypeConverter> w)
			{
				w.InsteadOf<YamlDotNet.Serialization.Converters.GuidConverter>();
			}).WithTypeConverter(new YamlDotNet.Serialization.Converters.DateTimeConverter(DateTimeKind.Utc, null, true)).WithEventEmitter((IEventEmitter inner) => new JsonEventEmitter(inner, yamlFormatter, enumNamingConvention), delegate(IRegistrationLocationSelectionSyntax<IEventEmitter> loc)
			{
				loc.InsteadOf<TypeAssigningEventEmitter>();
			});
		}

		public StaticSerializerBuilder WithNewLine(string newLine)
		{
			emitterSettings = emitterSettings.WithNewLine(newLine);
			return this;
		}

		public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(TObjectGraphVisitor objectGraphVisitor) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			return WithPreProcessingPhaseObjectGraphVisitor(objectGraphVisitor, delegate(IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>> w)
			{
				w.OnTop();
			});
		}

		public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<IEnumerable<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			return WithPreProcessingPhaseObjectGraphVisitor(objectGraphVisitorFactory, delegate(IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>> w)
			{
				w.OnTop();
			});
		}

		public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(TObjectGraphVisitor objectGraphVisitor, Action<IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			TObjectGraphVisitor objectGraphVisitor2 = objectGraphVisitor;
			if (objectGraphVisitor2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitor");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IEnumerable<IYamlTypeConverter> _) => objectGraphVisitor2));
			return this;
		}

		public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<IEnumerable<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			Func<IEnumerable<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IEnumerable<IYamlTypeConverter> typeConverters) => objectGraphVisitorFactory2(typeConverters)));
			return this;
		}

		public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(WrapperFactory<IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			WrapperFactory<IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateTrackingRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IObjectGraphVisitor<Nothing> wrapped, IEnumerable<IYamlTypeConverter> _) => objectGraphVisitorFactory2(wrapped)));
			return this;
		}

		public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>(WrapperFactory<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IObjectGraphVisitor<Nothing>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			WrapperFactory<IEnumerable<IYamlTypeConverter>, IObjectGraphVisitor<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(preProcessingPhaseObjectGraphVisitorFactories.CreateTrackingRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IObjectGraphVisitor<Nothing> wrapped, IEnumerable<IYamlTypeConverter> typeConverters) => objectGraphVisitorFactory2(wrapped, typeConverters)));
			return this;
		}

		public StaticSerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor<TObjectGraphVisitor>() where TObjectGraphVisitor : IObjectGraphVisitor<Nothing>
		{
			return WithoutPreProcessingPhaseObjectGraphVisitor(typeof(TObjectGraphVisitor));
		}

		public StaticSerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor(Type objectGraphVisitorType)
		{
			if (objectGraphVisitorType == null)
			{
				throw new ArgumentNullException("objectGraphVisitorType");
			}
			preProcessingPhaseObjectGraphVisitorFactories.Remove(objectGraphVisitorType);
			return this;
		}

		public StaticSerializerBuilder WithObjectGraphTraversalStrategyFactory(ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory)
		{
			this.objectGraphTraversalStrategyFactory = objectGraphTraversalStrategyFactory;
			return this;
		}

		public StaticSerializerBuilder WithEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory) where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			return WithEmissionPhaseObjectGraphVisitor(objectGraphVisitorFactory, delegate(IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<IEmitter>> w)
			{
				w.OnTop();
			});
		}

		public StaticSerializerBuilder WithEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>(Func<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory, Action<IRegistrationLocationSelectionSyntax<IObjectGraphVisitor<IEmitter>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			Func<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(emissionPhaseObjectGraphVisitorFactories.CreateRegistrationLocationSelector(typeof(TObjectGraphVisitor), (EmissionPhaseObjectGraphVisitorArgs args) => objectGraphVisitorFactory2(args)));
			return this;
		}

		public StaticSerializerBuilder WithEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>(WrapperFactory<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action<ITrackingRegistrationLocationSelectionSyntax<IObjectGraphVisitor<IEmitter>>> where) where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			WrapperFactory<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory2 = objectGraphVisitorFactory;
			if (objectGraphVisitorFactory2 == null)
			{
				throw new ArgumentNullException("objectGraphVisitorFactory");
			}
			if (where == null)
			{
				throw new ArgumentNullException("where");
			}
			where(emissionPhaseObjectGraphVisitorFactories.CreateTrackingRegistrationLocationSelector(typeof(TObjectGraphVisitor), (IObjectGraphVisitor<IEmitter> wrapped, EmissionPhaseObjectGraphVisitorArgs args) => objectGraphVisitorFactory2(wrapped, args)));
			return this;
		}

		public StaticSerializerBuilder WithoutEmissionPhaseObjectGraphVisitor<TObjectGraphVisitor>() where TObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
		{
			return WithoutEmissionPhaseObjectGraphVisitor(typeof(TObjectGraphVisitor));
		}

		public StaticSerializerBuilder WithoutEmissionPhaseObjectGraphVisitor(Type objectGraphVisitorType)
		{
			if (objectGraphVisitorType == null)
			{
				throw new ArgumentNullException("objectGraphVisitorType");
			}
			emissionPhaseObjectGraphVisitorFactories.Remove(objectGraphVisitorType);
			return this;
		}

		public StaticSerializerBuilder WithIndentedSequences()
		{
			emitterSettings = emitterSettings.WithIndentedSequences();
			return this;
		}

		public ISerializer Build()
		{
			return Serializer.FromValueSerializer(BuildValueSerializer(), emitterSettings);
		}

		public IValueSerializer BuildValueSerializer()
		{
			IEnumerable<IYamlTypeConverter> typeConverters = BuildTypeConverters();
			ITypeInspector typeInspector = BuildTypeInspector();
			IObjectGraphTraversalStrategy traversalStrategy = objectGraphTraversalStrategyFactory(typeInspector, typeResolver, typeConverters, maximumRecursion);
			IEventEmitter eventEmitter = eventEmitterFactories.BuildComponentChain(new WriterEventEmitter());
			return new ValueSerializer(traversalStrategy, eventEmitter, typeConverters, preProcessingPhaseObjectGraphVisitorFactories.Clone(), emissionPhaseObjectGraphVisitorFactories.Clone());
		}

		internal ITypeInspector BuildTypeInspector()
		{
			ITypeInspector typeInspector = context.GetTypeInspector();
			return typeInspectorFactories.BuildComponentChain(typeInspector);
		}
	}
	internal sealed class StreamFragment : IYamlConvertible
	{
		private readonly List<ParsingEvent> events = new List<ParsingEvent>();

		public IList<ParsingEvent> Events => events;

		void IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer)
		{
			events.Clear();
			int num = 0;
			do
			{
				if (!parser.MoveNext())
				{
					throw new InvalidOperationException("The parser has reached the end before deserialization completed.");
				}
				ParsingEvent current = parser.Current;
				events.Add(current);
				num += current.NestingIncrease;
			}
			while (num > 0);
		}

		void IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer)
		{
			foreach (ParsingEvent @event in events)
			{
				emitter.Emit(@event);
			}
		}
	}
	internal sealed class TagMappings
	{
		private readonly IDictionary<string, Type> mappings;

		public TagMappings()
		{
			mappings = new Dictionary<string, Type>();
		}

		public TagMappings(IDictionary<string, Type> mappings)
		{
			this.mappings = new Dictionary<string, Type>(mappings);
		}

		public void Add(string tag, Type mapping)
		{
			mappings.Add(tag, mapping);
		}

		internal Type? GetMapping(string tag)
		{
			if (!mappings.TryGetValue(tag, out Type value))
			{
				return null;
			}
			return value;
		}
	}
	internal sealed class YamlAttributeOverrides
	{
		private struct AttributeKey
		{
			public readonly Type AttributeType;

			public readonly string PropertyName;

			public AttributeKey(Type attributeType, string propertyName)
			{
				AttributeType = attributeType;
				PropertyName = propertyName;
			}

			public override bool Equals(object? obj)
			{
				if (obj is AttributeKey attributeKey && AttributeType.Equals(attributeKey.AttributeType))
				{
					return PropertyName.Equals(attributeKey.PropertyName);
				}
				return false;
			}

			public override int GetHashCode()
			{
				return YamlDotNet.Core.HashCode.CombineHashCodes(AttributeType.GetHashCode(), PropertyName.GetHashCode());
			}
		}

		private sealed class AttributeMapping
		{
			public readonly Type RegisteredType;

			public readonly Attribute Attribute;

			public AttributeMapping(Type registeredType, Attribute attribute)
			{
				RegisteredType = registeredType;
				Attribute = attribute;
			}

			public override bool Equals(object? obj)
			{
				if (obj is AttributeMapping attributeMapping && RegisteredType.Equals(attributeMapping.RegisteredType))
				{
					return Attribute.Equals(attributeMapping.Attribute);
				}
				return false;
			}

			public override int GetHashCode()
			{
				return YamlDotNet.Core.HashCode.CombineHashCodes(RegisteredType.GetHashCode(), Attribute.GetHashCode());
			}

			public int Matches(Type matchType)
			{
				int num = 0;
				Type type = matchType;
				while (type != null)
				{
					num++;
					if (type == RegisteredType)
					{
						return num;
					}
					type = type.BaseType();
				}
				if (matchType.GetInterfaces().Contains(RegisteredType))
				{
					return num;
				}
				return 0;
			}
		}

		private readonly Dictionary<AttributeKey, List<AttributeMapping>> overrides = new Dictionary<AttributeKey, List<AttributeMapping>>();

		[return: MaybeNull]
		public T GetAttribute<T>(Type type, string member) where T : Attribute
		{
			if (overrides.TryGetValue(new AttributeKey(typeof(T), member), out List<AttributeMapping> value))
			{
				int num = 0;
				AttributeMapping attributeMapping = null;
				foreach (AttributeMapping item in value)
				{
					int num2 = item.Matches(type);
					if (num2 > num)
					{
						num = num2;
						attributeMapping = item;
					}
				}
				if (num > 0)
				{
					return (T)attributeMapping.Attribute;
				}
			}
			return null;
		}

		public void Add(Type type, string member, Attribute attribute)
		{
			AttributeMapping item = new AttributeMapping(type, attribute);
			AttributeKey key = new AttributeKey(attribute.GetType(), member);
			if (!overrides.TryGetValue(key, out List<AttributeMapping> value))
			{
				value = new List<AttributeMapping>();
				overrides.Add(key, value);
			}
			else if (value.Contains(item))
			{
				throw new InvalidOperationException($"Attribute ({attribute}) already set for Type {type.FullName}, Member {member}");
			}
			value.Add(item);
		}

		public YamlAttributeOverrides Clone()
		{
			YamlAttributeOverrides yamlAttributeOverrides = new YamlAttributeOverrides();
			foreach (KeyValuePair<AttributeKey, List<AttributeMapping>> @override in overrides)
			{
				foreach (AttributeMapping item in @override.Value)
				{
					yamlAttributeOverrides.Add(item.RegisteredType, @override.Key.PropertyName, item.Attribute);
				}
			}
			return yamlAttributeOverrides;
		}

		public void Add<TClass>(Expression<Func<TClass, object>> propertyAccessor, Attribute attribute)
		{
			PropertyInfo propertyInfo = propertyAccessor.AsProperty();
			Add(typeof(TClass), propertyInfo.Name, attribute);
		}
	}
	internal sealed class YamlAttributeOverridesInspector : TypeInspectorSkeleton
	{
		public sealed class OverridePropertyDescriptor : IPropertyDescriptor
		{
			private readonly IPropertyDescriptor baseDescriptor;

			private readonly YamlAttributeOverrides overrides;

			private readonly Type classType;

			public string Name => baseDescriptor.Name;

			public bool CanWrite => baseDescriptor.CanWrite;

			public Type Type => baseDescriptor.Type;

			public Type? TypeOverride
			{
				get
				{
					return baseDescriptor.TypeOverride;
				}
				set
				{
					baseDescriptor.TypeOverride = value;
				}
			}

			public int Order
			{
				get
				{
					return baseDescriptor.Order;
				}
				set
				{
					baseDescriptor.Order = value;
				}
			}

			public ScalarStyle ScalarStyle
			{
				get
				{
					return baseDescriptor.ScalarStyle;
				}
				set
				{
					baseDescriptor.ScalarStyle = value;
				}
			}

			public OverridePropertyDescriptor(IPropertyDescriptor baseDescriptor, YamlAttributeOverrides overrides, Type classType)
			{
				this.baseDescriptor = baseDescriptor;
				this.overrides = overrides;
				this.classType = classType;
			}

			public void Write(object target, object? value)
			{
				baseDescriptor.Write(target, value);
			}

			public T? GetCustomAttribute<T>() where T : Attribute
			{
				return overrides.GetAttribute<T>(classType, Name) ?? baseDescriptor.GetCustomAttribute<T>();
			}

			public IObjectDescriptor Read(object target)
			{
				return baseDescriptor.Read(target);
			}
		}

		private readonly ITypeInspector innerTypeDescriptor;

		private readonly YamlAttributeOverrides overrides;

		public YamlAttributeOverridesInspector(ITypeInspector innerTypeDescriptor, YamlAttributeOverrides overrides)
		{
			this.innerTypeDescriptor = innerTypeDescriptor;
			this.overrides = overrides;
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			Type type2 = type;
			IEnumerable<IPropertyDescriptor> enumerable = innerTypeDescriptor.GetProperties(type2, container);
			if (overrides != null)
			{
				enumerable = enumerable.Select((Func<IPropertyDescriptor, IPropertyDescriptor>)((IPropertyDescriptor p) => new OverridePropertyDescriptor(p, overrides, type2)));
			}
			return enumerable;
		}
	}
	internal sealed class YamlAttributesTypeInspector : TypeInspectorSkeleton
	{
		private readonly ITypeInspector innerTypeDescriptor;

		public YamlAttributesTypeInspector(ITypeInspector innerTypeDescriptor)
		{
			this.innerTypeDescriptor = innerTypeDescriptor;
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			return from p in (from p in innerTypeDescriptor.GetProperties(type, container)
					where p.GetCustomAttribute<YamlIgnoreAttribute>() == null
					select p).Select((Func<IPropertyDescriptor, IPropertyDescriptor>)delegate(IPropertyDescriptor p)
				{
					PropertyDescriptor propertyDescriptor = new PropertyDescriptor(p);
					YamlMemberAttribute customAttribute = p.GetCustomAttribute<YamlMemberAttribute>();
					if (customAttribute != null)
					{
						if (customAttribute.SerializeAs != null)
						{
							propertyDescriptor.TypeOverride = customAttribute.SerializeAs;
						}
						propertyDescriptor.Order = customAttribute.Order;
						propertyDescriptor.ScalarStyle = customAttribute.ScalarStyle;
						if (customAttribute.Alias != null)
						{
							propertyDescriptor.Name = customAttribute.Alias;
						}
					}
					return propertyDescriptor;
				})
				orderby p.Order
				select p;
		}
	}
	internal class YamlFormatter
	{
		public static YamlFormatter Default { get; } = new YamlFormatter();


		public NumberFormatInfo NumberFormat { get; set; } = new NumberFormatInfo
		{
			CurrencyDecimalSeparator = ".",
			CurrencyGroupSeparator = "_",
			CurrencyGroupSizes = new int[1] { 3 },
			CurrencySymbol = string.Empty,
			CurrencyDecimalDigits = 99,
			NumberDecimalSeparator = ".",
			NumberGroupSeparator = "_",
			NumberGroupSizes = new int[1] { 3 },
			NumberDecimalDigits = 99,
			NaNSymbol = ".nan",
			PositiveInfinitySymbol = ".inf",
			NegativeInfinitySymbol = "-.inf"
		};


		public virtual Func<object, INamingConvention, string> FormatEnum { get; set; } = delegate(object value, INamingConvention enumNamingConvention)
		{
			string empty = string.Empty;
			empty = ((value != null) ? value.ToString() : string.Empty);
			return enumNamingConvention.Apply(empty);
		};


		public virtual Func<object, bool> PotentiallyQuoteEnums { get; set; } = (object _) => true;


		public string FormatNumber(object number)
		{
			return Convert.ToString(number, NumberFormat);
		}

		public string FormatNumber(double number)
		{
			return number.ToString("G", NumberFormat);
		}

		public string FormatNumber(float number)
		{
			return number.ToString("G", NumberFormat);
		}

		public string FormatBoolean(object boolean)
		{
			if (!boolean.Equals(true))
			{
				return "false";
			}
			return "true";
		}

		public string FormatDateTime(object dateTime)
		{
			return ((DateTime)dateTime).ToString("o", CultureInfo.InvariantCulture);
		}

		public string FormatTimeSpan(object timeSpan)
		{
			return ((TimeSpan)timeSpan).ToString();
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	internal sealed class YamlIgnoreAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	internal sealed class YamlMemberAttribute : Attribute
	{
		private DefaultValuesHandling? defaultValuesHandling;

		public string? Description { get; set; }

		public Type? SerializeAs { get; set; }

		public int Order { get; set; }

		public string? Alias { get; set; }

		public bool ApplyNamingConventions { get; set; }

		public ScalarStyle ScalarStyle { get; set; }

		public DefaultValuesHandling DefaultValuesHandling
		{
			get
			{
				return defaultValuesHandling.GetValueOrDefault();
			}
			set
			{
				defaultValuesHandling = value;
			}
		}

		public bool IsDefaultValuesHandlingSpecified => defaultValuesHandling.HasValue;

		public YamlMemberAttribute()
		{
			ScalarStyle = ScalarStyle.Any;
			ApplyNamingConventions = true;
		}

		public YamlMemberAttribute(Type serializeAs)
			: this()
		{
			SerializeAs = serializeAs ?? throw new ArgumentNullException("serializeAs");
		}
	}
	[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
	internal sealed class YamlSerializableAttribute : Attribute
	{
		public YamlSerializableAttribute()
		{
		}

		public YamlSerializableAttribute(Type serializableType)
		{
		}
	}
	internal sealed class YamlStaticContextAttribute : Attribute
	{
	}
}
namespace YamlDotNet.Serialization.ValueDeserializers
{
	internal sealed class AliasValueDeserializer : IValueDeserializer
	{
		private sealed class AliasState : Dictionary<AnchorName, ValuePromise>, IPostDeserializationCallback
		{
			public void OnDeserialization()
			{
				foreach (ValuePromise value in base.Values)
				{
					if (!value.HasValue)
					{
						YamlDotNet.Core.Events.AnchorAlias alias = value.Alias;
						Mark start = alias.Start;
						Mark end = alias.End;
						throw new AnchorNotFoundException(in start, in end, $"Anchor '{alias.Value}' not found");
					}
				}
			}
		}

		private sealed class ValuePromise : IValuePromise
		{
			private object? value;

			public readonly YamlDotNet.Core.Events.AnchorAlias? Alias;

			public bool HasValue { get; private set; }

			public object? Value
			{
				get
				{
					if (!HasValue)
					{
						throw new InvalidOperationException("Value not set");
					}
					return value;
				}
				set
				{
					if (HasValue)
					{
						throw new InvalidOperationException("Value already set");
					}
					HasValue = true;
					this.value = value;
					this.ValueAvailable?.Invoke(value);
				}
			}

			public event Action<object?>? ValueAvailable;

			public ValuePromise(YamlDotNet.Core.Events.AnchorAlias alias)
			{
				Alias = alias;
			}

			public ValuePromise(object? value)
			{
				HasValue = true;
				this.value = value;
			}
		}

		private readonly IValueDeserializer innerDeserializer;

		public AliasValueDeserializer(IValueDeserializer innerDeserializer)
		{
			this.innerDeserializer = innerDeserializer ?? throw new ArgumentNullException("innerDeserializer");
		}

		public object? DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer)
		{
			if (parser.TryConsume<YamlDotNet.Core.Events.AnchorAlias>(out var @event))
			{
				if (!state.Get<AliasState>().TryGetValue(@event.Value, out ValuePromise value))
				{
					Mark start = @event.Start;
					Mark end = @event.End;
					throw new AnchorNotFoundException(in start, in end, $"Alias ${@event.Value} cannot precede anchor declaration");
				}
				if (!value.HasValue)
				{
					return value;
				}
				return value.Value;
			}
			AnchorName anchorName = AnchorName.Empty;
			if (parser.Accept<NodeEvent>(out var event2) && !event2.Anchor.IsEmpty)
			{
				anchorName = event2.Anchor;
				AliasState aliasState = state.Get<AliasState>();
				if (!aliasState.ContainsKey(anchorName))
				{
					aliasState[anchorName] = new ValuePromise(new YamlDotNet.Core.Events.AnchorAlias(anchorName));
				}
			}
			object obj = innerDeserializer.DeserializeValue(parser, expectedType, state, nestedObjectDeserializer);
			if (!anchorName.IsEmpty)
			{
				AliasState aliasState2 = state.Get<AliasState>();
				if (!aliasState2.TryGetValue(anchorName, out ValuePromise value2))
				{
					aliasState2.Add(anchorName, new ValuePromise(obj));
				}
				else if (!value2.HasValue)
				{
					value2.Value = obj;
				}
				else
				{
					aliasState2[anchorName] = new ValuePromise(obj);
				}
			}
			return obj;
		}
	}
	internal sealed class NodeValueDeserializer : IValueDeserializer
	{
		private readonly IList<INodeDeserializer> deserializers;

		private readonly IList<INodeTypeResolver> typeResolvers;

		private readonly ITypeConverter typeConverter;

		private readonly INamingConvention enumNamingConvention;

		public NodeValueDeserializer(IList<INodeDeserializer> deserializers, IList<INodeTypeResolver> typeResolvers, ITypeConverter typeConverter, INamingConvention enumNamingConvention)
		{
			this.deserializers = deserializers ?? throw new ArgumentNullException("deserializers");
			this.typeResolvers = typeResolvers ?? throw new ArgumentNullException("typeResolvers");
			this.typeConverter = typeConverter ?? throw new ArgumentNullException("typeConverter");
			this.enumNamingConvention = enumNamingConvention ?? throw new ArgumentNullException("enumNamingConvention");
		}

		public object? DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer)
		{
			IValueDeserializer nestedObjectDeserializer2 = nestedObjectDeserializer;
			SerializerState state2 = state;
			parser.Accept<NodeEvent>(out var @event);
			Type typeFromEvent = GetTypeFromEvent(@event, expectedType);
			Mark start;
			Mark end;
			try
			{
				foreach (INodeDeserializer deserializer in deserializers)
				{
					if (deserializer.Deserialize(parser, typeFromEvent, (IParser r, Type t) => nestedObjectDeserializer2.DeserializeValue(r, t, state2, nestedObjectDeserializer2), out object value))
					{
						return typeConverter.ChangeType(value, expectedType, enumNamingConvention);
					}
				}
			}
			catch (YamlException)
			{
				throw;
			}
			catch (Exception innerException)
			{
				start = @event?.Start ?? Mark.Empty;
				end = @event?.End ?? Mark.Empty;
				throw new YamlException(in start, in end, "Exception during deserialization", innerException);
			}
			start = @event?.Start ?? Mark.Empty;
			end = @event?.End ?? Mark.Empty;
			throw new YamlException(in start, in end, "No node deserializer was able to deserialize the node into type " + expectedType.AssemblyQualifiedName);
		}

		private Type GetTypeFromEvent(NodeEvent? nodeEvent, Type currentType)
		{
			using (IEnumerator<INodeTypeResolver> enumerator = typeResolvers.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Resolve(nodeEvent, ref currentType))
				{
				}
			}
			return currentType;
		}
	}
}
namespace YamlDotNet.Serialization.Utilities
{
	internal interface IPostDeserializationCallback
	{
		void OnDeserialization();
	}
	internal interface ITypeConverter
	{
		object? ChangeType(object? value, Type expectedType, INamingConvention enumNamingConvention);
	}
	internal class NullTypeConverter : ITypeConverter
	{
		public object? ChangeType(object? value, Type expectedType, INamingConvention enumNamingConvention)
		{
			return value;
		}
	}
	internal sealed class ObjectAnchorCollection
	{
		private readonly IDictionary<string, object> objectsByAnchor = new Dictionary<string, object>();

		private readonly IDictionary<object, string> anchorsByObject = new Dictionary<object, string>();

		public object this[string anchor]
		{
			get
			{
				if (objectsByAnchor.TryGetValue(anchor, out object value))
				{
					return value;
				}
				throw new AnchorNotFoundException("The anchor '" + anchor + "' does not exists");
			}
		}

		public void Add(string anchor, object @object)
		{
			objectsByAnchor.Add(anchor, @object);
			if (@object != null)
			{
				anchorsByObject.Add(@object, anchor);
			}
		}

		public bool TryGetAnchor(object @object, [MaybeNullWhen(false)] out string? anchor)
		{
			return anchorsByObject.TryGetValue(@object, out anchor);
		}
	}
	internal class ReflectionTypeConverter : ITypeConverter
	{
		public object? ChangeType(object? value, Type expectedType)
		{
			return ChangeType(value, expectedType, NullNamingConvention.Instance);
		}

		public object? ChangeType(object? value, Type expectedType, INamingConvention enumNamingConvention)
		{
			return TypeConverter.ChangeType(value, expectedType, enumNamingConvention);
		}
	}
	internal static class ReflectionUtility
	{
		public static Type? GetImplementedGenericInterface(Type type, Type genericInterfaceType)
		{
			foreach (Type implementedInterface in GetImplementedInterfaces(type))
			{
				if (implementedInterface.IsGenericType() && implementedInterface.GetGenericTypeDefinition() == genericInterfaceType)
				{
					return implementedInterface;
				}
			}
			return null;
		}

		public static IEnumerable<Type> GetImplementedInterfaces(Type type)
		{
			if (type.IsInterface())
			{
				yield return type;
			}
			Type[] interfaces = type.GetInterfaces();
			for (int i = 0; i < interfaces.Length; i++)
			{
				yield return interfaces[i];
			}
		}
	}
	internal sealed class SerializerState : IDisposable
	{
		private readonly IDictionary<Type, object> items = new Dictionary<Type, object>();

		public T Get<T>() where T : class, new()
		{
			if (!items.TryGetValue(typeof(T), out object value))
			{
				value = new T();
				items.Add(typeof(T), value);
			}
			return (T)value;
		}

		public void OnDeserialization()
		{
			foreach (IPostDeserializationCallback item in items.Values.OfType<IPostDeserializationCallback>())
			{
				item.OnDeserialization();
			}
		}

		public void Dispose()
		{
			foreach (IDisposable item in items.Values.OfType<IDisposable>())
			{
				item.Dispose();
			}
		}
	}
	internal static class StringExtensions
	{
		private static string ToCamelOrPascalCase(string str, Func<char, char> firstLetterTransform)
		{
			string text = Regex.Replace(str, "([_\\-])(?<char>[a-z])", (Match match) => match.Groups["char"].Value.ToUpperInvariant(), RegexOptions.IgnoreCase);
			return firstLetterTransform(text[0]) + text.Substring(1);
		}

		public static string ToCamelCase(this string str)
		{
			return ToCamelOrPascalCase(str, char.ToLowerInvariant);
		}

		public static string ToPascalCase(this string str)
		{
			return ToCamelOrPascalCase(str, char.ToUpperInvariant);
		}

		public static string FromCamelCase(this string str, string separator)
		{
			string separator2 = separator;
			str = char.ToLower(str[0]) + str.Substring(1);
			str = Regex.Replace(str.ToCamelCase(), "(?<char>[A-Z])", (Match match) => separator2 + match.Groups["char"].Value.ToLowerInvariant());
			return str;
		}
	}
	internal static class TypeConverter
	{
		public static T ChangeType<T>(object? value, INamingConvention enumNamingConvention)
		{
			return (T)ChangeType(value, typeof(T), enumNamingConvention);
		}

		public static T ChangeType<T>(object? value, IFormatProvider provider, INamingConvention enumNamingConvention)
		{
			return (T)ChangeType(value, typeof(T), provider, enumNamingConvention);
		}

		public static T ChangeType<T>(object? value, CultureInfo culture, INamingConvention enumNamingConvention)
		{
			return (T)ChangeType(value, typeof(T), culture, enumNamingConvention);
		}

		public static object? ChangeType(object? value, Type destinationType, INamingConvention enumNamingConvention)
		{
			return ChangeType(value, destinationType, CultureInfo.InvariantCulture, enumNamingConvention);
		}

		public static object? ChangeType(object? value, Type destinationType, IFormatProvider provider, INamingConvention enumNamingConvention)
		{
			return ChangeType(value, destinationType, new CultureInfoAdapter(CultureInfo.CurrentCulture, provider), enumNamingConvention);
		}

		public static object? ChangeType(object? value, Type destinationType, CultureInfo culture, INamingConvention enumNamingConvention)
		{
			if (value == null || value.IsDbNull())
			{
				if (!destinationType.IsValueType())
				{
					return null;
				}
				return Activator.CreateInstance(destinationType);
			}
			Type type = value.GetType();
			if (destinationType == type || destinationType.IsAssignableFrom(type))
			{
				return value;
			}
			if (destinationType.IsGenericType() && destinationType.GetGenericTypeDefinition() == typeof(Nullable<>))
			{
				Type destinationType2 = destinationType.GetGenericArguments()[0];
				object obj = ChangeType(value, destinationType2, culture, enumNamingConvention);
				return Activator.CreateInstance(destinationType, obj);
			}
			if (destinationType.IsEnum())
			{
				object result = value;
				if (value is string value2)
				{
					string value3 = enumNamingConvention.Reverse(value2);
					result = Enum.Parse(destinationType, value3, ignoreCase: true);
				}
				return result;
			}
			if (destinationType == typeof(bool))
			{
				if ("0".Equals(value))
				{
					return false;
				}
				if ("1".Equals(value))
				{
					return true;
				}
			}
			System.ComponentModel.TypeConverter converter = TypeDescriptor.GetConverter(type);
			if (converter != null && converter.CanConvertTo(destinationType))
			{
				return converter.ConvertTo(null, culture, value, destinationType);
			}
			System.ComponentModel.TypeConverter converter2 = TypeDescriptor.GetConverter(destinationType);
			if (converter2 != null && converter2.CanConvertFrom(type))
			{
				return converter2.ConvertFrom(null, culture, value);
			}
			Type[] array = new Type[2] { type, destinationType };
			for (int i = 0; i < array.Length; i++)
			{
				foreach (MethodInfo publicStaticMethod2 in array[i].GetPublicStaticMethods())
				{
					if (!publicStaticMethod2.IsSpecialName || (!(publicStaticMethod2.Name == "op_Implicit") && !(publicStaticMethod2.Name == "op_Explicit")) || !destinationType.IsAssignableFrom(publicStaticMethod2.ReturnParameter.ParameterType))
					{
						continue;
					}
					ParameterInfo[] parameters = publicStaticMethod2.GetParameters();
					if (parameters.Length == 1 && parameters[0].ParameterType.IsAssignableFrom(type))
					{
						try
						{
							return publicStaticMethod2.Invoke(null, new object[1] { value });
						}
						catch (TargetInvocationException ex)
						{
							throw ex.InnerException;
						}
					}
				}
			}
			if (type == typeof(string))
			{
				try
				{
					MethodInfo publicStaticMethod = destinationType.GetPublicStaticMethod("Parse", typeof(string), typeof(IFormatProvider));
					if (publicStaticMethod != null)
					{
						return publicStaticMethod.Invoke(null, new object[2] { value, culture });
					}
					publicStaticMethod = destinationType.GetPublicStaticMethod("Parse", typeof(string));
					if (publicStaticMethod != null)
					{
						return publicStaticMethod.Invoke(null, new object[1] { value });
					}
				}
				catch (TargetInvocationException ex2)
				{
					throw ex2.InnerException;
				}
			}
			if (destinationType == typeof(TimeSpan))
			{
				return TimeSpan.Parse((string)ChangeType(value, typeof(string), CultureInfo.InvariantCulture, enumNamingConvention));
			}
			return Convert.ChangeType(value, destinationType, CultureInfo.InvariantCulture);
		}

		public static void RegisterTypeConverter<TConvertible, TConverter>() where TConverter : System.ComponentModel.TypeConverter
		{
			if (!TypeDescriptor.GetAttributes(typeof(TConvertible)).OfType<TypeConverterAttribute>().Any((TypeConverterAttribute a) => a.ConverterTypeName == typeof(TConverter).AssemblyQualifiedName))
			{
				TypeDescriptor.AddAttributes(typeof(TConvertible), new TypeConverterAttribute(typeof(TConverter)));
			}
		}
	}
}
namespace YamlDotNet.Serialization.TypeResolvers
{
	internal sealed class DynamicTypeResolver : ITypeResolver
	{
		public Type Resolve(Type staticType, object? actualValue)
		{
			if (actualValue == null)
			{
				return staticType;
			}
			return actualValue.GetType();
		}
	}
	internal class StaticTypeResolver : ITypeResolver
	{
		public virtual Type Resolve(Type staticType, object? actualValue)
		{
			if (actualValue != null)
			{
				if (actualValue.GetType().IsEnum)
				{
					return staticType;
				}
				switch (actualValue.GetType().GetTypeCode())
				{
				case TypeCode.Boolean:
					return typeof(bool);
				case TypeCode.Char:
					return typeof(char);
				case TypeCode.SByte:
					return typeof(sbyte);
				case TypeCode.Byte:
					return typeof(byte);
				case TypeCode.Int16:
					return typeof(short);
				case TypeCode.UInt16:
					return typeof(ushort);
				case TypeCode.Int32:
					return typeof(int);
				case TypeCode.UInt32:
					return typeof(uint);
				case TypeCode.Int64:
					return typeof(long);
				case TypeCode.UInt64:
					return typeof(ulong);
				case TypeCode.Single:
					return typeof(float);
				case TypeCode.Double:
					return typeof(double);
				case TypeCode.Decimal:
					return typeof(decimal);
				case TypeCode.String:
					return typeof(string);
				case TypeCode.DateTime:
					return typeof(DateTime);
				}
			}
			return staticType;
		}
	}
}
namespace YamlDotNet.Serialization.TypeInspectors
{
	internal sealed class CachedTypeInspector : TypeInspectorSkeleton
	{
		private readonly ITypeInspector innerTypeDescriptor;

		private readonly ConcurrentDictionary<Type, List<IPropertyDescriptor>> cache = new ConcurrentDictionary<Type, List<IPropertyDescriptor>>();

		public CachedTypeInspector(ITypeInspector innerTypeDescriptor)
		{
			this.innerTypeDescriptor = innerTypeDescriptor ?? throw new ArgumentNullException("innerTypeDescriptor");
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			object container2 = container;
			return cache.GetOrAdd(type, (Type t) => innerTypeDescriptor.GetProperties(t, container2).ToList());
		}
	}
	internal sealed class CompositeTypeInspector : TypeInspectorSkeleton
	{
		private readonly IEnumerable<ITypeInspector> typeInspectors;

		public CompositeTypeInspector(params ITypeInspector[] typeInspectors)
			: this((IEnumerable<ITypeInspector>)typeInspectors)
		{
		}

		public CompositeTypeInspector(IEnumerable<ITypeInspector> typeInspectors)
		{
			this.typeInspectors = typeInspectors?.ToList() ?? throw new ArgumentNullException("typeInspectors");
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			Type type2 = type;
			object container2 = container;
			return typeInspectors.SelectMany((ITypeInspector i) => i.GetProperties(type2, container2));
		}
	}
	internal sealed class NamingConventionTypeInspector : TypeInspectorSkeleton
	{
		private readonly ITypeInspector innerTypeDescriptor;

		private readonly INamingConvention namingConvention;

		public NamingConventionTypeInspector(ITypeInspector innerTypeDescriptor, INamingConvention namingConvention)
		{
			this.innerTypeDescriptor = innerTypeDescriptor ?? throw new ArgumentNullException("innerTypeDescriptor");
			this.namingConvention = namingConvention ?? throw new ArgumentNullException("namingConvention");
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			return innerTypeDescriptor.GetProperties(type, container).Select(delegate(IPropertyDescriptor p)
			{
				YamlMemberAttribute customAttribute = p.GetCustomAttribute<YamlMemberAttribute>();
				return (customAttribute != null && !customAttribute.ApplyNamingConventions) ? p : new PropertyDescriptor(p)
				{
					Name = namingConvention.Apply(p.Name)
				};
			});
		}
	}
	internal sealed class ReadableAndWritablePropertiesTypeInspector : TypeInspectorSkeleton
	{
		private readonly ITypeInspector innerTypeDescriptor;

		public ReadableAndWritablePropertiesTypeInspector(ITypeInspector innerTypeDescriptor)
		{
			this.innerTypeDescriptor = innerTypeDescriptor ?? throw new ArgumentNullException("innerTypeDescriptor");
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			return from p in innerTypeDescriptor.GetProperties(type, container)
				where p.CanWrite
				select p;
		}
	}
	internal sealed class ReadableFieldsTypeInspector : TypeInspectorSkeleton
	{
		private sealed class ReflectionFieldDescriptor : IPropertyDescriptor
		{
			private readonly FieldInfo fieldInfo;

			private readonly ITypeResolver typeResolver;

			public string Name => fieldInfo.Name;

			public Type Type => fieldInfo.FieldType;

			public Type? TypeOverride { get; set; }

			public int Order { get; set; }

			public bool CanWrite => !fieldInfo.IsInitOnly;

			public ScalarStyle ScalarStyle { get; set; }

			public ReflectionFieldDescriptor(FieldInfo fieldInfo, ITypeResolver typeResolver)
			{
				this.fieldInfo = fieldInfo;
				this.typeResolver = typeResolver;
				ScalarStyle = ScalarStyle.Any;
			}

			public void Write(object target, object? value)
			{
				fieldInfo.SetValue(target, value);
			}

			public T? GetCustomAttribute<T>() where T : Attribute
			{
				return (T)fieldInfo.GetCustomAttributes(typeof(T), inherit: true).FirstOrDefault();
			}

			public IObjectDescriptor Read(object target)
			{
				object value = fieldInfo.GetValue(target);
				Type type = TypeOverride ?? typeResolver.Resolve(Type, value);
				return new ObjectDescriptor(value, type, Type, ScalarStyle);
			}
		}

		private readonly ITypeResolver typeResolver;

		public ReadableFieldsTypeInspector(ITypeResolver typeResolver)
		{
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			return type.GetPublicFields().Select((Func<FieldInfo, IPropertyDescriptor>)((FieldInfo p) => new ReflectionFieldDescriptor(p, typeResolver)));
		}
	}
	internal sealed class ReadablePropertiesTypeInspector : TypeInspectorSkeleton
	{
		private sealed class ReflectionPropertyDescriptor : IPropertyDescriptor
		{
			private readonly PropertyInfo propertyInfo;

			private readonly ITypeResolver typeResolver;

			public string Name => propertyInfo.Name;

			public Type Type => propertyInfo.PropertyType;

			public Type? TypeOverride { get; set; }

			public int Order { get; set; }

			public bool CanWrite => propertyInfo.CanWrite;

			public ScalarStyle ScalarStyle { get; set; }

			public ReflectionPropertyDescriptor(PropertyInfo propertyInfo, ITypeResolver typeResolver)
			{
				this.propertyInfo = propertyInfo ?? throw new ArgumentNullException("propertyInfo");
				this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
				ScalarStyle = ScalarStyle.Any;
			}

			public void Write(object target, object? value)
			{
				propertyInfo.SetValue(target, value, null);
			}

			public T? GetCustomAttribute<T>() where T : Attribute
			{
				return (T)propertyInfo.GetAllCustomAttributes<T>().FirstOrDefault();
			}

			public IObjectDescriptor Read(object target)
			{
				object obj = propertyInfo.ReadValue(target);
				Type type = TypeOverride ?? typeResolver.Resolve(Type, obj);
				return new ObjectDescriptor(obj, type, Type, ScalarStyle);
			}
		}

		private readonly ITypeResolver typeResolver;

		private readonly bool includeNonPublicProperties;

		public ReadablePropertiesTypeInspector(ITypeResolver typeResolver)
			: this(typeResolver, includeNonPublicProperties: false)
		{
		}

		public ReadablePropertiesTypeInspector(ITypeResolver typeResolver, bool includeNonPublicProperties)
		{
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			this.includeNonPublicProperties = includeNonPublicProperties;
		}

		private static bool IsValidProperty(PropertyInfo property)
		{
			if (property.CanRead)
			{
				return property.GetGetMethod(nonPublic: true).GetParameters().Length == 0;
			}
			return false;
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			return type.GetProperties(includeNonPublicProperties).Where(IsValidProperty).Select((Func<PropertyInfo, IPropertyDescriptor>)((PropertyInfo p) => new ReflectionPropertyDescriptor(p, typeResolver)));
		}
	}
	internal abstract class TypeInspectorSkeleton : ITypeInspector
	{
		public abstract IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container);

		public IPropertyDescriptor GetProperty(Type type, object? container, string name, [MaybeNullWhen(true)] bool ignoreUnmatched)
		{
			string name2 = name;
			IEnumerable<IPropertyDescriptor> enumerable = from p in GetProperties(type, container)
				where p.Name == name2
				select p;
			using IEnumerator<IPropertyDescriptor> enumerator = enumerable.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				if (ignoreUnmatched)
				{
					return null;
				}
				throw new SerializationException("Property '" + name2 + "' not found on type '" + type.FullName + "'.");
			}
			IPropertyDescriptor current = enumerator.Current;
			if (enumerator.MoveNext())
			{
				throw new SerializationException("Multiple properties with the name/alias '" + name2 + "' already exists on type '" + type.FullName + "', maybe you're misusing YamlAlias or maybe you are using the wrong naming convention? The matching properties are: " + string.Join(", ", enumerable.Select((IPropertyDescriptor p) => p.Name).ToArray()));
			}
			return current;
		}
	}
	internal sealed class WritablePropertiesTypeInspector : TypeInspectorSkeleton
	{
		private sealed class ReflectionPropertyDescriptor : IPropertyDescriptor
		{
			private readonly PropertyInfo propertyInfo;

			private readonly ITypeResolver typeResolver;

			public string Name => propertyInfo.Name;

			public Type Type => propertyInfo.PropertyType;

			public Type? TypeOverride { get; set; }

			public int Order { get; set; }

			public bool CanWrite => propertyInfo.CanWrite;

			public ScalarStyle ScalarStyle { get; set; }

			public ReflectionPropertyDescriptor(PropertyInfo propertyInfo, ITypeResolver typeResolver)
			{
				this.propertyInfo = propertyInfo ?? throw new ArgumentNullException("propertyInfo");
				this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
				ScalarStyle = ScalarStyle.Any;
			}

			public void Write(object target, object? value)
			{
				propertyInfo.SetValue(target, value, null);
			}

			public T? GetCustomAttribute<T>() where T : Attribute
			{
				return (T)propertyInfo.GetAllCustomAttributes<T>().FirstOrDefault();
			}

			public IObjectDescriptor Read(object target)
			{
				object obj = propertyInfo.ReadValue(target);
				Type type = TypeOverride ?? typeResolver.Resolve(Type, obj);
				return new ObjectDescriptor(obj, type, Type, ScalarStyle);
			}
		}

		private readonly ITypeResolver typeResolver;

		private readonly bool includeNonPublicProperties;

		public WritablePropertiesTypeInspector(ITypeResolver typeResolver)
			: this(typeResolver, includeNonPublicProperties: false)
		{
		}

		public WritablePropertiesTypeInspector(ITypeResolver typeResolver, bool includeNonPublicProperties)
		{
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			this.includeNonPublicProperties = includeNonPublicProperties;
		}

		private static bool IsValidProperty(PropertyInfo property)
		{
			if (property.CanWrite)
			{
				return property.GetSetMethod(nonPublic: true).GetParameters().Length == 1;
			}
			return false;
		}

		public override IEnumerable<IPropertyDescriptor> GetProperties(Type type, object? container)
		{
			return type.GetProperties(includeNonPublicProperties).Where(IsValidProperty).Select((Func<PropertyInfo, IPropertyDescriptor>)((PropertyInfo p) => new ReflectionPropertyDescriptor(p, typeResolver)))
				.ToArray();
		}
	}
}
namespace YamlDotNet.Serialization.Schemas
{
	internal sealed class FailsafeSchema
	{
		public static class Tags
		{
			public static readonly TagName Map = new TagName("tag:yaml.org,2002:map");

			public static readonly TagName Seq = new TagName("tag:yaml.org,2002:seq");

			public static readonly TagName Str = new TagName("tag:yaml.org,2002:str");
		}
	}
	internal sealed class JsonSchema
	{
		public static class Tags
		{
			public static readonly TagName Null = new TagName("tag:yaml.org,2002:null");

			public static readonly TagName Bool = new TagName("tag:yaml.org,2002:bool");

			public static readonly TagName Int = new TagName("tag:yaml.org,2002:int");

			public static readonly TagName Float = new TagName("tag:yaml.org,2002:float");
		}
	}
	internal sealed class CoreSchema
	{
		public static class Tags
		{
		}
	}
	internal sealed class DefaultSchema
	{
		public static class Tags
		{
			public static readonly TagName Timestamp = new TagName("tag:yaml.org,2002:timestamp");
		}
	}
}
namespace YamlDotNet.Serialization.ObjectGraphVisitors
{
	internal sealed class AnchorAssigner : PreProcessingPhaseObjectGraphVisitorSkeleton, IAliasProvider
	{
		private class AnchorAssignment
		{
			public AnchorName Anchor;
		}

		private readonly IDictionary<object, AnchorAssignment> assignments = new Dictionary<object, AnchorAssignment>();

		private uint nextId;

		public AnchorAssigner(IEnumerable<IYamlTypeConverter> typeConverters)
			: base(typeConverters)
		{
		}

		protected override bool Enter(IObjectDescriptor value)
		{
			if (value.Value != null && assignments.TryGetValue(value.Value, out AnchorAssignment value2))
			{
				if (value2.Anchor.IsEmpty)
				{
					value2.Anchor = new AnchorName("o" + nextId.ToString(CultureInfo.InvariantCulture));
					nextId++;
				}
				return false;
			}
			return true;
		}

		protected override bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value)
		{
			return true;
		}

		protected override bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value)
		{
			return true;
		}

		protected override void VisitScalar(IObjectDescriptor scalar)
		{
		}

		protected override void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType)
		{
			VisitObject(mapping);
		}

		protected override void VisitMappingEnd(IObjectDescriptor mapping)
		{
		}

		protected override void VisitSequenceStart(IObjectDescriptor sequence, Type elementType)
		{
			VisitObject(sequence);
		}

		protected override void VisitSequenceEnd(IObjectDescriptor sequence)
		{
		}

		private void VisitObject(IObjectDescriptor value)
		{
			if (value.Value != null)
			{
				assignments.Add(value.Value, new AnchorAssignment());
			}
		}

		AnchorName IAliasProvider.GetAlias(object target)
		{
			if (target != null && assignments.TryGetValue(target, out AnchorAssignment value))
			{
				return value.Anchor;
			}
			return AnchorName.Empty;
		}
	}
	internal sealed class AnchorAssigningObjectGraphVisitor : ChainedObjectGraphVisitor
	{
		private readonly IEventEmitter eventEmitter;

		private readonly IAliasProvider aliasProvider;

		private readonly HashSet<AnchorName> emittedAliases = new HashSet<AnchorName>();

		public AnchorAssigningObjectGraphVisitor(IObjectGraphVisitor<IEmitter> nextVisitor, IEventEmitter eventEmitter, IAliasProvider aliasProvider)
			: base(nextVisitor)
		{
			this.eventEmitter = eventEmitter;
			this.aliasProvider = aliasProvider;
		}

		public override bool Enter(IObjectDescriptor value, IEmitter context)
		{
			if (value.Value != null)
			{
				AnchorName alias = aliasProvider.GetAlias(value.Value);
				if (!alias.IsEmpty && !emittedAliases.Add(alias))
				{
					AliasEventInfo aliasEventInfo = new AliasEventInfo(value, alias);
					eventEmitter.Emit(aliasEventInfo, context);
					return aliasEventInfo.NeedsExpansion;
				}
			}
			return base.Enter(value, context);
		}

		public override void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context)
		{
			AnchorName alias = aliasProvider.GetAlias(mapping.NonNullValue());
			eventEmitter.Emit(new MappingStartEventInfo(mapping)
			{
				Anchor = alias
			}, context);
		}

		public override void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context)
		{
			AnchorName alias = aliasProvider.GetAlias(sequence.NonNullValue());
			eventEmitter.Emit(new SequenceStartEventInfo(sequence)
			{
				Anchor = alias
			}, context);
		}

		public override void VisitScalar(IObjectDescriptor scalar, IEmitter context)
		{
			ScalarEventInfo scalarEventInfo = new ScalarEventInfo(scalar);
			if (scalar.Value != null)
			{
				scalarEventInfo.Anchor = aliasProvider.GetAlias(scalar.Value);
			}
			eventEmitter.Emit(scalarEventInfo, context);
		}
	}
	internal abstract class ChainedObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
	{
		private readonly IObjectGraphVisitor<IEmitter> nextVisitor;

		protected ChainedObjectGraphVisitor(IObjectGraphVisitor<IEmitter> nextVisitor)
		{
			this.nextVisitor = nextVisitor;
		}

		public virtual bool Enter(IObjectDescriptor value, IEmitter context)
		{
			return nextVisitor.Enter(value, context);
		}

		public virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			return nextVisitor.EnterMapping(key, value, context);
		}

		public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			return nextVisitor.EnterMapping(key, value, context);
		}

		public virtual void VisitScalar(IObjectDescriptor scalar, IEmitter context)
		{
			nextVisitor.VisitScalar(scalar, context);
		}

		public virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context)
		{
			nextVisitor.VisitMappingStart(mapping, keyType, valueType, context);
		}

		public virtual void VisitMappingEnd(IObjectDescriptor mapping, IEmitter context)
		{
			nextVisitor.VisitMappingEnd(mapping, context);
		}

		public virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context)
		{
			nextVisitor.VisitSequenceStart(sequence, elementType, context);
		}

		public virtual void VisitSequenceEnd(IObjectDescriptor sequence, IEmitter context)
		{
			nextVisitor.VisitSequenceEnd(sequence, context);
		}
	}
	internal sealed class CommentsObjectGraphVisitor : ChainedObjectGraphVisitor
	{
		public CommentsObjectGraphVisitor(IObjectGraphVisitor<IEmitter> nextVisitor)
			: base(nextVisitor)
		{
		}

		public override bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			YamlMemberAttribute customAttribute = key.GetCustomAttribute<YamlMemberAttribute>();
			if (customAttribute != null && customAttribute.Description != null)
			{
				context.Emit(new YamlDotNet.Core.Events.Comment(customAttribute.Description, isInline: false));
			}
			return base.EnterMapping(key, value, context);
		}
	}
	internal sealed class CustomSerializationObjectGraphVisitor : ChainedObjectGraphVisitor
	{
		private readonly IEnumerable<IYamlTypeConverter> typeConverters;

		private readonly ObjectSerializer nestedObjectSerializer;

		public CustomSerializationObjectGraphVisitor(IObjectGraphVisitor<IEmitter> nextVisitor, IEnumerable<IYamlTypeConverter> typeConverters, ObjectSerializer nestedObjectSerializer)
			: base(nextVisitor)
		{
			IEnumerable<IYamlTypeConverter> enumerable;
			if (typeConverters == null)
			{
				enumerable = Enumerable.Empty<IYamlTypeConverter>();
			}
			else
			{
				IEnumerable<IYamlTypeConverter> enumerable2 = typeConverters.ToList();
				enumerable = enumerable2;
			}
			this.typeConverters = enumerable;
			this.nestedObjectSerializer = nestedObjectSerializer;
		}

		public override bool Enter(IObjectDescriptor value, IEmitter context)
		{
			IObjectDescriptor value2 = value;
			IYamlTypeConverter yamlTypeConverter = typeConverters.FirstOrDefault((IYamlTypeConverter t) => t.Accepts(value2.Type));
			if (yamlTypeConverter != null)
			{
				yamlTypeConverter.WriteYaml(context, value2.Value, value2.Type);
				return false;
			}
			if (value2.Value is IYamlConvertible yamlConvertible)
			{
				yamlConvertible.Write(context, nestedObjectSerializer);
				return false;
			}
			if (value2.Value is IYamlSerializable yamlSerializable)
			{
				yamlSerializable.WriteYaml(context);
				return false;
			}
			return base.Enter(value2, context);
		}
	}
	internal sealed class DefaultExclusiveObjectGraphVisitor : ChainedObjectGraphVisitor
	{
		public DefaultExclusiveObjectGraphVisitor(IObjectGraphVisitor<IEmitter> nextVisitor)
			: base(nextVisitor)
		{
		}

		private static object? GetDefault(Type type)
		{
			if (!type.IsValueType())
			{
				return null;
			}
			return Activator.CreateInstance(type);
		}

		public override bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			if (!object.Equals(value.Value, GetDefault(value.Type)))
			{
				return base.EnterMapping(key, value, context);
			}
			return false;
		}

		public override bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			DefaultValueAttribute customAttribute = key.GetCustomAttribute<DefaultValueAttribute>();
			object objB = ((customAttribute != null) ? customAttribute.Value : GetDefault(key.Type));
			if (!object.Equals(value.Value, objB))
			{
				return base.EnterMapping(key, value, context);
			}
			return false;
		}
	}
	internal sealed class DefaultValuesObjectGraphVisitor : ChainedObjectGraphVisitor
	{
		private readonly DefaultValuesHandling handling;

		private readonly IObjectFactory factory;

		public DefaultValuesObjectGraphVisitor(DefaultValuesHandling handling, IObjectGraphVisitor<IEmitter> nextVisitor, IObjectFactory factory)
			: base(nextVisitor)
		{
			this.handling = handling;
			this.factory = factory;
		}

		private object? GetDefault(Type type)
		{
			return factory.CreatePrimitive(type);
		}

		public override bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			DefaultValuesHandling defaultValuesHandling = handling;
			YamlMemberAttribute customAttribute = key.GetCustomAttribute<YamlMemberAttribute>();
			if (customAttribute != null && customAttribute.IsDefaultValuesHandlingSpecified)
			{
				defaultValuesHandling = customAttribute.DefaultValuesHandling;
			}
			if ((defaultValuesHandling & DefaultValuesHandling.OmitNull) != 0 && value.Value == null)
			{
				return false;
			}
			if ((defaultValuesHandling & DefaultValuesHandling.OmitEmptyCollections) != 0 && value.Value is IEnumerable enumerable)
			{
				IEnumerator enumerator = enumerable.GetEnumerator();
				bool flag = enumerator.MoveNext();
				if (enumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
				if (!flag)
				{
					return false;
				}
			}
			if ((defaultValuesHandling & DefaultValuesHandling.OmitDefaults) != 0)
			{
				object objB = key.GetCustomAttribute<DefaultValueAttribute>()?.Value ?? GetDefault(key.Type);
				if (object.Equals(value.Value, objB))
				{
					return false;
				}
			}
			return base.EnterMapping(key, value, context);
		}
	}
	internal sealed class EmittingObjectGraphVisitor : IObjectGraphVisitor<IEmitter>
	{
		private readonly IEventEmitter eventEmitter;

		public EmittingObjectGraphVisitor(IEventEmitter eventEmitter)
		{
			this.eventEmitter = eventEmitter;
		}

		bool IObjectGraphVisitor<IEmitter>.Enter(IObjectDescriptor value, IEmitter context)
		{
			return true;
		}

		bool IObjectGraphVisitor<IEmitter>.EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			return true;
		}

		bool IObjectGraphVisitor<IEmitter>.EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context)
		{
			return true;
		}

		void IObjectGraphVisitor<IEmitter>.VisitScalar(IObjectDescriptor scalar, IEmitter context)
		{
			eventEmitter.Emit(new ScalarEventInfo(scalar), context);
		}

		void IObjectGraphVisitor<IEmitter>.VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context)
		{
			eventEmitter.Emit(new MappingStartEventInfo(mapping), context);
		}

		void IObjectGraphVisitor<IEmitter>.VisitMappingEnd(IObjectDescriptor mapping, IEmitter context)
		{
			eventEmitter.Emit(new MappingEndEventInfo(mapping), context);
		}

		void IObjectGraphVisitor<IEmitter>.VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context)
		{
			eventEmitter.Emit(new SequenceStartEventInfo(sequence), context);
		}

		void IObjectGraphVisitor<IEmitter>.VisitSequenceEnd(IObjectDescriptor sequence, IEmitter context)
		{
			eventEmitter.Emit(new SequenceEndEventInfo(sequence), context);
		}
	}
	internal abstract class PreProcessingPhaseObjectGraphVisitorSkeleton : IObjectGraphVisitor<Nothing>
	{
		protected readonly IEnumerable<IYamlTypeConverter> typeConverters;

		public PreProcessingPhaseObjectGraphVisitorSkeleton(IEnumerable<IYamlTypeConverter> typeConverters)
		{
			IEnumerable<IYamlTypeConverter> enumerable;
			if (typeConverters == null)
			{
				enumerable = Enumerable.Empty<IYamlTypeConverter>();
			}
			else
			{
				IEnumerable<IYamlTypeConverter> enumerable2 = typeConverters.ToList();
				enumerable = enumerable2;
			}
			this.typeConverters = enumerable;
		}

		bool IObjectGraphVisitor<Nothing>.Enter(IObjectDescriptor value, Nothing context)
		{
			IObjectDescriptor value2 = value;
			if (typeConverters.FirstOrDefault((IYamlTypeConverter t) => t.Accepts(value2.Type)) != null)
			{
				return false;
			}
			if (value2.Value is IYamlConvertible)
			{
				return false;
			}
			if (value2.Value is IYamlSerializable)
			{
				return false;
			}
			return Enter(value2);
		}

		bool IObjectGraphVisitor<Nothing>.EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, Nothing context)
		{
			return EnterMapping(key, value);
		}

		bool IObjectGraphVisitor<Nothing>.EnterMapping(IObjectDescriptor key, IObjectDescriptor value, Nothing context)
		{
			return EnterMapping(key, value);
		}

		void IObjectGraphVisitor<Nothing>.VisitMappingEnd(IObjectDescriptor mapping, Nothing context)
		{
			VisitMappingEnd(mapping);
		}

		void IObjectGraphVisitor<Nothing>.VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, Nothing context)
		{
			VisitMappingStart(mapping, keyType, valueType);
		}

		void IObjectGraphVisitor<Nothing>.VisitScalar(IObjectDescriptor scalar, Nothing context)
		{
			VisitScalar(scalar);
		}

		void IObjectGraphVisitor<Nothing>.VisitSequenceEnd(IObjectDescriptor sequence, Nothing context)
		{
			VisitSequenceEnd(sequence);
		}

		void IObjectGraphVisitor<Nothing>.VisitSequenceStart(IObjectDescriptor sequence, Type elementType, Nothing context)
		{
			VisitSequenceStart(sequence, elementType);
		}

		protected abstract bool Enter(IObjectDescriptor value);

		protected abstract bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value);

		protected abstract bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value);

		protected abstract void VisitMappingEnd(IObjectDescriptor mapping);

		protected abstract void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType);

		protected abstract void VisitScalar(IObjectDescriptor scalar);

		protected abstract void VisitSequenceEnd(IObjectDescriptor sequence);

		protected abstract void VisitSequenceStart(IObjectDescriptor sequence, Type elementType);
	}
}
namespace YamlDotNet.Serialization.ObjectGraphTraversalStrategies
{
	internal class FullObjectGraphTraversalStrategy : IObjectGraphTraversalStrategy
	{
		protected struct ObjectPathSegment
		{
			public readonly object Name;

			public readonly IObjectDescriptor Value;

			public ObjectPathSegment(object name, IObjectDescriptor value)
			{
				Name = name;
				Value = value;
			}
		}

		private readonly int maxRecursion;

		private readonly ITypeInspector typeDescriptor;

		private readonly ITypeResolver typeResolver;

		private readonly INamingConvention namingConvention;

		private readonly IObjectFactory objectFactory;

		public FullObjectGraphTraversalStrategy(ITypeInspector typeDescriptor, ITypeResolver typeResolver, int maxRecursion, INamingConvention namingConvention, IObjectFactory objectFactory)
		{
			if (maxRecursion <= 0)
			{
				throw new ArgumentOutOfRangeException("maxRecursion", maxRecursion, "maxRecursion must be greater than 1");
			}
			this.typeDescriptor = typeDescriptor ?? throw new ArgumentNullException("typeDescriptor");
			this.typeResolver = typeResolver ?? throw new ArgumentNullException("typeResolver");
			this.maxRecursion = maxRecursion;
			this.namingConvention = namingConvention ?? throw new ArgumentNullException("namingConvention");
			this.objectFactory = objectFactory ?? throw new ArgumentNullException("objectFactory");
		}

		void IObjectGraphTraversalStrategy.Traverse<TContext>(IObjectDescriptor graph, IObjectGraphVisitor<TContext> visitor, TContext context)
		{
			Traverse("<root>", graph, visitor, context, new Stack<ObjectPathSegment>(maxRecursion));
		}

		protected virtual void Traverse<TContext>(object name, IObjectDescriptor value, IObjectGraphVisitor<TContext> visitor, TContext context, Stack<ObjectPathSegment> path)
		{
			if (path.Count >= maxRecursion)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendLine("Too much recursion when traversing the object graph.");
				stringBuilder.AppendLine("The path to reach this recursion was:");
				Stack<KeyValuePair<string, string>> stack = new Stack<KeyValuePair<string, string>>(path.Count);
				int num = 0;
				foreach (ObjectPathSegment item in path)
				{
					string text = item.Name?.ToString() ?? string.Empty;
					num = Math.Max(num, text.Length);
					stack.Push(new KeyValuePair<string, string>(text, item.Value.Type.FullName));
				}
				foreach (KeyValuePair<string, string> item2 in stack)
				{
					stringBuilder.Append(" -> ").Append(item2.Key.PadRight(num)).Append("  [")
						.Append(item2.Value)
						.AppendLine("]");
				}
				throw new MaximumRecursionLevelReachedException(stringBuilder.ToString());
			}
			if (!visitor.Enter(value, context))
			{
				return;
			}
			path.Push(new ObjectPathSegment(name, value));
			try
			{
				TypeCode typeCode = value.Type.GetTypeCode();
				switch (typeCode)
				{
				case TypeCode.Boolean:
				case TypeCode.Char:
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
				case TypeCode.DateTime:
				case TypeCode.String:
					visitor.VisitScalar(value, context);
					return;
				case TypeCode.Empty:
					throw new NotSupportedException($"TypeCode.{typeCode} is not supported.");
				}
				if (value.IsDbNull())
				{
					visitor.VisitScalar(new ObjectDescriptor(null, typeof(object), typeof(object)), context);
				}
				if (value.Value == null || value.Type == typeof(TimeSpan))
				{
					visitor.VisitScalar(value, context);
					return;
				}
				Type underlyingType = Nullable.GetUnderlyingType(value.Type);
				if (underlyingType != null)
				{
					Traverse("Value", new ObjectDescriptor(value.Value, underlyingType, value.Type, value.ScalarStyle), visitor, context, path);
				}
				else
				{
					TraverseObject(value, visitor, context, path);
				}
			}
			finally
			{
				path.Pop();
			}
		}

		protected virtual void TraverseObject<TContext>(IObjectDescriptor value, IObjectGraphVisitor<TContext> visitor, TContext context, Stack<ObjectPathSegment> path)
		{
			IDictionary dictionary;
			Type[] genericArguments;
			if (typeof(IDictionary).IsAssignableFrom(value.Type))
			{
				TraverseDictionary(value, visitor, typeof(object), typeof(object), context, path);
			}
			else if (objectFactory.GetDictionary(value, out dictionary, out genericArguments))
			{
				TraverseDictionary(new ObjectDescriptor(dictionary, value.Type, value.StaticType, value.ScalarStyle), visitor, genericArguments[0], genericArguments[1], context, path);
			}
			else if (typeof(IEnumerable).IsAssignableFrom(value.Type))
			{
				TraverseList(value, visitor, context, path);
			}
			else
			{
				TraverseProperties(value, visitor, context, path);
			}
		}

		protected virtual void TraverseDictionary<TContext>(IObjectDescriptor dictionary, IObjectGraphVisitor<TContext> visitor, Type keyType, Type valueType, TContext context, Stack<ObjectPathSegment> path)
		{
			visitor.VisitMappingStart(dictionary, keyType, valueType, context);
			bool flag = dictionary.Type.FullName.Equals("System.Dynamic.ExpandoObject");
			foreach (DictionaryEntry? item in (IDictionary)dictionary.NonNullValue())
			{
				DictionaryEntry value = item.Value;
				object obj = (flag ? namingConvention.Apply(value.Key.ToString()) : value.Key);
				IObjectDescriptor objectDescriptor = GetObjectDescriptor(obj, keyType);
				IObjectDescriptor objectDescriptor2 = GetObjectDescriptor(value.Value, valueType);
				if (visitor.EnterMapping(objectDescriptor, objectDescriptor2, context))
				{
					Traverse(obj, objectDescriptor, visitor, context, path);
					Traverse(obj, objectDescriptor2, visitor, context, path);
				}
			}
			visitor.VisitMappingEnd(dictionary, context);
		}

		private void TraverseList<TContext>(IObjectDescriptor value, IObjectGraphVisitor<TContext> visitor, TContext context, Stack<ObjectPathSegment> path)
		{
			Type valueType = objectFactory.GetValueType(value.Type);
			visitor.VisitSequenceStart(value, valueType, context);
			int num = 0;
			foreach (object item in (IEnumerable)value.NonNullValue())
			{
				Traverse(num, GetObjectDescriptor(item, valueType), visitor, context, path);
				num++;
			}
			visitor.VisitSequenceEnd(value, context);
		}

		protected virtual void TraverseProperties<TContext>(IObjectDescriptor value, IObjectGraphVisitor<TContext> visitor, TContext context, Stack<ObjectPathSegment> path)
		{
			if (context.GetType() != typeof(Nothing))
			{
				objectFactory.ExecuteOnSerializing(value.Value);
			}
			visitor.VisitMappingStart(value, typeof(string), typeof(object), context);
			object obj = value.NonNullValue();
			foreach (IPropertyDescriptor property in typeDescriptor.GetProperties(value.Type, obj))
			{
				IObjectDescriptor value2 = property.Read(obj);
				if (visitor.EnterMapping(property, value2, context))
				{
					Traverse(property.Name, new ObjectDescriptor(property.Name, typeof(string), typeof(string), ScalarStyle.Plain), visitor, context, path);
					Traverse(property.Name, value2, visitor, context, path);
				}
			}
			visitor.VisitMappingEnd(value, context);
			if (context.GetType() != typeof(Nothing))
			{
				objectFactory.ExecuteOnSerialized(value.Value);
			}
		}

		private IObjectDescriptor GetObjectDescriptor(object? value, Type staticType)
		{
			return new ObjectDescriptor(value, typeResolver.Resolve(staticType, value), staticType);
		}
	}
	internal class RoundtripObjectGraphTraversalStrategy : FullObjectGraphTraversalStrategy
	{
		private readonly IEnumerable<IYamlTypeConverter> converters;

		private readonly Settings settings;

		public RoundtripObjectGraphTraversalStrategy(IEnumerable<IYamlTypeConverter> converters, ITypeInspector typeDescriptor, ITypeResolver typeResolver, int maxRecursion, INamingConvention namingConvention, Settings settings, IObjectFactory factory)
			: base(typeDescriptor, typeResolver, maxRecursion, namingConvention, factory)
		{
			this.converters = converters;
			this.settings = settings;
		}

		protected override void TraverseProperties<TContext>(IObjectDescriptor value, IObjectGraphVisitor<TContext> visitor, TContext context, Stack<ObjectPathSegment> path)
		{
			IObjectDescriptor value2 = value;
			if (!value2.Type.HasDefaultConstructor(settings.AllowPrivateConstructors) && !converters.Any((IYamlTypeConverter c) => c.Accepts(value2.Type)))
			{
				throw new InvalidOperationException($"Type '{value2.Type}' cannot be deserialized because it does not have a default constructor or a type converter.");
			}
			base.TraverseProperties(value2, visitor, context, path);
		}
	}
}
namespace YamlDotNet.Serialization.ObjectFactories
{
	internal sealed class DefaultObjectFactory : ObjectFactoryBase
	{
		private readonly Dictionary<Type, Dictionary<Type, MethodInfo[]>> _stateMethods = new Dictionary<Type, Dictionary<Type, MethodInfo[]>>
		{
			{
				typeof(YamlDotNet.Serialization.Callbacks.OnDeserializedAttribute),
				new Dictionary<Type, MethodInfo[]>()
			},
			{
				typeof(YamlDotNet.Serialization.Callbacks.OnDeserializingAttribute),
				new Dictionary<Type, MethodInfo[]>()
			},
			{
				typeof(YamlDotNet.Serialization.Callbacks.OnSerializedAttribute),
				new Dictionary<Type, MethodInfo[]>()
			},
			{
				typeof(YamlDotNet.Serialization.Callbacks.OnSerializingAttribute),
				new Dictionary<Type, MethodInfo[]>()
			}
		};

		private readonly Dictionary<Type, Type> DefaultGenericInterfaceImplementations = new Dictionary<Type, Type>
		{
			{
				typeof(IEnumerable<>),
				typeof(List<>)
			},
			{
				typeof(ICollection<>),
				typeof(List<>)
			},
			{
				typeof(IList<>),
				typeof(List<>)
			},
			{
				typeof(IDictionary<, >),
				typeof(Dictionary<, >)
			}
		};

		private readonly Dictionary<Type, Type> DefaultNonGenericInterfaceImplementations = new Dictionary<Type, Type>
		{
			{
				typeof(IEnumerable),
				typeof(List<object>)
			},
			{
				typeof(ICollection),
				typeof(List<object>)
			},
			{
				typeof(IList),
				typeof(List<object>)
			},
			{
				typeof(IDictionary),
				typeof(Dictionary<object, object>)
			}
		};

		private readonly Settings settings;

		public DefaultObjectFactory()
			: this(new Dictionary<Type, Type>(), new Settings())
		{
		}

		public DefaultObjectFactory(IDictionary<Type, Type> mappings)
			: this(mappings, new Settings())
		{
		}

		public DefaultObjectFactory(IDictionary<Type, Type> mappings, Settings settings)
		{
			foreach (KeyValuePair<Type, Type> mapping in mappings)
			{
				if (!mapping.Key.IsAssignableFrom(mapping.Value))
				{
					throw new InvalidOperationException($"Type '{mapping.Value}' does not implement type '{mapping.Key}'.");
				}
				DefaultNonGenericInterfaceImplementations.Add(mapping.Key, mapping.Value);
			}
			this.settings = settings;
		}

		public override object Create(Type type)
		{
			if (type.IsInterface())
			{
				Type value2;
				if (type.IsGenericType())
				{
					if (DefaultGenericInterfaceImplementations.TryGetValue(type.GetGenericTypeDefinition(), out Type value))
					{
						type = value.MakeGenericType(type.GetGenericArguments());
					}
				}
				else if (DefaultNonGenericInterfaceImplementations.TryGetValue(type, out value2))
				{
					type = value2;
				}
			}
			try
			{
				return Activator.CreateInstance(type, settings.AllowPrivateConstructors);
			}
			catch (Exception innerException)
			{
				throw new InvalidOperationException("Failed to create an instance of type '" + type.FullName + "'.", innerException);
			}
		}

		public override void ExecuteOnDeserialized(object value)
		{
			ExecuteState(typeof(YamlDotNet.Serialization.Callbacks.OnDeserializedAttribute), value);
		}

		public override void ExecuteOnDeserializing(object value)
		{
			ExecuteState(typeof(YamlDotNet.Serialization.Callbacks.OnDeserializingAttribute), value);
		}

		public override void ExecuteOnSerialized(object value)
		{
			ExecuteState(typeof(YamlDotNet.Serialization.Callbacks.OnSerializedAttribute), value);
		}

		public override void ExecuteOnSerializing(object value)
		{
			ExecuteState(typeof(YamlDotNet.Serialization.Callbacks.OnSerializingAttribute), value);
		}

		private void ExecuteState(Type attributeType, object value)
		{
			if (value != null)
			{
				Type type = value.GetType();
				MethodInfo[] stateMethods = GetStateMethods(attributeType, type);
				for (int i = 0; i < stateMethods.Length; i++)
				{
					stateMethods[i].Invoke(value, null);
				}
			}
		}

		private MethodInfo[] GetStateMethods(Type attributeType, Type valueType)
		{
			Type attributeType2 = attributeType;
			Dictionary<Type, MethodInfo[]> dictionary = _stateMethods[attributeType2];
			if (dictionary.TryGetValue(valueType, out var value))
			{
				return value;
			}
			value = valueType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			return dictionary[valueType] = value.Where((MethodInfo x) => x.GetCustomAttributes(attributeType2, inherit: true).Any()).ToArray();
		}
	}
	internal sealed class LambdaObjectFactory : ObjectFactoryBase
	{
		private readonly Func<Type, object> factory;

		public LambdaObjectFactory(Func<Type, object> factory)
		{
			this.factory = factory ?? throw new ArgumentNullException("factory");
		}

		public override object Create(Type type)
		{
			return factory(type);
		}
	}
	internal abstract class ObjectFactoryBase : IObjectFactory
	{
		public abstract object Create(Type type);

		public virtual object? CreatePrimitive(Type type)
		{
			if (!type.IsValueType())
			{
				return null;
			}
			return Activator.CreateInstance(type);
		}

		public virtual void ExecuteOnDeserialized(object value)
		{
		}

		public virtual void ExecuteOnDeserializing(object value)
		{
		}

		public virtual void ExecuteOnSerialized(object value)
		{
		}

		public virtual void ExecuteOnSerializing(object value)
		{
		}

		public virtual bool GetDictionary(IObjectDescriptor descriptor, out IDictionary? dictionary, out Type[]? genericArguments)
		{
			Type implementedGenericInterface = ReflectionUtility.GetImplementedGenericInterface(descriptor.Type, typeof(IDictionary<, >));
			if (implementedGenericInterface != null)
			{
				genericArguments = implementedGenericInterface.GetGenericArguments();
				object obj = Activator.CreateInstance(typeof(GenericDictionaryToNonGenericAdapter<, >).MakeGenericType(genericArguments), descriptor.Value);
				dictionary = obj as IDictionary;
				return true;
			}
			genericArguments = null;
			dictionary = null;
			return false;
		}

		public virtual Type GetValueType(Type type)
		{
			Type implementedGenericInterface = ReflectionUtility.GetImplementedGenericInterface(type, typeof(IEnumerable<>));
			if (!(implementedGenericInterface != null))
			{
				return typeof(object);
			}
			return implementedGenericInterface.GetGenericArguments()[0];
		}
	}
	internal abstract class StaticObjectFactory : IObjectFactory
	{
		public abstract object Create(Type type);

		public abstract Array CreateArray(Type type, int count);

		public abstract bool IsDictionary(Type type);

		public abstract bool IsArray(Type type);

		public abstract bool IsList(Type type);

		public abstract Type GetKeyType(Type type);

		public abstract Type GetValueType(Type type);

		public virtual object? CreatePrimitive(Type type)
		{
			return Type.GetTypeCode(type) switch
			{
				TypeCode.Boolean => false, 
				TypeCode.Byte => (byte)0, 
				TypeCode.Int16 => (short)0, 
				TypeCode.Int32 => 0, 
				TypeCode.Int64 => 0L, 
				TypeCode.SByte => (sbyte)0, 
				TypeCode.UInt16 => (ushort)0, 
				TypeCode.UInt32 => 0u, 
				TypeCode.UInt64 => 0uL, 
				TypeCode.Single => 0f, 
				TypeCode.Double => 0.0, 
				TypeCode.Decimal => 0m, 
				TypeCode.Char => '\0', 
				TypeCode.DateTime => default(DateTime), 
				_ => null, 
			};
		}

		public bool GetDictionary(IObjectDescriptor descriptor, out IDictionary? dictionary, out Type[]? genericArguments)
		{
			dictionary = null;
			genericArguments = null;
			return false;
		}

		public abstract void ExecuteOnDeserializing(object value);

		public abstract void ExecuteOnDeserialized(object value);

		public abstract void ExecuteOnSerializing(object value);

		public abstract void ExecuteOnSerialized(object value);
	}
}
namespace YamlDotNet.Serialization.NodeTypeResolvers
{
	internal sealed class DefaultContainersNodeTypeResolver : INodeTypeResolver
	{
		bool INodeTypeResolver.Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			if (currentType == typeof(object))
			{
				if (nodeEvent is SequenceStart)
				{
					currentType = typeof(List<object>);
					return true;
				}
				if (nodeEvent is MappingStart)
				{
					currentType = typeof(Dictionary<object, object>);
					return true;
				}
			}
			return false;
		}
	}
	internal class MappingNodeTypeResolver : INodeTypeResolver
	{
		private readonly IDictionary<Type, Type> _mappings;

		public MappingNodeTypeResolver(IDictionary<Type, Type> mappings)
		{
			if (mappings == null)
			{
				throw new ArgumentNullException("mappings");
			}
			foreach (KeyValuePair<Type, Type> mapping in mappings)
			{
				if (!mapping.Key.IsAssignableFrom(mapping.Value))
				{
					throw new InvalidOperationException($"Type '{mapping.Value}' does not implement type '{mapping.Key}'.");
				}
			}
			_mappings = mappings;
		}

		public bool Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			if (_mappings.TryGetValue(currentType, out Type value))
			{
				currentType = value;
				return true;
			}
			return false;
		}
	}
	internal class PreventUnknownTagsNodeTypeResolver : INodeTypeResolver
	{
		bool INodeTypeResolver.Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			if (nodeEvent != null && !nodeEvent.Tag.IsEmpty)
			{
				Mark start = nodeEvent.Start;
				Mark end = nodeEvent.End;
				throw new YamlException(in start, in end, $"Encountered an unresolved tag '{nodeEvent.Tag}'");
			}
			return false;
		}
	}
	internal sealed class TagNodeTypeResolver : INodeTypeResolver
	{
		private readonly IDictionary<TagName, Type> tagMappings;

		public TagNodeTypeResolver(IDictionary<TagName, Type> tagMappings)
		{
			this.tagMappings = tagMappings ?? throw new ArgumentNullException("tagMappings");
		}

		bool INodeTypeResolver.Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			if (nodeEvent != null && !nodeEvent.Tag.IsEmpty && tagMappings.TryGetValue(nodeEvent.Tag, out Type value))
			{
				currentType = value;
				return true;
			}
			return false;
		}
	}
	[Obsolete("The mechanism that this class uses to specify type names is non-standard. Register the tags explicitly instead of using this convention.")]
	internal sealed class TypeNameInTagNodeTypeResolver : INodeTypeResolver
	{
		bool INodeTypeResolver.Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			if (nodeEvent != null && !nodeEvent.Tag.IsEmpty)
			{
				Type type = Type.GetType(nodeEvent.Tag.Value.Substring(1), throwOnError: false);
				if (type != null)
				{
					currentType = type;
					return true;
				}
			}
			return false;
		}
	}
	internal sealed class YamlConvertibleTypeResolver : INodeTypeResolver
	{
		public bool Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			return typeof(IYamlConvertible).IsAssignableFrom(currentType);
		}
	}
	internal sealed class YamlSerializableTypeResolver : INodeTypeResolver
	{
		public bool Resolve(NodeEvent? nodeEvent, ref Type currentType)
		{
			return typeof(IYamlSerializable).IsAssignableFrom(currentType);
		}
	}
}
namespace YamlDotNet.Serialization.NodeDeserializers
{
	internal sealed class ArrayNodeDeserializer : INodeDeserializer
	{
		private sealed class ArrayList : IList, ICollection, IEnumerable
		{
			private object?[] data;

			public bool IsFixedSize => false;

			public bool IsReadOnly => false;

			public object? this[int index]
			{
				get
				{
					return data[index];
				}
				set
				{
					data[index] = value;
				}
			}

			public int Count { get; private set; }

			public bool IsSynchronized => false;

			public object SyncRoot => data;

			public ArrayList()
			{
				Clear();
			}

			public int Add(object? value)
			{
				if (Count == data.Length)
				{
					Array.Resize(ref data, data.Length * 2);
				}
				data[Count] = value;
				return Count++;
			}

			public void Clear()
			{
				data = new object[10];
				Count = 0;
			}

			bool IList.Contains(object? value)
			{
				throw new NotSupportedException();
			}

			int IList.IndexOf(object? value)
			{
				throw new NotSupportedException();
			}

			void IList.Insert(int index, object? value)
			{
				throw new NotSupportedException();
			}

			void IList.Remove(object? value)
			{
				throw new NotSupportedException();
			}

			void IList.RemoveAt(int index)
			{
				throw new NotSupportedException();
			}

			public void CopyTo(Array array, int index)
			{
				Array.Copy(data, 0, array, index, Count);
			}

			public IEnumerator GetEnumerator()
			{
				int i = 0;
				while (i < Count)
				{
					yield return data[i];
					int num = i + 1;
					i = num;
				}
			}
		}

		private readonly INamingConvention enumNamingConvention;

		public ArrayNodeDeserializer(INamingConvention enumNamingConvention)
		{
			this.enumNamingConvention = enumNamingConvention;
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (!expectedType.IsArray)
			{
				value = false;
				return false;
			}
			Type? elementType = expectedType.GetElementType();
			ArrayList arrayList = new ArrayList();
			CollectionNodeDeserializer.DeserializeHelper(elementType, parser, nestedObjectDeserializer, arrayList, canUpdate: true, enumNamingConvention);
			Array array = Array.CreateInstance(elementType, arrayList.Count);
			arrayList.CopyTo(array, 0);
			value = array;
			return true;
		}
	}
	internal abstract class CollectionDeserializer
	{
		protected static void DeserializeHelper(Type tItem, IParser parser, Func<IParser, Type, object?> nestedObjectDeserializer, IList result, bool canUpdate, IObjectFactory objectFactory)
		{
			IList result2 = result;
			parser.Consume<SequenceStart>();
			SequenceEnd @event;
			while (!parser.TryConsume<SequenceEnd>(out @event))
			{
				ParsingEvent current = parser.Current;
				object obj = nestedObjectDeserializer(parser, tItem);
				if (obj is IValuePromise valuePromise)
				{
					if (!canUpdate)
					{
						Mark start = current?.Start ?? Mark.Empty;
						Mark end = current?.End ?? Mark.Empty;
						throw new ForwardAnchorNotSupportedException(in start, in end, "Forward alias references are not allowed because this type does not implement IList<>");
					}
					int index = result2.Add(objectFactory.CreatePrimitive(tItem));
					valuePromise.ValueAvailable += delegate(object? v)
					{
						result2[index] = v;
					};
				}
				else
				{
					result2.Add(obj);
				}
			}
		}
	}
	internal sealed class CollectionNodeDeserializer : INodeDeserializer
	{
		private readonly IObjectFactory objectFactory;

		private readonly INamingConvention enumNamingConvention;

		public CollectionNodeDeserializer(IObjectFactory objectFactory, INamingConvention enumNamingConvention)
		{
			this.objectFactory = objectFactory ?? throw new ArgumentNullException("objectFactory");
			this.enumNamingConvention = enumNamingConvention;
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			bool canUpdate = true;
			Type implementedGenericInterface = ReflectionUtility.GetImplementedGenericInterface(expectedType, typeof(ICollection<>));
			Type type;
			IList list;
			if (implementedGenericInterface != null)
			{
				type = implementedGenericInterface.GetGenericArguments()[0];
				value = objectFactory.Create(expectedType);
				list = value as IList;
				if (list == null)
				{
					canUpdate = ReflectionUtility.GetImplementedGenericInterface(expectedType, typeof(IList<>)) != null;
					list = (IList)Activator.CreateInstance(typeof(GenericCollectionToNonGenericAdapter<>).MakeGenericType(type), value);
				}
			}
			else
			{
				if (!typeof(IList).IsAssignableFrom(expectedType))
				{
					value = null;
					return false;
				}
				type = typeof(object);
				value = objectFactory.Create(expectedType);
				list = (IList)value;
			}
			DeserializeHelper(type, parser, nestedObjectDeserializer, list, canUpdate, enumNamingConvention);
			return true;
		}

		internal static void DeserializeHelper(Type tItem, IParser parser, Func<IParser, Type, object?> nestedObjectDeserializer, IList result, bool canUpdate, INamingConvention enumNamingConvention)
		{
			IList result2 = result;
			Type tItem2 = tItem;
			INamingConvention enumNamingConvention2 = enumNamingConvention;
			parser.Consume<SequenceStart>();
			SequenceEnd @event;
			while (!parser.TryConsume<SequenceEnd>(out @event))
			{
				ParsingEvent current = parser.Current;
				object obj = nestedObjectDeserializer(parser, tItem2);
				if (obj is IValuePromise valuePromise)
				{
					if (!canUpdate)
					{
						Mark start = current?.Start ?? Mark.Empty;
						Mark end = current?.End ?? Mark.Empty;
						throw new ForwardAnchorNotSupportedException(in start, in end, "Forward alias references are not allowed because this type does not implement IList<>");
					}
					int index = result2.Add(tItem2.IsValueType() ? Activator.CreateInstance(tItem2) : null);
					valuePromise.ValueAvailable += delegate(object? v)
					{
						result2[index] = YamlDotNet.Serialization.Utilities.TypeConverter.ChangeType(v, tItem2, enumNamingConvention2);
					};
				}
				else
				{
					result2.Add(YamlDotNet.Serialization.Utilities.TypeConverter.ChangeType(obj, tItem2, enumNamingConvention2));
				}
			}
		}
	}
	internal abstract class DictionaryDeserializer
	{
		private readonly bool duplicateKeyChecking;

		public DictionaryDeserializer(bool duplicateKeyChecking)
		{
			this.duplicateKeyChecking = duplicateKeyChecking;
		}

		private void TryAssign(IDictionary result, object key, object value, MappingStart propertyName)
		{
			if (duplicateKeyChecking && result.Contains(key))
			{
				Mark start = propertyName.Start;
				Mark end = propertyName.End;
				throw new YamlException(in start, in end, $"Encountered duplicate key {key}");
			}
			result[key] = value;
		}

		protected virtual void Deserialize(Type tKey, Type tValue, IParser parser, Func<IParser, Type, object?> nestedObjectDeserializer, IDictionary result)
		{
			IDictionary result2 = result;
			MappingStart property = parser.Consume<MappingStart>();
			MappingEnd @event;
			while (!parser.TryConsume<MappingEnd>(out @event))
			{
				object key = nestedObjectDeserializer(parser, tKey);
				object value = nestedObjectDeserializer(parser, tValue);
				IValuePromise valuePromise = value as IValuePromise;
				if (key is IValuePromise valuePromise2)
				{
					if (valuePromise == null)
					{
						valuePromise2.ValueAvailable += delegate(object? v)
						{
							result2[v] = value;
						};
						continue;
					}
					bool hasFirstPart = false;
					valuePromise2.ValueAvailable += delegate(object? v)
					{
						if (hasFirstPart)
						{
							TryAssign(result2, v, value, property);
						}
						else
						{
							key = v;
							hasFirstPart = true;
						}
					};
					valuePromise.ValueAvailable += delegate(object? v)
					{
						if (hasFirstPart)
						{
							TryAssign(result2, key, v, property);
						}
						else
						{
							value = v;
							hasFirstPart = true;
						}
					};
					continue;
				}
				if (key == null)
				{
					throw new ArgumentException("Empty key names are not supported yet.", "key");
				}
				if (valuePromise == null)
				{
					TryAssign(result2, key, value, property);
					continue;
				}
				valuePromise.ValueAvailable += delegate(object? v)
				{
					result2[key] = v;
				};
			}
		}
	}
	internal class DictionaryNodeDeserializer : DictionaryDeserializer, INodeDeserializer
	{
		private readonly IObjectFactory objectFactory;

		public DictionaryNodeDeserializer(IObjectFactory objectFactory, bool duplicateKeyChecking)
			: base(duplicateKeyChecking)
		{
			this.objectFactory = objectFactory ?? throw new ArgumentNullException("objectFactory");
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			Type implementedGenericInterface = ReflectionUtility.GetImplementedGenericInterface(expectedType, typeof(IDictionary<, >));
			Type type;
			Type type2;
			IDictionary dictionary;
			if (implementedGenericInterface != null)
			{
				Type[] genericArguments = implementedGenericInterface.GetGenericArguments();
				type = genericArguments[0];
				type2 = genericArguments[1];
				value = objectFactory.Create(expectedType);
				dictionary = value as IDictionary;
				if (dictionary == null)
				{
					dictionary = (IDictionary)Activator.CreateInstance(typeof(GenericDictionaryToNonGenericAdapter<, >).MakeGenericType(type, type2), value);
				}
			}
			else
			{
				if (!typeof(IDictionary).IsAssignableFrom(expectedType))
				{
					value = null;
					return false;
				}
				type = typeof(object);
				type2 = typeof(object);
				value = objectFactory.Create(expectedType);
				dictionary = (IDictionary)value;
			}
			Deserialize(type, type2, parser, nestedObjectDeserializer, dictionary);
			return true;
		}
	}
	internal sealed class EnumerableNodeDeserializer : INodeDeserializer
	{
		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			Type type;
			if (expectedType == typeof(IEnumerable))
			{
				type = typeof(object);
			}
			else
			{
				Type implementedGenericInterface = ReflectionUtility.GetImplementedGenericInterface(expectedType, typeof(IEnumerable<>));
				if (implementedGenericInterface != expectedType)
				{
					value = null;
					return false;
				}
				type = implementedGenericInterface.GetGenericArguments()[0];
			}
			Type arg = typeof(List<>).MakeGenericType(type);
			value = nestedObjectDeserializer(parser, arg);
			return true;
		}
	}
	internal sealed class NullNodeDeserializer : INodeDeserializer
	{
		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			value = null;
			if (parser.Accept<NodeEvent>(out var @event) && NodeIsNull(@event))
			{
				parser.SkipThisAndNestedEvents();
				return true;
			}
			return false;
		}

		private bool NodeIsNull(NodeEvent nodeEvent)
		{
			if (nodeEvent.Tag == "tag:yaml.org,2002:null")
			{
				return true;
			}
			if (nodeEvent is YamlDotNet.Core.Events.Scalar scalar && scalar.Style == ScalarStyle.Plain && !scalar.IsKey)
			{
				string value = scalar.Value;
				switch (value)
				{
				default:
					return value == "NULL";
				case "":
				case "~":
				case "null":
				case "Null":
					return true;
				}
			}
			return false;
		}
	}
	internal sealed class ObjectNodeDeserializer : INodeDeserializer
	{
		private readonly IObjectFactory objectFactory;

		private readonly ITypeInspector typeDescriptor;

		private readonly bool ignoreUnmatched;

		private readonly bool duplicateKeyChecking;

		private readonly ITypeConverter typeConverter;

		private readonly INamingConvention enumNamingConvention;

		public ObjectNodeDeserializer(IObjectFactory objectFactory, ITypeInspector typeDescriptor, bool ignoreUnmatched, bool duplicateKeyChecking, ITypeConverter typeConverter, INamingConvention enumNamingConvention)
		{
			this.objectFactory = objectFactory ?? throw new ArgumentNullException("objectFactory");
			this.typeDescriptor = typeDescriptor ?? throw new ArgumentNullException("typeDescriptor");
			this.ignoreUnmatched = ignoreUnmatched;
			this.duplicateKeyChecking = duplicateKeyChecking;
			this.typeConverter = typeConverter ?? throw new ArgumentNullException("typeConverter");
			this.enumNamingConvention = enumNamingConvention ?? throw new ArgumentNullException("enumNamingConvention");
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (!parser.TryConsume<MappingStart>(out var _))
			{
				value = null;
				return false;
			}
			Type type = Nullable.GetUnderlyingType(expectedType) ?? expectedType;
			value = objectFactory.Create(type);
			objectFactory.ExecuteOnDeserializing(value);
			HashSet<string> hashSet = new HashSet<string>(StringComparer.Ordinal);
			MappingEnd event2;
			while (!parser.TryConsume<MappingEnd>(out event2))
			{
				YamlDotNet.Core.Events.Scalar scalar = parser.Consume<YamlDotNet.Core.Events.Scalar>();
				if (duplicateKeyChecking && !hashSet.Add(scalar.Value))
				{
					Mark start = scalar.Start;
					Mark end = scalar.End;
					throw new YamlException(in start, in end, "Encountered duplicate key " + scalar.Value);
				}
				try
				{
					IPropertyDescriptor property = typeDescriptor.GetProperty(type, null, scalar.Value, ignoreUnmatched);
					if (property == null)
					{
						parser.SkipThisAndNestedEvents();
						continue;
					}
					object obj = nestedObjectDeserializer(parser, property.Type);
					if (obj is IValuePromise valuePromise)
					{
						object valueRef = value;
						valuePromise.ValueAvailable += delegate(object? v)
						{
							object value3 = typeConverter.ChangeType(v, property.Type, enumNamingConvention);
							property.Write(valueRef, value3);
						};
					}
					else
					{
						object value2 = typeConverter.ChangeType(obj, property.Type, enumNamingConvention);
						property.Write(value, value2);
					}
				}
				catch (SerializationException ex)
				{
					Mark start = scalar.Start;
					Mark end = scalar.End;
					throw new YamlException(in start, in end, ex.Message);
				}
				catch (YamlException)
				{
					throw;
				}
				catch (Exception innerException)
				{
					Mark start = scalar.Start;
					Mark end = scalar.End;
					throw new YamlException(in start, in end, "Exception during deserialization", innerException);
				}
			}
			objectFactory.ExecuteOnDeserialized(value);
			return true;
		}
	}
	internal sealed class ScalarNodeDeserializer : INodeDeserializer
	{
		private const string BooleanTruePattern = "^(true|y|yes|on)$";

		private const string BooleanFalsePattern = "^(false|n|no|off)$";

		private readonly bool attemptUnknownTypeDeserialization;

		private readonly ITypeConverter typeConverter;

		private readonly YamlFormatter formatter;

		private readonly INamingConvention enumNamingConvention;

		public ScalarNodeDeserializer(bool attemptUnknownTypeDeserialization, ITypeConverter typeConverter, YamlFormatter formatter, INamingConvention enumNamingConvention)
		{
			this.attemptUnknownTypeDeserialization = attemptUnknownTypeDeserialization;
			this.typeConverter = typeConverter ?? throw new ArgumentNullException("typeConverter");
			this.formatter = formatter;
			this.enumNamingConvention = enumNamingConvention;
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (!parser.TryConsume<YamlDotNet.Core.Events.Scalar>(out var @event))
			{
				value = null;
				return false;
			}
			Type type = Nullable.GetUnderlyingType(expectedType) ?? expectedType;
			if (type.IsEnum())
			{
				string value2 = enumNamingConvention.Reverse(@event.Value);
				value = Enum.Parse(type, value2, ignoreCase: true);
				return true;
			}
			TypeCode typeCode = type.GetTypeCode();
			switch (typeCode)
			{
			case TypeCode.Boolean:
				value = DeserializeBooleanHelper(@event.Value);
				break;
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				value = DeserializeIntegerHelper(typeCode, @event.Value);
				break;
			case TypeCode.Single:
				value = float.Parse(@event.Value, formatter.NumberFormat);
				break;
			case TypeCode.Double:
				value = double.Parse(@event.Value, formatter.NumberFormat);
				break;
			case TypeCode.Decimal:
				value = decimal.Parse(@event.Value, formatter.NumberFormat);
				break;
			case TypeCode.String:
				value = @event.Value;
				break;
			case TypeCode.Char:
				value = @event.Value[0];
				break;
			case TypeCode.DateTime:
				value = DateTime.Parse(@event.Value, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind);
				break;
			default:
				if (expectedType == typeof(object))
				{
					if (!@event.IsKey && attemptUnknownTypeDeserialization)
					{
						value = AttemptUnknownTypeDeserialization(@event);
					}
					else
					{
						value = @event.Value;
					}
				}
				else
				{
					value = typeConverter.ChangeType(@event.Value, expectedType, enumNamingConvention);
				}
				break;
			}
			return true;
		}

		private object DeserializeBooleanHelper(string value)
		{
			bool flag;
			if (Regex.IsMatch(value, "^(true|y|yes|on)$", RegexOptions.IgnoreCase))
			{
				flag = true;
			}
			else
			{
				if (!Regex.IsMatch(value, "^(false|n|no|off)$", RegexOptions.IgnoreCase))
				{
					throw new FormatException("The value \"" + value + "\" is not a valid YAML Boolean");
				}
				flag = false;
			}
			return flag;
		}

		private object DeserializeIntegerHelper(TypeCode typeCode, string value)
		{
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				int i = 0;
				bool flag = false;
				ulong num = 0uL;
				if (value[0] == '-')
				{
					i++;
					flag = true;
				}
				else if (value[0] == '+')
				{
					i++;
				}
				if (value[i] == '0')
				{
					int num2;
					if (i == value.Length - 1)
					{
						num2 = 10;
						num = 0uL;
					}
					else
					{
						i++;
						if (value[i] == 'b')
						{
							num2 = 2;
							i++;
						}
						else if (value[i] == 'x')
						{
							num2 = 16;
							i++;
						}
						else
						{
							num2 = 8;
						}
					}
					for (; i < value.Length; i++)
					{
						if (value[i] != '_')
						{
							builder.Append(value[i]);
						}
					}
					switch (num2)
					{
					case 2:
					case 8:
						num = Convert.ToUInt64(builder.ToString(), num2);
						break;
					case 16:
						num = ulong.Parse(builder.ToString(), NumberStyles.HexNumber, formatter.NumberFormat);
						break;
					}
				}
				else
				{
					string[] array = value.Substring(i).Split(new char[1] { ':' });
					num = 0uL;
					for (int j = 0; j < array.Length; j++)
					{
						num *= 60;
						num += ulong.Parse(array[j].Replace("_", ""));
					}
				}
				if (!flag)
				{
					return CastInteger(num, typeCode);
				}
				long number = ((num != 9223372036854775808uL) ? checked(-(long)num) : long.MinValue);
				return CastInteger(number, typeCode);
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private static object CastInteger(long number, TypeCode typeCode)
		{
			return checked(typeCode switch
			{
				TypeCode.Byte => (byte)number, 
				TypeCode.Int16 => (short)number, 
				TypeCode.Int32 => (int)number, 
				TypeCode.Int64 => number, 
				TypeCode.SByte => (sbyte)number, 
				TypeCode.UInt16 => (ushort)number, 
				TypeCode.UInt32 => (uint)number, 
				TypeCode.UInt64 => (ulong)number, 
				_ => number, 
			});
		}

		private static object CastInteger(ulong number, TypeCode typeCode)
		{
			return checked(typeCode switch
			{
				TypeCode.Byte => (byte)number, 
				TypeCode.Int16 => (short)number, 
				TypeCode.Int32 => (int)number, 
				TypeCode.Int64 => (long)number, 
				TypeCode.SByte => (sbyte)number, 
				TypeCode.UInt16 => (ushort)number, 
				TypeCode.UInt32 => (uint)number, 
				TypeCode.UInt64 => number, 
				_ => number, 
			});
		}

		private object? AttemptUnknownTypeDeserialization(YamlDotNet.Core.Events.Scalar value)
		{
			if (value.Style == ScalarStyle.SingleQuoted || value.Style == ScalarStyle.DoubleQuoted || value.Style == ScalarStyle.Folded)
			{
				return value.Value;
			}
			string v = value.Value;
			switch (v)
			{
			case "null":
			case "Null":
			case "NULL":
			case "~":
			case "":
				return null;
			case "true":
			case "True":
			case "TRUE":
				return true;
			case "False":
			case "FALSE":
			case "false":
				return false;
			default:
			{
				object value2;
				if (Regex.IsMatch(v, "0x[0-9a-fA-F]+"))
				{
					if (!TryAndSwallow(() => Convert.ToByte(v, 16), out value2) && !TryAndSwallow(() => Convert.ToInt16(v, 16), out value2) && !TryAndSwallow(() => Convert.ToInt32(v, 16), out value2) && !TryAndSwallow(() => Convert.ToInt64(v, 16), out value2) && !TryAndSwallow(() => Convert.ToUInt64(v, 16), out value2))
					{
						return v;
					}
				}
				else if (Regex.IsMatch(v, "0o[0-9a-fA-F]+"))
				{
					if (!TryAndSwallow(() => Convert.ToByte(v, 8), out value2) && !TryAndSwallow(() => Convert.ToInt16(v, 8), out value2) && !TryAndSwallow(() => Convert.ToInt32(v, 8), out value2) && !TryAndSwallow(() => Convert.ToInt64(v, 8), out value2) && !TryAndSwallow(() => Convert.ToUInt64(v, 8), out value2))
					{
						return v;
					}
				}
				else
				{
					if (!Regex.IsMatch(v, "[-+]?(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?"))
					{
						if (Regex.IsMatch(v, "^[-+]?(\\.inf|\\.Inf|\\.INF)$"))
						{
							if (v.StartsWith("-"))
							{
								return float.NegativeInfinity;
							}
							return float.PositiveInfinity;
						}
						if (Regex.IsMatch(v, "^(\\.nan|\\.NaN|\\.NAN)$"))
						{
							return float.NaN;
						}
						return v;
					}
					if (!TryAndSwallow(() => byte.Parse(v, formatter.NumberFormat), out value2) && !TryAndSwallow(() => short.Parse(v, formatter.NumberFormat), out value2) && !TryAndSwallow(() => int.Parse(v, formatter.NumberFormat), out value2) && !TryAndSwallow(() => long.Parse(v, formatter.NumberFormat), out value2) && !TryAndSwallow(() => ulong.Parse(v, formatter.NumberFormat), out value2) && !TryAndSwallow(() => float.Parse(v, formatter.NumberFormat), out value2) && !TryAndSwallow(() => double.Parse(v, formatter.NumberFormat), out value2))
					{
						return v;
					}
				}
				return value2;
			}
			}
		}

		private static bool TryAndSwallow(Func<object> attempt, out object? value)
		{
			try
			{
				value = attempt();
				return true;
			}
			catch
			{
				value = null;
				return false;
			}
		}
	}
	internal sealed class StaticArrayNodeDeserializer : INodeDeserializer
	{
		private sealed class ArrayList : IList, ICollection, IEnumerable
		{
			private object?[] data;

			public bool IsFixedSize => false;

			public bool IsReadOnly => false;

			public object? this[int index]
			{
				get
				{
					return data[index];
				}
				set
				{
					data[index] = value;
				}
			}

			public int Count { get; private set; }

			public bool IsSynchronized => false;

			public object SyncRoot => data;

			public ArrayList()
			{
				Clear();
			}

			public int Add(object? value)
			{
				if (Count == data.Length)
				{
					Array.Resize(ref data, data.Length * 2);
				}
				data[Count] = value;
				return Count++;
			}

			public void Clear()
			{
				data = new object[10];
				Count = 0;
			}

			bool IList.Contains(object? value)
			{
				throw new NotSupportedException();
			}

			int IList.IndexOf(object? value)
			{
				throw new NotSupportedException();
			}

			void IList.Insert(int index, object? value)
			{
				throw new NotSupportedException();
			}

			void IList.Remove(object? value)
			{
				throw new NotSupportedException();
			}

			void IList.RemoveAt(int index)
			{
				throw new NotSupportedException();
			}

			public void CopyTo(Array array, int index)
			{
				Array.Copy(data, 0, array, index, Count);
			}

			public IEnumerator GetEnumerator()
			{
				int i = 0;
				while (i < Count)
				{
					yield return data[i];
					int num = i + 1;
					i = num;
				}
			}
		}

		private readonly StaticObjectFactory factory;

		public StaticArrayNodeDeserializer(StaticObjectFactory factory)
		{
			this.factory = factory ?? throw new ArgumentNullException("factory");
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (!factory.IsArray(expectedType))
			{
				value = false;
				return false;
			}
			Type valueType = factory.GetValueType(expectedType);
			ArrayList arrayList = new ArrayList();
			StaticCollectionNodeDeserializer.DeserializeHelper(valueType, parser, nestedObjectDeserializer, arrayList, factory);
			Array array = factory.CreateArray(expectedType, arrayList.Count);
			arrayList.CopyTo(array, 0);
			value = array;
			return true;
		}
	}
	internal sealed class StaticCollectionNodeDeserializer : INodeDeserializer
	{
		private readonly StaticObjectFactory factory;

		public StaticCollectionNodeDeserializer(StaticObjectFactory factory)
		{
			this.factory = factory ?? throw new ArgumentNullException("factory");
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (!factory.IsList(expectedType))
			{
				value = null;
				return false;
			}
			DeserializeHelper(result: (IList)(value = factory.Create(expectedType) as IList), tItem: factory.GetValueType(expectedType), parser: parser, nestedObjectDeserializer: nestedObjectDeserializer, factory: factory);
			return true;
		}

		internal static void DeserializeHelper(Type tItem, IParser parser, Func<IParser, Type, object?> nestedObjectDeserializer, IList result, IObjectFactory factory)
		{
			IList result2 = result;
			parser.Consume<SequenceStart>();
			SequenceEnd @event;
			while (!parser.TryConsume<SequenceEnd>(out @event))
			{
				_ = parser.Current;
				object obj = nestedObjectDeserializer(parser, tItem);
				if (obj is IValuePromise valuePromise)
				{
					int index = result2.Add(factory.CreatePrimitive(tItem));
					valuePromise.ValueAvailable += delegate(object? v)
					{
						result2[index] = v;
					};
				}
				else
				{
					result2.Add(obj);
				}
			}
		}
	}
	internal class StaticDictionaryNodeDeserializer : DictionaryDeserializer, INodeDeserializer
	{
		private readonly StaticObjectFactory _objectFactory;

		public StaticDictionaryNodeDeserializer(StaticObjectFactory objectFactory, bool duplicateKeyChecking)
			: base(duplicateKeyChecking)
		{
			_objectFactory = objectFactory ?? throw new ArgumentNullException("objectFactory");
		}

		public bool Deserialize(IParser reader, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (_objectFactory.IsDictionary(expectedType))
			{
				if (!(_objectFactory.Create(expectedType) is IDictionary dictionary))
				{
					value = null;
					return false;
				}
				Type keyType = _objectFactory.GetKeyType(expectedType);
				Type valueType = _objectFactory.GetValueType(expectedType);
				value = dictionary;
				base.Deserialize(keyType, valueType, reader, nestedObjectDeserializer, dictionary);
				return true;
			}
			value = null;
			return false;
		}
	}
	internal sealed class TypeConverterNodeDeserializer : INodeDeserializer
	{
		private readonly IEnumerable<IYamlTypeConverter> converters;

		public TypeConverterNodeDeserializer(IEnumerable<IYamlTypeConverter> converters)
		{
			this.converters = converters ?? throw new ArgumentNullException("converters");
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			Type expectedType2 = expectedType;
			IYamlTypeConverter yamlTypeConverter = converters.FirstOrDefault((IYamlTypeConverter c) => c.Accepts(expectedType2));
			if (yamlTypeConverter == null)
			{
				value = null;
				return false;
			}
			value = yamlTypeConverter.ReadYaml(parser, expectedType2);
			return true;
		}
	}
	internal sealed class YamlConvertibleNodeDeserializer : INodeDeserializer
	{
		private readonly IObjectFactory objectFactory;

		public YamlConvertibleNodeDeserializer(IObjectFactory objectFactory)
		{
			this.objectFactory = objectFactory;
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			Func<IParser, Type, object?> nestedObjectDeserializer2 = nestedObjectDeserializer;
			IParser parser2 = parser;
			if (typeof(IYamlConvertible).IsAssignableFrom(expectedType))
			{
				IYamlConvertible yamlConvertible = (IYamlConvertible)objectFactory.Create(expectedType);
				yamlConvertible.Read(parser2, expectedType, (Type type) => nestedObjectDeserializer2(parser2, type));
				value = yamlConvertible;
				return true;
			}
			value = null;
			return false;
		}
	}
	internal sealed class YamlSerializableNodeDeserializer : INodeDeserializer
	{
		private readonly IObjectFactory objectFactory;

		public YamlSerializableNodeDeserializer(IObjectFactory objectFactory)
		{
			this.objectFactory = objectFactory;
		}

		public bool Deserialize(IParser parser, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			if (typeof(IYamlSerializable).IsAssignableFrom(expectedType))
			{
				IYamlSerializable yamlSerializable = (IYamlSerializable)objectFactory.Create(expectedType);
				yamlSerializable.ReadYaml(parser);
				value = yamlSerializable;
				return true;
			}
			value = null;
			return false;
		}
	}
}
namespace YamlDotNet.Serialization.NamingConventions
{
	internal sealed class CamelCaseNamingConvention : INamingConvention
	{
		public static readonly INamingConvention Instance = new CamelCaseNamingConvention();

		[Obsolete("Use the Instance static field instead of creating new instances")]
		public CamelCaseNamingConvention()
		{
		}

		public string Apply(string value)
		{
			return value.ToCamelCase();
		}

		public string Reverse(string value)
		{
			return value.ToPascalCase();
		}
	}
	internal sealed class HyphenatedNamingConvention : INamingConvention
	{
		public static readonly INamingConvention Instance = new HyphenatedNamingConvention();

		[Obsolete("Use the Instance static field instead of creating new instances")]
		public HyphenatedNamingConvention()
		{
		}

		public string Apply(string value)
		{
			return value.FromCamelCase("-");
		}

		public string Reverse(string value)
		{
			return value.ToPascalCase();
		}
	}
	internal sealed class LowerCaseNamingConvention : INamingConvention
	{
		public static readonly INamingConvention Instance = new LowerCaseNamingConvention();

		private LowerCaseNamingConvention()
		{
		}

		public string Apply(string value)
		{
			return value.ToCamelCase().ToLower();
		}

		public string Reverse(string value)
		{
			if (string.IsNullOrEmpty(value))
			{
				return value;
			}
			return char.ToUpperInvariant(value[0]) + value.Substring(1);
		}
	}
	internal sealed class NullNamingConvention : INamingConvention
	{
		public static readonly INamingConvention Instance = new NullNamingConvention();

		[Obsolete("Use the Instance static field instead of creating new instances")]
		public NullNamingConvention()
		{
		}

		public string Apply(string value)
		{
			return value;
		}

		public string Reverse(string value)
		{
			return value;
		}
	}
	internal sealed class PascalCaseNamingConvention : INamingConvention
	{
		public static readonly INamingConvention Instance = new PascalCaseNamingConvention();

		[Obsolete("Use the Instance static field instead of creating new instances")]
		public PascalCaseNamingConvention()
		{
		}

		public string Apply(string value)
		{
			return value.ToPascalCase();
		}

		public string Reverse(string value)
		{
			return value.ToPascalCase();
		}
	}
	internal sealed class UnderscoredNamingConvention : INamingConvention
	{
		public static readonly INamingConvention Instance = new UnderscoredNamingConvention();

		[Obsolete("Use the Instance static field instead of creating new instances")]
		public UnderscoredNamingConvention()
		{
		}

		public string Apply(string value)
		{
			return value.FromCamelCase("_");
		}

		public string Reverse(string value)
		{
			return value.ToPascalCase();
		}
	}
}
namespace YamlDotNet.Serialization.EventEmitters
{
	internal abstract class ChainedEventEmitter : IEventEmitter
	{
		protected readonly IEventEmitter nextEmitter;

		protected ChainedEventEmitter(IEventEmitter nextEmitter)
		{
			this.nextEmitter = nextEmitter ?? throw new ArgumentNullException("nextEmitter");
		}

		public virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter)
		{
			nextEmitter.Emit(eventInfo, emitter);
		}

		public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter)
		{
			nextEmitter.Emit(eventInfo, emitter);
		}

		public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter)
		{
			nextEmitter.Emit(eventInfo, emitter);
		}

		public virtual void Emit(MappingEndEventInfo eventInfo, IEmitter emitter)
		{
			nextEmitter.Emit(eventInfo, emitter);
		}

		public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter)
		{
			nextEmitter.Emit(eventInfo, emitter);
		}

		public virtual void Emit(SequenceEndEventInfo eventInfo, IEmitter emitter)
		{
			nextEmitter.Emit(eventInfo, emitter);
		}
	}
	internal sealed class JsonEventEmitter : ChainedEventEmitter
	{
		private readonly YamlFormatter formatter;

		private readonly INamingConvention enumNamingConvention;

		public JsonEventEmitter(IEventEmitter nextEmitter, YamlFormatter formatter, INamingConvention enumNamingConvention)
			: base(nextEmitter)
		{
			this.formatter = formatter;
			this.enumNamingConvention = enumNamingConvention;
		}

		public override void Emit(AliasEventInfo eventInfo, IEmitter emitter)
		{
			eventInfo.NeedsExpansion = true;
		}

		public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter)
		{
			eventInfo.IsPlainImplicit = true;
			eventInfo.Style = ScalarStyle.Plain;
			object value = eventInfo.Source.Value;
			if (value == null)
			{
				eventInfo.RenderedValue = "null";
			}
			else
			{
				TypeCode typeCode = eventInfo.Source.Type.GetTypeCode();
				switch (typeCode)
				{
				case TypeCode.Boolean:
					eventInfo.RenderedValue = formatter.FormatBoolean(value);
					break;
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
					if (eventInfo.Source.Type.IsEnum())
					{
						eventInfo.RenderedValue = formatter.FormatEnum(value, enumNamingConvention);
						eventInfo.Style = ((!formatter.PotentiallyQuoteEnums(value)) ? ScalarStyle.Plain : ScalarStyle.DoubleQuoted);
					}
					else
					{
						eventInfo.RenderedValue = formatter.FormatNumber(value);
					}
					break;
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					eventInfo.RenderedValue = formatter.FormatNumber(value);
					break;
				case TypeCode.Char:
				case TypeCode.String:
					eventInfo.RenderedValue = value.ToString();
					eventInfo.Style = ScalarStyle.DoubleQuoted;
					break;
				case TypeCode.DateTime:
					eventInfo.RenderedValue = formatter.FormatDateTime(value);
					break;
				case TypeCode.Empty:
					eventInfo.RenderedValue = "null";
					break;
				default:
					if (eventInfo.Source.Type == typeof(TimeSpan))
					{
						eventInfo.RenderedValue = formatter.FormatTimeSpan(value);
						break;
					}
					throw new NotSupportedException($"TypeCode.{typeCode} is not supported.");
				}
			}
			base.Emit(eventInfo, emitter);
		}

		public override void Emit(MappingStartEventInfo eventInfo, IEmitter emitter)
		{
			eventInfo.Style = MappingStyle.Flow;
			base.Emit(eventInfo, emitter);
		}

		public override void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter)
		{
			eventInfo.Style = SequenceStyle.Flow;
			base.Emit(eventInfo, emitter);
		}
	}
	internal sealed class TypeAssigningEventEmitter : ChainedEventEmitter
	{
		private readonly bool requireTagWhenStaticAndActualTypesAreDifferent;

		private readonly IDictionary<Type, TagName> tagMappings;

		private readonly bool quoteNecessaryStrings;

		private readonly Regex? isSpecialStringValue_Regex;

		private static readonly string SpecialStrings_Pattern = "^(null|Null|NULL|\\~|true|True|TRUE|false|False|FALSE|[-+]?[0-9]+|0o[0-7]+|0x[0-9a-fA-F]+|[-+]?(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\\.inf|\\.Inf|\\.INF)|\\.nan|\\.NaN|\\.NAN)$";

		private static readonly string CombinedYaml1_1SpecialStrings_Pattern = "^(null|Null|NULL|\\~|true|True|TRUE|false|False|FALSE|y|Y|yes|Yes|YES|n|N|no|No|NO|on|On|ON|off|Off|OFF|[-+]?0b[0-1_]+|[-+]?0o?[0-7_]+|[-+]?(0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?[1-9][0-9_]*(:[0-5]?[0-9])+|[-+]?([0-9][0-9_]*)?\\.[0-9_]*([eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(:[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(inf|Inf|INF)|\\.(nan|NaN|NAN))$";

		private readonly ScalarStyle defaultScalarStyle;

		private readonly YamlFormatter formatter;

		private readonly INamingConvention enumNamingConvention;

		public TypeAssigningEventEmitter(IEventEmitter nextEmitter, bool requireTagWhenStaticAndActualTypesAreDifferent, IDictionary<Type, TagName> tagMappings, bool quoteNecessaryStrings, bool quoteYaml1_1Strings, ScalarStyle defaultScalarStyle, YamlFormatter formatter, INamingConvention enumNamingConvention)
			: base(nextEmitter)
		{
			this.requireTagWhenStaticAndActualTypesAreDifferent = requireTagWhenStaticAndActualTypesAreDifferent;
			this.defaultScalarStyle = defaultScalarStyle;
			this.formatter = formatter;
			this.tagMappings = tagMappings;
			this.quoteNecessaryStrings = quoteNecessaryStrings;
			isSpecialStringValue_Regex = new Regex(quoteYaml1_1Strings ? CombinedYaml1_1SpecialStrings_Pattern : SpecialStrings_Pattern, RegexOptions.Compiled);
			this.enumNamingConvention = enumNamingConvention;
		}

		public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter)
		{
			ScalarStyle style = ScalarStyle.Plain;
			object value = eventInfo.Source.Value;
			if (value == null)
			{
				eventInfo.Tag = JsonSchema.Tags.Null;
				eventInfo.RenderedValue = "";
			}
			else
			{
				TypeCode typeCode = eventInfo.Source.Type.GetTypeCode();
				switch (typeCode)
				{
				case TypeCode.Boolean:
					eventInfo.Tag = JsonSchema.Tags.Bool;
					eventInfo.RenderedValue = formatter.FormatBoolean(value);
					break;
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
				case TypeCode.Int32:
				case TypeCode.UInt32:
				case TypeCode.Int64:
				case TypeCode.UInt64:
					if (eventInfo.Source.Type.IsEnum)
					{
						eventInfo.Tag = FailsafeSchema.Tags.Str;
						eventInfo.RenderedValue = formatter.FormatEnum(value, enumNamingConvention);
						style = ((!quoteNecessaryStrings || !IsSpecialStringValue(eventInfo.RenderedValue) || !formatter.PotentiallyQuoteEnums(value)) ? defaultScalarStyle : ScalarStyle.DoubleQuoted);
					}
					else
					{
						eventInfo.Tag = JsonSchema.Tags.Int;
						eventInfo.RenderedValue = formatter.FormatNumber(value);
					}
					break;
				case TypeCode.Single:
					eventInfo.Tag = JsonSchema.Tags.Float;
					eventInfo.RenderedValue = formatter.FormatNumber((float)value);
					break;
				case TypeCode.Double:
					eventInfo.Tag = JsonSchema.Tags.Float;
					eventInfo.RenderedValue = formatter.FormatNumber((double)value);
					break;
				case TypeCode.Decimal:
					eventInfo.Tag = JsonSchema.Tags.Float;
					eventInfo.RenderedValue = formatter.FormatNumber(value);
					break;
				case TypeCode.Char:
				case TypeCode.String:
					eventInfo.Tag = FailsafeSchema.Tags.Str;
					eventInfo.RenderedValue = value.ToString();
					style = ((!quoteNecessaryStrings || !IsSpecialStringValue(eventInfo.RenderedValue)) ? defaultScalarStyle : ScalarStyle.DoubleQuoted);
					break;
				case TypeCode.DateTime:
					eventInfo.Tag = DefaultSchema.Tags.Timestamp;
					eventInfo.RenderedValue = formatter.FormatDateTime(value);
					break;
				case TypeCode.Empty:
					eventInfo.Tag = JsonSchema.Tags.Null;
					eventInfo.RenderedValue = "";
					break;
				default:
					if (eventInfo.Source.Type == typeof(TimeSpan))
					{
						eventInfo.RenderedValue = formatter.FormatTimeSpan(value);
						break;
					}
					throw new NotSupportedException($"TypeCode.{typeCode} is not supported.");
				}
			}
			eventInfo.IsPlainImplicit = true;
			if (eventInfo.Style == ScalarStyle.Any)
			{
				eventInfo.Style = style;
			}
			base.Emit(eventInfo, emitter);
		}

		public override void Emit(MappingStartEventInfo eventInfo, IEmitter emitter)
		{
			AssignTypeIfNeeded(eventInfo);
			base.Emit(eventInfo, emitter);
		}

		public override void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter)
		{
			AssignTypeIfNeeded(eventInfo);
			base.Emit(eventInfo, emitter);
		}

		private void AssignTypeIfNeeded(ObjectEventInfo eventInfo)
		{
			if (tagMappings.TryGetValue(eventInfo.Source.Type, out var value))
			{
				eventInfo.Tag = value;
			}
			else if (requireTagWhenStaticAndActualTypesAreDifferent && eventInfo.Source.Value != null && eventInfo.Source.Type != eventInfo.Source.StaticType)
			{
				throw new YamlException("Cannot serialize type '" + eventInfo.Source.Type.FullName + "' where a '" + eventInfo.Source.StaticType.FullName + "' was expected because no tag mapping has been registered for '" + eventInfo.Source.Type.FullName + "', which means that it won't be possible to deserialize the document.\nRegister a tag mapping using the SerializerBuilder.WithTagMapping method.\n\nE.g: builder.WithTagMapping(\"!" + eventInfo.Source.Type.Name + "\", typeof(" + eventInfo.Source.Type.FullName + "));");
			}
		}

		private bool IsSpecialStringValue(string value)
		{
			if (value.Trim() == string.Empty)
			{
				return true;
			}
			return isSpecialStringValue_Regex?.IsMatch(value) ?? false;
		}
	}
	internal sealed class WriterEventEmitter : IEventEmitter
	{
		void IEventEmitter.Emit(AliasEventInfo eventInfo, IEmitter emitter)
		{
			emitter.Emit(new YamlDotNet.Core.Events.AnchorAlias(eventInfo.Alias));
		}

		void IEventEmitter.Emit(ScalarEventInfo eventInfo, IEmitter emitter)
		{
			emitter.Emit(new YamlDotNet.Core.Events.Scalar(eventInfo.Anchor, eventInfo.Tag, eventInfo.RenderedValue, eventInfo.Style, eventInfo.IsPlainImplicit, eventInfo.IsQuotedImplicit));
		}

		void IEventEmitter.Emit(MappingStartEventInfo eventInfo, IEmitter emitter)
		{
			emitter.Emit(new MappingStart(eventInfo.Anchor, eventInfo.Tag, eventInfo.IsImplicit, eventInfo.Style));
		}

		void IEventEmitter.Emit(MappingEndEventInfo eventInfo, IEmitter emitter)
		{
			emitter.Emit(new MappingEnd());
		}

		void IEventEmitter.Emit(SequenceStartEventInfo eventInfo, IEmitter emitter)
		{
			emitter.Emit(new SequenceStart(eventInfo.Anchor, eventInfo.Tag, eventInfo.IsImplicit, eventInfo.Style));
		}

		void IEventEmitter.Emit(SequenceEndEventInfo eventInfo, IEmitter emitter)
		{
			emitter.Emit(new SequenceEnd());
		}
	}
}
namespace YamlDotNet.Serialization.Converters
{
	internal class DateTimeConverter : IYamlTypeConverter
	{
		private readonly DateTimeKind kind;

		private readonly IFormatProvider provider;

		private readonly bool doubleQuotes;

		private readonly string[] formats;

		public DateTimeConverter(DateTimeKind kind = DateTimeKind.Utc, IFormatProvider? provider = null, bool doubleQuotes = false, params string[] formats)
		{
			this.kind = ((kind == DateTimeKind.Unspecified) ? DateTimeKind.Utc : kind);
			this.provider = provider ?? CultureInfo.InvariantCulture;
			this.doubleQuotes = doubleQuotes;
			this.formats = formats.DefaultIfEmpty("G").ToArray();
		}

		public bool Accepts(Type type)
		{
			return type == typeof(DateTime);
		}

		public object ReadYaml(IParser parser, Type type)
		{
			return EnsureDateTimeKind(DateTime.ParseExact(parser.Consume<YamlDotNet.Core.Events.Scalar>().Value, style: (kind == DateTimeKind.Local) ? DateTimeStyles.AssumeLocal : DateTimeStyles.AssumeUniversal, formats: formats, provider: provider), kind);
		}

		public void WriteYaml(IEmitter emitter, object? value, Type type)
		{
			DateTime dateTime = (DateTime)value;
			string value2 = ((kind == DateTimeKind.Local) ? dateTime.ToLocalTime() : dateTime.ToUniversalTime()).ToString(formats.First(), provider);
			emitter.Emit(new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, TagName.Empty, value2, doubleQuotes ? ScalarStyle.DoubleQuoted : ScalarStyle.Any, isPlainImplicit: true, isQuotedImplicit: false));
		}

		private static DateTime EnsureDateTimeKind(DateTime dt, DateTimeKind kind)
		{
			if (dt.Kind == DateTimeKind.Local && kind == DateTimeKind.Utc)
			{
				return dt.ToUniversalTime();
			}
			if (dt.Kind == DateTimeKind.Utc && kind == DateTimeKind.Local)
			{
				return dt.ToLocalTime();
			}
			return dt;
		}
	}
	internal class DateTimeOffsetConverter : IYamlTypeConverter
	{
		private readonly IFormatProvider provider;

		private readonly ScalarStyle style;

		private readonly DateTimeStyles dateStyle;

		private readonly string[] formats;

		public DateTimeOffsetConverter(IFormatProvider? provider = null, ScalarStyle style = ScalarStyle.Any, DateTimeStyles dateStyle = DateTimeStyles.None, params string[] formats)
		{
			this.provider = provider ?? CultureInfo.InvariantCulture;
			this.style = style;
			this.dateStyle = dateStyle;
			this.formats = formats.DefaultIfEmpty("O").ToArray();
		}

		public bool Accepts(Type type)
		{
			return type == typeof(DateTimeOffset);
		}

		public object ReadYaml(IParser parser, Type type)
		{
			return DateTimeOffset.ParseExact(parser.Consume<YamlDotNet.Core.Events.Scalar>().Value, formats, provider, dateStyle);
		}

		public void WriteYaml(IEmitter emitter, object? value, Type type)
		{
			string value2 = ((DateTimeOffset)value).ToString(formats.First(), provider);
			emitter.Emit(new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, TagName.Empty, value2, style, isPlainImplicit: true, isQuotedImplicit: false));
		}
	}
	internal class GuidConverter : IYamlTypeConverter
	{
		private readonly bool jsonCompatible;

		public GuidConverter(bool jsonCompatible)
		{
			this.jsonCompatible = jsonCompatible;
		}

		public bool Accepts(Type type)
		{
			return type == typeof(Guid);
		}

		public object ReadYaml(IParser parser, Type type)
		{
			return new Guid(parser.Consume<YamlDotNet.Core.Events.Scalar>().Value);
		}

		public void WriteYaml(IEmitter emitter, object? value, Type type)
		{
			Guid guid = (Guid)value;
			emitter.Emit(new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, TagName.Empty, guid.ToString("D"), jsonCompatible ? ScalarStyle.DoubleQuoted : ScalarStyle.Any, isPlainImplicit: true, isQuotedImplicit: false));
		}
	}
	internal class SystemTypeConverter : IYamlTypeConverter
	{
		public bool Accepts(Type type)
		{
			return typeof(Type).IsAssignableFrom(type);
		}

		public object ReadYaml(IParser parser, Type type)
		{
			return Type.GetType(parser.Consume<YamlDotNet.Core.Events.Scalar>().Value, throwOnError: true);
		}

		public void WriteYaml(IEmitter emitter, object? value, Type type)
		{
			Type type2 = (Type)value;
			emitter.Emit(new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, TagName.Empty, type2.AssemblyQualifiedName, ScalarStyle.Any, isPlainImplicit: true, isQuotedImplicit: false));
		}
	}
}
namespace YamlDotNet.Serialization.Callbacks
{
	[AttributeUsage(AttributeTargets.Method)]
	internal sealed class OnDeserializedAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method)]
	internal sealed class OnDeserializingAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method)]
	internal sealed class OnSerializedAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method)]
	internal sealed class OnSerializingAttribute : Attribute
	{
	}
}
namespace YamlDotNet.Serialization.BufferedDeserialization
{
	internal interface ITypeDiscriminatingNodeDeserializerOptions
	{
		void AddTypeDiscriminator(ITypeDiscriminator discriminator);

		void AddKeyValueTypeDiscriminator<T>(string discriminatorKey, IDictionary<string, Type> valueTypeMapping);

		void AddUniqueKeyTypeDiscriminator<T>(IDictionary<string, Type> uniqueKeyTypeMapping);
	}
	internal class ParserBuffer : IParser
	{
		private readonly LinkedList<ParsingEvent> buffer;

		private LinkedListNode<ParsingEvent>? current;

		public ParsingEvent? Current => current?.Value;

		public ParserBuffer(IParser parserToBuffer, int maxDepth, int maxLength)
		{
			buffer = new LinkedList<ParsingEvent>();
			buffer.AddLast(parserToBuffer.Consume<MappingStart>());
			int num = 0;
			do
			{
				ParsingEvent parsingEvent = parserToBuffer.Consume<ParsingEvent>();
				num += parsingEvent.NestingIncrease;
				buffer.AddLast(parsingEvent);
				if (maxDepth > -1 && num > maxDepth)
				{
					throw new ArgumentOutOfRangeException("parserToBuffer", "Parser buffer exceeded max depth");
				}
				if (maxLength > -1 && buffer.Count > maxLength)
				{
					throw new ArgumentOutOfRangeException("parserToBuffer", "Parser buffer exceeded max length");
				}
			}
			while (num >= 0);
			current = buffer.First;
		}

		public bool MoveNext()
		{
			current = current?.Next;
			return current != null;
		}

		public void Reset()
		{
			current = buffer.First;
		}
	}
	internal class TypeDiscriminatingNodeDeserializer : INodeDeserializer
	{
		private readonly IList<INodeDeserializer> innerDeserializers;

		private readonly IList<ITypeDiscriminator> typeDiscriminators;

		private readonly int maxDepthToBuffer;

		private readonly int maxLengthToBuffer;

		public TypeDiscriminatingNodeDeserializer(IList<INodeDeserializer> innerDeserializers, IList<ITypeDiscriminator> typeDiscriminators, int maxDepthToBuffer, int maxLengthToBuffer)
		{
			this.innerDeserializers = innerDeserializers;
			this.typeDiscriminators = typeDiscriminators;
			this.maxDepthToBuffer = maxDepthToBuffer;
			this.maxLengthToBuffer = maxLengthToBuffer;
		}

		public bool Deserialize(IParser reader, Type expectedType, Func<IParser, Type, object?> nestedObjectDeserializer, out object? value)
		{
			Type expectedType2 = expectedType;
			if (!reader.Accept<MappingStart>(out var _))
			{
				value = null;
				return false;
			}
			IEnumerable<ITypeDiscriminator> enumerable = typeDiscriminators.Where((ITypeDiscriminator t) => t.BaseType.IsAssignableFrom(expectedType2));
			if (!enumerable.Any())
			{
				value = null;
				return false;
			}
			Mark start = reader.Current.Start;
			Type expectedType3 = expectedType2;
			ParserBuffer parserBuffer;
			try
			{
				parserBuffer = new ParserBuffer(reader, maxDepthToBuffer, maxLengthToBuffer);
			}
			catch (Exception innerException)
			{
				Mark end = reader.Current.End;
				throw new YamlException(in start, in end, "Failed to buffer yaml node", innerException);
			}
			try
			{
				foreach (ITypeDiscriminator item in enumerable)
				{
					parserBuffer.Reset();
					if (item.TryDiscriminate(parserBuffer, out Type suggestedType))
					{
						expectedType3 = suggestedType;
						break;
					}
				}
			}
			catch (Exception innerException2)
			{
				Mark end = reader.Current.End;
				throw new YamlException(in start, in end, "Failed to discriminate type", innerException2);
			}
			parserBuffer.Reset();
			foreach (INodeDeserializer innerDeserializer in innerDeserializers)
			{
				if (innerDeserializer.Deserialize(parserBuffer, expectedType3, nestedObjectDeserializer, out value))
				{
					return true;
				}
			}
			value = null;
			return false;
		}
	}
	internal class TypeDiscriminatingNodeDeserializerOptions : ITypeDiscriminatingNodeDeserializerOptions
	{
		internal readonly List<ITypeDiscriminator> discriminators = new List<ITypeDiscriminator>();

		public void AddTypeDiscriminator(ITypeDiscriminator discriminator)
		{
			discriminators.Add(discriminator);
		}

		public void AddKeyValueTypeDiscriminator<T>(string discriminatorKey, IDictionary<string, Type> valueTypeMapping)
		{
			discriminators.Add(new KeyValueTypeDiscriminator(typeof(T), discriminatorKey, valueTypeMapping));
		}

		public void AddUniqueKeyTypeDiscriminator<T>(IDictionary<string, Type> uniqueKeyTypeMapping)
		{
			discriminators.Add(new UniqueKeyTypeDiscriminator(typeof(T), uniqueKeyTypeMapping));
		}
	}
}
namespace YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminators
{
	internal interface ITypeDiscriminator
	{
		Type BaseType { get; }

		bool TryDiscriminate(IParser buffer, out Type? suggestedType);
	}
	internal class KeyValueTypeDiscriminator : ITypeDiscriminator
	{
		private readonly string targetKey;

		private readonly IDictionary<string, Type> typeMapping;

		public Type BaseType { get; private set; }

		public KeyValueTypeDiscriminator(Type baseType, string targetKey, IDictionary<string, Type> typeMapping)
		{
			foreach (KeyValuePair<string, Type> item in typeMapping)
			{
				if (!baseType.IsAssignableFrom(item.Value))
				{
					throw new ArgumentOutOfRangeException("typeMapping", $"{item.Value} is not a assignable to {baseType}");
				}
			}
			BaseType = baseType;
			this.targetKey = targetKey;
			this.typeMapping = typeMapping;
		}

		public bool TryDiscriminate(IParser parser, out Type? suggestedType)
		{
			if (parser.TryFindMappingEntry((YamlDotNet.Core.Events.Scalar scalar) => targetKey == scalar.Value, out YamlDotNet.Core.Events.Scalar _, out ParsingEvent value) && value is YamlDotNet.Core.Events.Scalar scalar2 && typeMapping.TryGetValue(scalar2.Value, out Type value2))
			{
				suggestedType = value2;
				return true;
			}
			suggestedType = null;
			return false;
		}
	}
	internal class UniqueKeyTypeDiscriminator : ITypeDiscriminator
	{
		private readonly IDictionary<string, Type> typeMapping;

		public Type BaseType { get; private set; }

		public UniqueKeyTypeDiscriminator(Type baseType, IDictionary<string, Type> typeMapping)
		{
			foreach (KeyValuePair<string, Type> item in typeMapping)
			{
				if (!baseType.IsAssignableFrom(item.Value))
				{
					throw new ArgumentOutOfRangeException("typeMapping", $"{item.Value} is not a assignable to {baseType}");
				}
			}
			BaseType = baseType;
			this.typeMapping = typeMapping;
		}

		public bool TryDiscriminate(IParser parser, out Type? suggestedType)
		{
			if (parser.TryFindMappingEntry((YamlDotNet.Core.Events.Scalar scalar) => typeMapping.ContainsKey(scalar.Value), out YamlDotNet.Core.Events.Scalar key, out ParsingEvent _))
			{
				suggestedType = typeMapping[key.Value];
				return true;
			}
			suggestedType = null;
			return false;
		}
	}
}
namespace YamlDotNet.RepresentationModel
{
	internal class DocumentLoadingState
	{
		private readonly IDictionary<AnchorName, YamlNode> anchors = new Dictionary<AnchorName, YamlNode>();

		private readonly IList<YamlNode> nodesWithUnresolvedAliases = new List<YamlNode>();

		public void AddAnchor(YamlNode node)
		{
			if (node.Anchor.IsEmpty)
			{
				throw new ArgumentException("The specified node does not have an anchor");
			}
			if (anchors.ContainsKey(node.Anchor))
			{
				anchors[node.Anchor] = node;
			}
			else
			{
				anchors.Add(node.Anchor, node);
			}
		}

		public YamlNode GetNode(AnchorName anchor, Mark start, Mark end)
		{
			if (anchors.TryGetValue(anchor, out YamlNode value))
			{
				return value;
			}
			throw new AnchorNotFoundException(in start, in end, $"The anchor '{anchor}' does not exists");
		}

		public bool TryGetNode(AnchorName anchor, [NotNullWhen(true)] out YamlNode? node)
		{
			return anchors.TryGetValue(anchor, out node);
		}

		public void AddNodeWithUnresolvedAliases(YamlNode node)
		{
			nodesWithUnresolvedAliases.Add(node);
		}

		public void ResolveAliases()
		{
			foreach (YamlNode nodesWithUnresolvedAlias in nodesWithUnresolvedAliases)
			{
				nodesWithUnresolvedAlias.ResolveAliases(this);
			}
		}
	}
	internal class EmitterState
	{
		public HashSet<AnchorName> EmittedAnchors { get; } = new HashSet<AnchorName>();

	}
	internal interface IYamlVisitor
	{
		void Visit(YamlStream stream);

		void Visit(YamlDocument document);

		void Visit(YamlScalarNode scalar);

		void Visit(YamlSequenceNode sequence);

		void Visit(YamlMappingNode mapping);
	}
	internal class LibYamlEventStream
	{
		private readonly IParser parser;

		public LibYamlEventStream(IParser iParser)
		{
			parser = iParser ?? throw new ArgumentNullException("iParser");
		}

		public void WriteTo(TextWriter textWriter)
		{
			while (parser.MoveNext())
			{
				ParsingEvent current = parser.Current;
				if (!(current is YamlDotNet.Core.Events.AnchorAlias anchorAlias))
				{
					if (!(current is YamlDotNet.Core.Events.DocumentEnd documentEnd))
					{
						if (!(current is YamlDotNet.Core.Events.DocumentStart documentStart))
						{
							if (!(current is MappingEnd))
							{
								if (!(current is MappingStart nodeEvent))
								{
									if (!(current is YamlDotNet.Core.Events.Scalar scalar))
									{
										if (!(current is SequenceEnd))
										{
											if (!(current is SequenceStart nodeEvent2))
											{
												if (!(current is YamlDotNet.Core.Events.StreamEnd))
												{
													if (current is YamlDotNet.Core.Events.StreamStart)
													{
														textWriter.Write("+STR");
													}
												}
												else
												{
													textWriter.Write("-STR");
												}
											}
											else
											{
												textWriter.Write("+SEQ");
												WriteAnchorAndTag(textWriter, nodeEvent2);
											}
										}
										else
										{
											textWriter.Write("-SEQ");
										}
									}
									else
									{
										textWriter.Write("=VAL");
										WriteAnchorAndTag(textWriter, scalar);
										switch (scalar.Style)
										{
										case ScalarStyle.DoubleQuoted:
											textWriter.Write(" \"");
											break;
										case ScalarStyle.SingleQuoted:
											textWriter.Write(" '");
											break;
										case ScalarStyle.Folded:
											textWriter.Write(" >");
											break;
										case ScalarStyle.Literal:
											textWriter.Write(" |");
											break;
										default:
											textWriter.Write(" :");
											break;
										}
										string value = scalar.Value;
										foreach (char c in value)
										{
											switch (c)
											{
											case '\b':
												textWriter.Write("\\b");
												break;
											case '\t':
												textWriter.Write("\\t");
												break;
											case '\n':
												textWriter.Write("\\n");
												break;
											case '\r':
												textWriter.Write("\\r");
												break;
											case '\\':
												textWriter.Write("\\\\");
												break;
											default:
												textWriter.Write(c);
												break;
											}
										}
									}
								}
								else
								{
									textWriter.Write("+MAP");
									WriteAnchorAndTag(textWriter, nodeEvent);
								}
							}
							else
							{
								textWriter.Write("-MAP");
							}
						}
						else
						{
							textWriter.Write("+DOC");
							if (!documentStart.IsImplicit)
							{
								textWriter.Write(" ---");
							}
						}
					}
					else
					{
						textWriter.Write("-DOC");
						if (!documentEnd.IsImplicit)
						{
							textWriter.Write(" ...");
						}
					}
				}
				else
				{
					textWriter.Write("=ALI *");
					textWriter.Write(anchorAlias.Value);
				}
				textWriter.WriteLine();
			}
		}

		private void WriteAnchorAndTag(TextWriter textWriter, NodeEvent nodeEvent)
		{
			if (!nodeEvent.Anchor.IsEmpty)
			{
				textWriter.Write(" &");
				textWriter.Write(nodeEvent.Anchor);
			}
			if (!nodeEvent.Tag.IsEmpty)
			{
				textWriter.Write(" <");
				textWriter.Write(nodeEvent.Tag.Value);
				textWriter.Write(">");
			}
		}
	}
	internal class YamlAliasNode : YamlNode
	{
		public override YamlNodeType NodeType => YamlNodeType.Alias;

		internal YamlAliasNode(AnchorName anchor)
		{
			base.Anchor = anchor;
		}

		internal override void ResolveAliases(DocumentLoadingState state)
		{
			throw new NotSupportedException("Resolving an alias on an alias node does not make sense");
		}

		internal override void Emit(IEmitter emitter, EmitterState state)
		{
			throw new NotSupportedException("A YamlAliasNode is an implementation detail and should never be saved.");
		}

		public override void Accept(IYamlVisitor visitor)
		{
			throw new NotSupportedException("A YamlAliasNode is an implementation detail and should never be visited.");
		}

		public override bool Equals(object? obj)
		{
			if (obj is YamlAliasNode yamlAliasNode && Equals(yamlAliasNode))
			{
				return object.Equals(base.Anchor, yamlAliasNode.Anchor);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal override string ToString(RecursionLevel level)
		{
			return "*" + base.Anchor.ToString();
		}

		internal override IEnumerable<YamlNode> SafeAllNodes(RecursionLevel level)
		{
			yield return this;
		}
	}
	internal class YamlDocument
	{
		private class AnchorAssigningVisitor : YamlVisitorBase
		{
			private readonly HashSet<AnchorName> existingAnchors = new HashSet<AnchorName>();

			private readonly Dictionary<YamlNode, bool> visitedNodes = new Dictionary<YamlNode, bool>();

			public void AssignAnchors(YamlDocument document)
			{
				existingAnchors.Clear();
				visitedNodes.Clear();
				document.Accept(this);
				Random random = new Random();
				foreach (KeyValuePair<YamlNode, bool> visitedNode in visitedNodes)
				{
					if (!visitedNode.Value)
					{
						continue;
					}
					AnchorName anchorName;
					if (!visitedNode.Key.Anchor.IsEmpty && !existingAnchors.Contains(visitedNode.Key.Anchor))
					{
						anchorName = visitedNode.Key.Anchor;
					}
					else
					{
						do
						{
							anchorName = new AnchorName(random.Next().ToString(CultureInfo.InvariantCulture));
						}
						while (existingAnchors.Contains(anchorName));
					}
					existingAnchors.Add(anchorName);
					visitedNode.Key.Anchor = anchorName;
				}
			}

			private bool VisitNodeAndFindDuplicates(YamlNode node)
			{
				if (visitedNodes.TryGetValue(node, out var value))
				{
					if (!value)
					{
						visitedNodes[node] = true;
					}
					return !value;
				}
				visitedNodes.Add(node, value: false);
				return false;
			}

			public override void Visit(YamlScalarNode scalar)
			{
				VisitNodeAndFindDuplicates(scalar);
			}

			public override void Visit(YamlMappingNode mapping)
			{
				if (!VisitNodeAndFindDuplicates(mapping))
				{
					base.Visit(mapping);
				}
			}

			public override void Visit(YamlSequenceNode sequence)
			{
				if (!VisitNodeAndFindDuplicates(sequence))
				{
					base.Visit(sequence);
				}
			}
		}

		public YamlNode RootNode { get; private set; }

		public IEnumerable<YamlNode> AllNodes => RootNode.AllNodes;

		public YamlDocument(YamlNode rootNode)
		{
			RootNode = rootNode;
		}

		public YamlDocument(string rootNode)
		{
			RootNode = new YamlScalarNode(rootNode);
		}

		internal YamlDocument(IParser parser)
		{
			DocumentLoadingState documentLoadingState = new DocumentLoadingState();
			parser.Consume<YamlDotNet.Core.Events.DocumentStart>();
			YamlDotNet.Core.Events.DocumentEnd @event;
			while (!parser.TryConsume<YamlDotNet.Core.Events.DocumentEnd>(out @event))
			{
				RootNode = YamlNode.ParseNode(parser, documentLoadingState);
				if (RootNode is YamlAliasNode)
				{
					throw new YamlException("A document cannot contain only an alias");
				}
			}
			documentLoadingState.ResolveAliases();
			if (RootNode == null)
			{
				throw new ArgumentException("Atempted to parse an empty document");
			}
		}

		private void AssignAnchors()
		{
			new AnchorAssigningVisitor().AssignAnchors(this);
		}

		internal void Save(IEmitter emitter, bool assignAnchors = true)
		{
			if (assignAnchors)
			{
				AssignAnchors();
			}
			emitter.Emit(new YamlDotNet.Core.Events.DocumentStart());
			RootNode.Save(emitter, new EmitterState());
			emitter.Emit(new YamlDotNet.Core.Events.DocumentEnd(isImplicit: false));
		}

		public void Accept(IYamlVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class YamlMappingNode : YamlNode, IEnumerable<KeyValuePair<YamlNode, YamlNode>>, IEnumerable, IYamlConvertible
	{
		private readonly OrderedDictionary<YamlNode, YamlNode> children = new OrderedDictionary<YamlNode, YamlNode>();

		public IOrderedDictionary<YamlNode, YamlNode> Children => children;

		public MappingStyle Style { get; set; }

		public override YamlNodeType NodeType => YamlNodeType.Mapping;

		internal YamlMappingNode(IParser parser, DocumentLoadingState state)
		{
			Load(parser, state);
		}

		private void Load(IParser parser, DocumentLoadingState state)
		{
			MappingStart mappingStart = parser.Consume<MappingStart>();
			Load(mappingStart, state);
			Style = mappingStart.Style;
			bool flag = false;
			MappingEnd @event;
			while (!parser.TryConsume<MappingEnd>(out @event))
			{
				YamlNode yamlNode = YamlNode.ParseNode(parser, state);
				YamlNode yamlNode2 = YamlNode.ParseNode(parser, state);
				try
				{
					children.Add(yamlNode, yamlNode2);
				}
				catch (ArgumentException innerException)
				{
					Mark start = yamlNode.Start;
					Mark end = yamlNode.End;
					throw new YamlException(in start, in end, "Duplicate key", innerException);
				}
				flag = flag || yamlNode is YamlAliasNode || yamlNode2 is YamlAliasNode;
			}
			if (flag)
			{
				state.AddNodeWithUnresolvedAliases(this);
			}
		}

		public YamlMappingNode()
		{
		}

		public YamlMappingNode(params KeyValuePair<YamlNode, YamlNode>[] children)
			: this((IEnumerable<KeyValuePair<YamlNode, YamlNode>>)children)
		{
		}

		public YamlMappingNode(IEnumerable<KeyValuePair<YamlNode, YamlNode>> children)
		{
			foreach (KeyValuePair<YamlNode, YamlNode> child in children)
			{
				this.children.Add(child);
			}
		}

		public YamlMappingNode(params YamlNode[] children)
			: this((IEnumerable<YamlNode>)children)
		{
		}

		public YamlMappingNode(IEnumerable<YamlNode> children)
		{
			using IEnumerator<YamlNode> enumerator = children.GetEnumerator();
			while (enumerator.MoveNext())
			{
				YamlNode current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					throw new ArgumentException("When constructing a mapping node with a sequence, the number of elements of the sequence must be even.");
				}
				Add(current, enumerator.Current);
			}
		}

		public void Add(YamlNode key, YamlNode value)
		{
			children.Add(key, value);
		}

		public void Add(string key, YamlNode value)
		{
			children.Add(new YamlScalarNode(key), value);
		}

		public void Add(YamlNode key, string value)
		{
			children.Add(key, new YamlScalarNode(value));
		}

		public void Add(string key, string value)
		{
			children.Add(new YamlScalarNode(key), new YamlScalarNode(value));
		}

		internal override void ResolveAliases(DocumentLoadingState state)
		{
			Dictionary<YamlNode, YamlNode> dictionary = null;
			Dictionary<YamlNode, YamlNode> dictionary2 = null;
			foreach (KeyValuePair<YamlNode, YamlNode> child in children)
			{
				if (child.Key is YamlAliasNode)
				{
					if (dictionary == null)
					{
						dictionary = new Dictionary<YamlNode, YamlNode>();
					}
					dictionary.Add(child.Key, state.GetNode(child.Key.Anchor, child.Key.Start, child.Key.End));
				}
				if (child.Value is YamlAliasNode)
				{
					if (dictionary2 == null)
					{
						dictionary2 = new Dictionary<YamlNode, YamlNode>();
					}
					dictionary2.Add(child.Key, state.GetNode(child.Value.Anchor, child.Value.Start, child.Value.End));
				}
			}
			if (dictionary2 != null)
			{
				foreach (KeyValuePair<YamlNode, YamlNode> item in dictionary2)
				{
					children[item.Key] = item.Value;
				}
			}
			if (dictionary == null)
			{
				return;
			}
			foreach (KeyValuePair<YamlNode, YamlNode> item2 in dictionary)
			{
				YamlNode value = children[item2.Key];
				children.Remove(item2.Key);
				children.Add(item2.Value, value);
			}
		}

		internal override void Emit(IEmitter emitter, EmitterState state)
		{
			emitter.Emit(new MappingStart(base.Anchor, base.Tag, isImplicit: true, Style));
			foreach (KeyValuePair<YamlNode, YamlNode> child in children)
			{
				child.Key.Save(emitter, state);
				child.Value.Save(emitter, state);
			}
			emitter.Emit(new MappingEnd());
		}

		public override void Accept(IYamlVisitor visitor)
		{
			visitor.Visit(this);
		}

		public override bool Equals(object? obj)
		{
			if (!(obj is YamlMappingNode yamlMappingNode) || !object.Equals(base.Tag, yamlMappingNode.Tag) || children.Count != yamlMappingNode.children.Count)
			{
				return false;
			}
			foreach (KeyValuePair<YamlNode, YamlNode> child in children)
			{
				if (!yamlMappingNode.children.TryGetValue(child.Key, out YamlNode value) || !object.Equals(child.Value, value))
				{
					return false;
				}
			}
			return true;
		}

		public override int GetHashCode()
		{
			int num = base.GetHashCode();
			foreach (KeyValuePair<YamlNode, YamlNode> child in children)
			{
				num = YamlDotNet.Core.HashCode.CombineHashCodes(num, child.Key);
				num = YamlDotNet.Core.HashCode.CombineHashCodes(num, child.Value);
			}
			return num;
		}

		internal override IEnumerable<YamlNode> SafeAllNodes(RecursionLevel level)
		{
			level.Increment();
			yield return this;
			foreach (KeyValuePair<YamlNode, YamlNode> child in children)
			{
				foreach (YamlNode item in child.Key.SafeAllNodes(level))
				{
					yield return item;
				}
				foreach (YamlNode item2 in child.Value.SafeAllNodes(level))
				{
					yield return item2;
				}
			}
			level.Decrement();
		}

		internal override string ToString(RecursionLevel level)
		{
			if (!level.TryIncrement())
			{
				return "WARNING! INFINITE RECURSION!";
			}
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				builder.Append("{ ");
				foreach (KeyValuePair<YamlNode, YamlNode> child in children)
				{
					if (builder.Length > 2)
					{
						builder.Append(", ");
					}
					builder.Append("{ ").Append(child.Key.ToString(level)).Append(", ")
						.Append(child.Value.ToString(level))
						.Append(" }");
				}
				builder.Append(" }");
				level.Decrement();
				return builder.ToString();
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		public IEnumerator<KeyValuePair<YamlNode, YamlNode>> GetEnumerator()
		{
			return children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer)
		{
			Load(parser, new DocumentLoadingState());
		}

		void IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer)
		{
			Emit(emitter, new EmitterState());
		}

		public static YamlMappingNode FromObject(object mapping)
		{
			if (mapping == null)
			{
				throw new ArgumentNullException("mapping");
			}
			YamlMappingNode yamlMappingNode = new YamlMappingNode();
			foreach (PropertyInfo publicProperty in mapping.GetType().GetPublicProperties())
			{
				if (publicProperty.CanRead && publicProperty.GetGetMethod(nonPublic: false).GetParameters().Length == 0)
				{
					object value = publicProperty.GetValue(mapping, null);
					YamlNode yamlNode = value as YamlNode;
					if (yamlNode == null)
					{
						yamlNode = Convert.ToString(value) ?? string.Empty;
					}
					yamlMappingNode.Add(publicProperty.Name, yamlNode);
				}
			}
			return yamlMappingNode;
		}
	}
	internal abstract class YamlNode
	{
		private const int MaximumRecursionLevel = 1000;

		internal const string MaximumRecursionLevelReachedToStringValue = "WARNING! INFINITE RECURSION!";

		public AnchorName Anchor { get; set; }

		public TagName Tag { get; set; }

		public Mark Start { get; private set; } = Mark.Empty;


		public Mark End { get; private set; } = Mark.Empty;


		public IEnumerable<YamlNode> AllNodes
		{
			get
			{
				RecursionLevel level = new RecursionLevel(1000);
				return SafeAllNodes(level);
			}
		}

		public abstract YamlNodeType NodeType { get; }

		public YamlNode this[int index]
		{
			get
			{
				if (!(this is YamlSequenceNode yamlSequenceNode))
				{
					throw new ArgumentException($"Accessed '{NodeType}' with an invalid index: {index}. Only Sequences can be indexed by number.");
				}
				return yamlSequenceNode.Children[index];
			}
		}

		public YamlNode this[YamlNode key]
		{
			get
			{
				if (!(this is YamlMappingNode yamlMappingNode))
				{
					throw new ArgumentException($"Accessed '{NodeType}' with an invalid index: {key}. Only Mappings can be indexed by key.");
				}
				return yamlMappingNode.Children[key];
			}
		}

		internal void Load(NodeEvent yamlEvent, DocumentLoadingState state)
		{
			Tag = yamlEvent.Tag;
			if (!yamlEvent.Anchor.IsEmpty)
			{
				Anchor = yamlEvent.Anchor;
				state.AddAnchor(this);
			}
			Start = yamlEvent.Start;
			End = yamlEvent.End;
		}

		internal static YamlNode ParseNode(IParser parser, DocumentLoadingState state)
		{
			if (parser.Accept<YamlDotNet.Core.Events.Scalar>(out var _))
			{
				return new YamlScalarNode(parser, state);
			}
			if (parser.Accept<SequenceStart>(out var _))
			{
				return new YamlSequenceNode(parser, state);
			}
			if (parser.Accept<MappingStart>(out var _))
			{
				return new YamlMappingNode(parser, state);
			}
			if (parser.TryConsume<YamlDotNet.Core.Events.AnchorAlias>(out var event4))
			{
				if (!state.TryGetNode(event4.Value, out YamlNode node))
				{
					return new YamlAliasNode(event4.Value);
				}
				return node;
			}
			throw new ArgumentException("The current event is of an unsupported type.", "parser");
		}

		internal abstract void ResolveAliases(DocumentLoadingState state);

		internal void Save(IEmitter emitter, EmitterState state)
		{
			if (!Anchor.IsEmpty && !state.EmittedAnchors.Add(Anchor))
			{
				emitter.Emit(new YamlDotNet.Core.Events.AnchorAlias(Anchor));
			}
			else
			{
				Emit(emitter, state);
			}
		}

		internal abstract void Emit(IEmitter emitter, EmitterState state);

		public abstract void Accept(IYamlVisitor visitor);

		public override string ToString()
		{
			RecursionLevel recursionLevel = new RecursionLevel(1000);
			return ToString(recursionLevel);
		}

		internal abstract string ToString(RecursionLevel level);

		internal abstract IEnumerable<YamlNode> SafeAllNodes(RecursionLevel level);

		public static implicit operator YamlNode(string value)
		{
			return new YamlScalarNode(value);
		}

		public static implicit operator YamlNode(string[] sequence)
		{
			return new YamlSequenceNode(((IEnumerable<string>)sequence).Select((Func<string, YamlNode>)((string i) => i)));
		}

		public static explicit operator string?(YamlNode node)
		{
			if (!(node is YamlScalarNode yamlScalarNode))
			{
				throw new ArgumentException($"Attempted to convert a '{node.NodeType}' to string. This conversion is valid only for Scalars.");
			}
			return yamlScalarNode.Value;
		}
	}
	internal sealed class YamlNodeIdentityEqualityComparer : IEqualityComparer<YamlNode>
	{
		public bool Equals([AllowNull] YamlNode x, [AllowNull] YamlNode y)
		{
			return x == y;
		}

		public int GetHashCode(YamlNode obj)
		{
			return obj.GetHashCode();
		}
	}
	internal enum YamlNodeType
	{
		Alias,
		Mapping,
		Scalar,
		Sequence
	}
	[DebuggerDisplay("{Value}")]
	internal sealed class YamlScalarNode : YamlNode, IYamlConvertible
	{
		private bool _forceImplicitPlain;

		private string? _value;

		public string? Value
		{
			get
			{
				return _value;
			}
			set
			{
				if (value == null)
				{
					_forceImplicitPlain = true;
				}
				else
				{
					_forceImplicitPlain = false;
				}
				_value = value;
			}
		}

		public ScalarStyle Style { get; set; }

		public override YamlNodeType NodeType => YamlNodeType.Scalar;

		internal YamlScalarNode(IParser parser, DocumentLoadingState state)
		{
			Load(parser, state);
		}

		private void Load(IParser parser, DocumentLoadingState state)
		{
			YamlDotNet.Core.Events.Scalar scalar = parser.Consume<YamlDotNet.Core.Events.Scalar>();
			Load(scalar, state);
			if (scalar.Style == ScalarStyle.Plain && base.Tag.IsEmpty && (scalar.Value == string.Empty || scalar.Value.Equals("null", StringComparison.InvariantCulture) || scalar.Value.Equals("Null", StringComparison.InvariantCulture) || scalar.Value.Equals("NULL", StringComparison.InvariantCulture) || scalar.Value == "~"))
			{
				_forceImplicitPlain = true;
			}
			_value = scalar.Value;
			Style = scalar.Style;
		}

		public YamlScalarNode()
		{
		}

		public YamlScalarNode(string? value)
		{
			Value = value;
		}

		internal override void ResolveAliases(DocumentLoadingState state)
		{
			throw new NotSupportedException("Resolving an alias on a scalar node does not make sense");
		}

		internal override void Emit(IEmitter emitter, EmitterState state)
		{
			TagName tag = base.Tag;
			bool isPlainImplicit = tag.IsEmpty;
			if (_forceImplicitPlain && Style == ScalarStyle.Plain && (Value == null || Value == ""))
			{
				tag = JsonSchema.Tags.Null;
				isPlainImplicit = true;
			}
			else if (tag.IsEmpty && Value == null && (Style == ScalarStyle.Plain || Style == ScalarStyle.Any))
			{
				tag = JsonSchema.Tags.Null;
				isPlainImplicit = true;
			}
			emitter.Emit(new YamlDotNet.Core.Events.Scalar(base.Anchor, tag, Value ?? string.Empty, Style, isPlainImplicit, isQuotedImplicit: false));
		}

		public override void Accept(IYamlVisitor visitor)
		{
			visitor.Visit(this);
		}

		public override bool Equals(object? obj)
		{
			if (obj is YamlScalarNode yamlScalarNode && object.Equals(base.Tag, yamlScalarNode.Tag))
			{
				return object.Equals(Value, yamlScalarNode.Value);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return YamlDotNet.Core.HashCode.CombineHashCodes(base.Tag.GetHashCode(), Value);
		}

		public static explicit operator string?(YamlScalarNode value)
		{
			return value.Value;
		}

		internal override string ToString(RecursionLevel level)
		{
			return Value ?? string.Empty;
		}

		internal override IEnumerable<YamlNode> SafeAllNodes(RecursionLevel level)
		{
			yield return this;
		}

		void IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer)
		{
			Load(parser, new DocumentLoadingState());
		}

		void IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer)
		{
			Emit(emitter, new EmitterState());
		}
	}
	[DebuggerDisplay("Count = {children.Count}")]
	internal sealed class YamlSequenceNode : YamlNode, IEnumerable<YamlNode>, IEnumerable, IYamlConvertible
	{
		private readonly IList<YamlNode> children = new List<YamlNode>();

		public IList<YamlNode> Children => children;

		public SequenceStyle Style { get; set; }

		public override YamlNodeType NodeType => YamlNodeType.Sequence;

		internal YamlSequenceNode(IParser parser, DocumentLoadingState state)
		{
			Load(parser, state);
		}

		private void Load(IParser parser, DocumentLoadingState state)
		{
			SequenceStart sequenceStart = parser.Consume<SequenceStart>();
			Load(sequenceStart, state);
			Style = sequenceStart.Style;
			bool flag = false;
			SequenceEnd @event;
			while (!parser.TryConsume<SequenceEnd>(out @event))
			{
				YamlNode yamlNode = YamlNode.ParseNode(parser, state);
				children.Add(yamlNode);
				flag = flag || yamlNode is YamlAliasNode;
			}
			if (flag)
			{
				state.AddNodeWithUnresolvedAliases(this);
			}
		}

		public YamlSequenceNode()
		{
		}

		public YamlSequenceNode(params YamlNode[] children)
			: this((IEnumerable<YamlNode>)children)
		{
		}

		public YamlSequenceNode(IEnumerable<YamlNode> children)
		{
			foreach (YamlNode child in children)
			{
				this.children.Add(child);
			}
		}

		public void Add(YamlNode child)
		{
			children.Add(child);
		}

		public void Add(string child)
		{
			children.Add(new YamlScalarNode(child));
		}

		internal override void ResolveAliases(DocumentLoadingState state)
		{
			for (int i = 0; i < children.Count; i++)
			{
				if (children[i] is YamlAliasNode)
				{
					children[i] = state.GetNode(children[i].Anchor, children[i].Start, children[i].End);
				}
			}
		}

		internal override void Emit(IEmitter emitter, EmitterState state)
		{
			emitter.Emit(new SequenceStart(base.Anchor, base.Tag, base.Tag.IsEmpty, Style));
			foreach (YamlNode child in children)
			{
				child.Save(emitter, state);
			}
			emitter.Emit(new SequenceEnd());
		}

		public override void Accept(IYamlVisitor visitor)
		{
			visitor.Visit(this);
		}

		public override bool Equals(object? obj)
		{
			if (!(obj is YamlSequenceNode yamlSequenceNode) || !object.Equals(base.Tag, yamlSequenceNode.Tag) || children.Count != yamlSequenceNode.children.Count)
			{
				return false;
			}
			for (int i = 0; i < children.Count; i++)
			{
				if (!object.Equals(children[i], yamlSequenceNode.children[i]))
				{
					return false;
				}
			}
			return true;
		}

		public override int GetHashCode()
		{
			int h = 0;
			foreach (YamlNode child in children)
			{
				h = YamlDotNet.Core.HashCode.CombineHashCodes(h, child);
			}
			return YamlDotNet.Core.HashCode.CombineHashCodes(h, base.Tag);
		}

		internal override IEnumerable<YamlNode> SafeAllNodes(RecursionLevel level)
		{
			level.Increment();
			yield return this;
			foreach (YamlNode child in children)
			{
				foreach (YamlNode item in child.SafeAllNodes(level))
				{
					yield return item;
				}
			}
			level.Decrement();
		}

		internal override string ToString(RecursionLevel level)
		{
			if (!level.TryIncrement())
			{
				return "WARNING! INFINITE RECURSION!";
			}
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				builder.Append("[ ");
				foreach (YamlNode child in children)
				{
					if (builder.Length > 2)
					{
						builder.Append(", ");
					}
					builder.Append(child.ToString(level));
				}
				builder.Append(" ]");
				level.Decrement();
				return builder.ToString();
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		public IEnumerator<YamlNode> GetEnumerator()
		{
			return Children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer)
		{
			Load(parser, new DocumentLoadingState());
		}

		void IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer)
		{
			Emit(emitter, new EmitterState());
		}
	}
	internal class YamlStream : IEnumerable<YamlDocument>, IEnumerable
	{
		private readonly IList<YamlDocument> documents = new List<YamlDocument>();

		public IList<YamlDocument> Documents => documents;

		public YamlStream()
		{
		}

		public YamlStream(params YamlDocument[] documents)
			: this((IEnumerable<YamlDocument>)documents)
		{
		}

		public YamlStream(IEnumerable<YamlDocument> documents)
		{
			foreach (YamlDocument document in documents)
			{
				this.documents.Add(document);
			}
		}

		public void Add(YamlDocument document)
		{
			documents.Add(document);
		}

		public void Load(TextReader input)
		{
			Load(new Parser(input));
		}

		public void Load(IParser parser)
		{
			documents.Clear();
			parser.Consume<YamlDotNet.Core.Events.StreamStart>();
			YamlDotNet.Core.Events.StreamEnd @event;
			while (!parser.TryConsume<YamlDotNet.Core.Events.StreamEnd>(out @event))
			{
				YamlDocument item = new YamlDocument(parser);
				documents.Add(item);
			}
		}

		public void Save(TextWriter output)
		{
			Save(output, assignAnchors: true);
		}

		public void Save(TextWriter output, bool assignAnchors)
		{
			Save(new Emitter(output), assignAnchors);
		}

		public void Save(IEmitter emitter, bool assignAnchors)
		{
			emitter.Emit(new YamlDotNet.Core.Events.StreamStart());
			foreach (YamlDocument document in documents)
			{
				document.Save(emitter, assignAnchors);
			}
			emitter.Emit(new YamlDotNet.Core.Events.StreamEnd());
		}

		public void Accept(IYamlVisitor visitor)
		{
			visitor.Visit(this);
		}

		public IEnumerator<YamlDocument> GetEnumerator()
		{
			return documents.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	[Obsolete("Use YamlVisitorBase")]
	internal abstract class YamlVisitor : IYamlVisitor
	{
		protected virtual void Visit(YamlStream stream)
		{
		}

		protected virtual void Visited(YamlStream stream)
		{
		}

		protected virtual void Visit(YamlDocument document)
		{
		}

		protected virtual void Visited(YamlDocument document)
		{
		}

		protected virtual void Visit(YamlScalarNode scalar)
		{
		}

		protected virtual void Visited(YamlScalarNode scalar)
		{
		}

		protected virtual void Visit(YamlSequenceNode sequence)
		{
		}

		protected virtual void Visited(YamlSequenceNode sequence)
		{
		}

		protected virtual void Visit(YamlMappingNode mapping)
		{
		}

		protected virtual void Visited(YamlMappingNode mapping)
		{
		}

		protected virtual void VisitChildren(YamlStream stream)
		{
			foreach (YamlDocument document in stream.Documents)
			{
				document.Accept(this);
			}
		}

		protected virtual void VisitChildren(YamlDocument document)
		{
			if (document.RootNode != null)
			{
				document.RootNode.Accept(this);
			}
		}

		protected virtual void VisitChildren(YamlSequenceNode sequence)
		{
			foreach (YamlNode child in sequence.Children)
			{
				child.Accept(this);
			}
		}

		protected virtual void VisitChildren(YamlMappingNode mapping)
		{
			foreach (KeyValuePair<YamlNode, YamlNode> child in mapping.Children)
			{
				child.Key.Accept(this);
				child.Value.Accept(this);
			}
		}

		void IYamlVisitor.Visit(YamlStream stream)
		{
			Visit(stream);
			VisitChildren(stream);
			Visited(stream);
		}

		void IYamlVisitor.Visit(YamlDocument document)
		{
			Visit(document);
			VisitChildren(document);
			Visited(document);
		}

		void IYamlVisitor.Visit(YamlScalarNode scalar)
		{
			Visit(scalar);
			Visited(scalar);
		}

		void IYamlVisitor.Visit(YamlSequenceNode sequence)
		{
			Visit(sequence);
			VisitChildren(sequence);
			Visited(sequence);
		}

		void IYamlVisitor.Visit(YamlMappingNode mapping)
		{
			Visit(mapping);
			VisitChildren(mapping);
			Visited(mapping);
		}
	}
	internal abstract class YamlVisitorBase : IYamlVisitor
	{
		public virtual void Visit(YamlStream stream)
		{
			VisitChildren(stream);
		}

		public virtual void Visit(YamlDocument document)
		{
			VisitChildren(document);
		}

		public virtual void Visit(YamlScalarNode scalar)
		{
		}

		public virtual void Visit(YamlSequenceNode sequence)
		{
			VisitChildren(sequence);
		}

		public virtual void Visit(YamlMappingNode mapping)
		{
			VisitChildren(mapping);
		}

		protected virtual void VisitPair(YamlNode key, YamlNode value)
		{
			key.Accept(this);
			value.Accept(this);
		}

		protected virtual void VisitChildren(YamlStream stream)
		{
			foreach (YamlDocument document in stream.Documents)
			{
				document.Accept(this);
			}
		}

		protected virtual void VisitChildren(YamlDocument document)
		{
			if (document.RootNode != null)
			{
				document.RootNode.Accept(this);
			}
		}

		protected virtual void VisitChildren(YamlSequenceNode sequence)
		{
			foreach (YamlNode child in sequence.Children)
			{
				child.Accept(this);
			}
		}

		protected virtual void VisitChildren(YamlMappingNode mapping)
		{
			foreach (KeyValuePair<YamlNode, YamlNode> child in mapping.Children)
			{
				VisitPair(child.Key, child.Value);
			}
		}
	}
}
namespace YamlDotNet.Helpers
{
	[DebuggerStepThrough]
	internal sealed class ConcurrentObjectPool<T> where T : class
	{
		[DebuggerDisplay("{value,nq}")]
		private struct Element
		{
			internal T? value;
		}

		internal delegate T Factory();

		private T? firstItem;

		private readonly Element[] items;

		private readonly Factory factory;

		internal ConcurrentObjectPool(Factory factory)
			: this(factory, Environment.ProcessorCount * 2)
		{
		}

		internal ConcurrentObjectPool(Factory factory, int size)
		{
			this.factory = factory;
			items = new Element[size - 1];
		}

		private T CreateInstance()
		{
			return factory();
		}

		internal T Allocate()
		{
			T val = firstItem;
			if (val == null || val != Interlocked.CompareExchange(ref firstItem, null, val))
			{
				val = AllocateSlow();
			}
			return val;
		}

		private T AllocateSlow()
		{
			Element[] array = items;
			for (int i = 0; i < array.Length; i++)
			{
				T value = array[i].value;
				if (value != null && value == Interlocked.CompareExchange(ref array[i].value, null, value))
				{
					return value;
				}
			}
			return CreateInstance();
		}

		internal void Free(T obj)
		{
			if (firstItem == null)
			{
				firstItem = obj;
			}
			else
			{
				FreeSlow(obj);
			}
		}

		private void FreeSlow(T obj)
		{
			Element[] array = items;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].value == null)
				{
					array[i].value = obj;
					break;
				}
			}
		}

		[Conditional("DEBUG")]
		private void Validate(object obj)
		{
			Element[] array = items;
			for (int i = 0; i < array.Length && array[i].value != null; i++)
			{
			}
		}
	}
	internal static class ExpressionExtensions
	{
		public static PropertyInfo AsProperty(this LambdaExpression propertyAccessor)
		{
			PropertyInfo propertyInfo = TryGetMemberExpression<PropertyInfo>(propertyAccessor);
			if (propertyInfo == null)
			{
				throw new ArgumentException("Expected a lambda expression in the form: x => x.SomeProperty", "propertyAccessor");
			}
			return propertyInfo;
		}

		[return: MaybeNull]
		private static TMemberInfo TryGetMemberExpression<TMemberInfo>(LambdaExpression lambdaExpression) where TMemberInfo : MemberInfo
		{
			if (lambdaExpression.Parameters.Count != 1)
			{
				return null;
			}
			Expression expression = lambdaExpression.Body;
			if (expression is UnaryExpression unaryExpression)
			{
				if (unaryExpression.NodeType != ExpressionType.Convert)
				{
					return null;
				}
				expression = unaryExpression.Operand;
			}
			if (expression is MemberExpression memberExpression)
			{
				if (memberExpression.Expression != lambdaExpression.Parameters[0])
				{
					return null;
				}
				return memberExpression.Member as TMemberInfo;
			}
			return null;
		}
	}
	internal sealed class GenericCollectionToNonGenericAdapter<T> : IList, ICollection, IEnumerable
	{
		private readonly ICollection<T> genericCollection;

		public bool IsFixedSize
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public bool IsReadOnly
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public object? this[int index]
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				((IList<T>)genericCollection)[index] = (T)value;
			}
		}

		public int Count
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public bool IsSynchronized
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public object SyncRoot
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public GenericCollectionToNonGenericAdapter(ICollection<T> genericCollection)
		{
			this.genericCollection = genericCollection ?? throw new ArgumentNullException("genericCollection");
		}

		public int Add(object? value)
		{
			int count = genericCollection.Count;
			genericCollection.Add((T)value);
			return count;
		}

		public void Clear()
		{
			genericCollection.Clear();
		}

		public bool Contains(object? value)
		{
			throw new NotSupportedException();
		}

		public int IndexOf(object? value)
		{
			throw new NotSupportedException();
		}

		public void Insert(int index, object? value)
		{
			throw new NotSupportedException();
		}

		public void Remove(object? value)
		{
			throw new NotSupportedException();
		}

		public void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public void CopyTo(Array array, int index)
		{
			throw new NotSupportedException();
		}

		public IEnumerator GetEnumerator()
		{
			return genericCollection.GetEnumerator();
		}
	}
	internal sealed class GenericDictionaryToNonGenericAdapter<TKey, TValue> : IDictionary, ICollection, IEnumerable where TKey : notnull
	{
		private class DictionaryEnumerator : IDictionaryEnumerator, IEnumerator
		{
			private readonly IEnumerator<KeyValuePair<TKey, TValue>> enumerator;

			public DictionaryEntry Entry => new DictionaryEntry(Key, Value);

			public object Key => enumerator.Current.Key;

			public object? Value => enumerator.Current.Value;

			public object Current => Entry;

			public DictionaryEnumerator(IEnumerator<KeyValuePair<TKey, TValue>> enumerator)
			{
				this.enumerator = enumerator;
			}

			public bool MoveNext()
			{
				return enumerator.MoveNext();
			}

			public void Reset()
			{
				enumerator.Reset();
			}
		}

		private readonly IDictionary<TKey, TValue> genericDictionary;

		public bool IsFixedSize
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public bool IsReadOnly
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public ICollection Keys
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public ICollection Values
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public object? this[object key]
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				genericDictionary[(TKey)key] = (TValue)value;
			}
		}

		public int Count
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public bool IsSynchronized
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public object SyncRoot
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public GenericDictionaryToNonGenericAdapter(IDictionary<TKey, TValue> genericDictionary)
		{
			this.genericDictionary = genericDictionary ?? throw new ArgumentNullException("genericDictionary");
		}

		public void Add(object key, object? value)
		{
			throw new NotSupportedException();
		}

		public void Clear()
		{
			throw new NotSupportedException();
		}

		public bool Contains(object key)
		{
			throw new NotSupportedException();
		}

		public IDictionaryEnumerator GetEnumerator()
		{
			return new DictionaryEnumerator(genericDictionary.GetEnumerator());
		}

		public void Remove(object key)
		{
			throw new NotSupportedException();
		}

		public void CopyTo(Array array, int index)
		{
			throw new NotSupportedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal interface IOrderedDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable where TKey : notnull
	{
		KeyValuePair<TKey, TValue> this[int index] { get; set; }

		void Insert(int index, TKey key, TValue value);

		void RemoveAt(int index);
	}
	internal static class NumberExtensions
	{
		public static bool IsPowerOfTwo(this int value)
		{
			return (value & (value - 1)) == 0;
		}
	}
	[Serializable]
	internal sealed class OrderedDictionary<TKey, TValue> : IOrderedDictionary<TKey, TValue>, IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable where TKey : notnull
	{
		private class KeyCollection : ICollection<TKey>, IEnumerable<TKey>, IEnumerable
		{
			private readonly OrderedDictionary<TKey, TValue> orderedDictionary;

			public int Count => orderedDictionary.list.Count;

			public bool IsReadOnly => true;

			public void Add(TKey item)
			{
				throw new NotSupportedException();
			}

			public void Clear()
			{
				throw new NotSupportedException();
			}

			public bool Contains(TKey item)
			{
				return orderedDictionary.dictionary.Keys.Contains(item);
			}

			public KeyCollection(OrderedDictionary<TKey, TValue> orderedDictionary)
			{
				this.orderedDictionary = orderedDictionary;
			}

			public void CopyTo(TKey[] array, int arrayIndex)
			{
				for (int i = 0; i < orderedDictionary.list.Count; i++)
				{
					array[i] = orderedDictionary.list[i + arrayIndex].Key;
				}
			}

			public IEnumerator<TKey> GetEnumerator()
			{
				return orderedDictionary.list.Select((KeyValuePair<TKey, TValue> kvp) => kvp.Key).GetEnumerator();
			}

			public bool Remove(TKey item)
			{
				throw new NotSupportedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		private class ValueCollection : ICollection<TValue>, IEnumerable<TValue>, IEnumerable
		{
			private readonly OrderedDictionary<TKey, TValue> orderedDictionary;

			public int Count => orderedDictionary.list.Count;

			public bool IsReadOnly => true;

			public void Add(TValue item)
			{
				throw new NotSupportedException();
			}

			public void Clear()
			{
				throw new NotSupportedException();
			}

			public bool Contains(TValue item)
			{
				return orderedDictionary.dictionary.Values.Contains(item);
			}

			public ValueCollection(OrderedDictionary<TKey, TValue> orderedDictionary)
			{
				this.orderedDictionary = orderedDictionary;
			}

			public void CopyTo(TValue[] array, int arrayIndex)
			{
				for (int i = 0; i < orderedDictionary.list.Count; i++)
				{
					array[i] = orderedDictionary.list[i + arrayIndex].Value;
				}
			}

			public IEnumerator<TValue> GetEnumerator()
			{
				return orderedDictionary.list.Select((KeyValuePair<TKey, TValue> kvp) => kvp.Value).GetEnumerator();
			}

			public bool Remove(TValue item)
			{
				throw new NotSupportedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		[NonSerialized]
		private Dictionary<TKey, TValue> dictionary;

		private readonly List<KeyValuePair<TKey, TValue>> list;

		private readonly IEqualityComparer<TKey> comparer;

		public TValue this[TKey key]
		{
			get
			{
				return dictionary[key];
			}
			set
			{
				TKey key2 = key;
				if (dictionary.ContainsKey(key2))
				{
					int index = list.FindIndex((KeyValuePair<TKey, TValue> kvp) => comparer.Equals(kvp.Key, key2));
					dictionary[key2] = value;
					list[index] = new KeyValuePair<TKey, TValue>(key2, value);
				}
				else
				{
					Add(key2, value);
				}
			}
		}

		public ICollection<TKey> Keys => new KeyCollection(this);

		public ICollection<TValue> Values => new ValueCollection(this);

		public int Count => dictionary.Count;

		public bool IsReadOnly => false;

		public KeyValuePair<TKey, TValue> this[int index]
		{
			get
			{
				return list[index];
			}
			set
			{
				list[index] = value;
			}
		}

		public OrderedDictionary()
			: this((IEqualityComparer<TKey>)EqualityComparer<TKey>.Default)
		{
		}

		public OrderedDictionary(IEqualityComparer<TKey> comparer)
		{
			list = new List<KeyValuePair<TKey, TValue>>();
			dictionary = new Dictionary<TKey, TValue>(comparer);
			this.comparer = comparer;
		}

		public void Add(TKey key, TValue value)
		{
			Add(new KeyValuePair<TKey, TValue>(key, value));
		}

		public void Add(KeyValuePair<TKey, TValue> item)
		{
			dictionary.Add(item.Key, item.Value);
			list.Add(item);
		}

		public void Clear()
		{
			dictionary.Clear();
			list.Clear();
		}

		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			return dictionary.Contains(item);
		}

		public bool ContainsKey(TKey key)
		{
			return dictionary.ContainsKey(key);
		}

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			list.CopyTo(array, arrayIndex);
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			return list.GetEnumerator();
		}

		public void Insert(int index, TKey key, TValue value)
		{
			dictionary.Add(key, value);
			list.Insert(index, new KeyValuePair<TKey, TValue>(key, value));
		}

		public bool Remove(TKey key)
		{
			TKey key2 = key;
			if (dictionary.ContainsKey(key2))
			{
				int index = list.FindIndex((KeyValuePair<TKey, TValue> kvp) => comparer.Equals(kvp.Key, key2));
				list.RemoveAt(index);
				if (!dictionary.Remove(key2))
				{
					throw new InvalidOperationException();
				}
				return true;
			}
			return false;
		}

		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			return Remove(item.Key);
		}

		public void RemoveAt(int index)
		{
			TKey key = list[index].Key;
			dictionary.Remove(key);
			list.RemoveAt(index);
		}

		public bool TryGetValue(TKey key, [MaybeNullWhen(false)] out TValue value)
		{
			return dictionary.TryGetValue(key, out value);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return list.GetEnumerator();
		}

		[System.Runtime.Serialization.OnDeserialized]
		internal void OnDeserializedMethod(StreamingContext context)
		{
			dictionary = new Dictionary<TKey, TValue>();
			foreach (KeyValuePair<TKey, TValue> item in list)
			{
				dictionary[item.Key] = item.Value;
			}
		}
	}
	internal static class ReadOnlyCollectionExtensions
	{
		public static IReadOnlyList<T> AsReadonlyList<T>(this List<T> list)
		{
			return list;
		}

		public static IReadOnlyDictionary<TKey, TValue> AsReadonlyDictionary<TKey, TValue>(this Dictionary<TKey, TValue> dictionary) where TKey : notnull
		{
			return dictionary;
		}
	}
	[DebuggerStepThrough]
	internal static class StringBuilderPool
	{
		internal readonly struct BuilderWrapper : IDisposable
		{
			public readonly StringBuilder Builder;

			private readonly ConcurrentObjectPool<StringBuilder> _pool;

			public BuilderWrapper(StringBuilder builder, ConcurrentObjectPool<StringBuilder> pool)
			{
				Builder = builder;
				_pool = pool;
			}

			public override string ToString()
			{
				return Builder.ToString();
			}

			public void Dispose()
			{
				StringBuilder builder = Builder;
				if (builder.Capacity <= 1024)
				{
					builder.Length = 0;
					_pool.Free(builder);
				}
			}
		}

		private static readonly ConcurrentObjectPool<StringBuilder> Pool;

		static StringBuilderPool()
		{
			Pool = new ConcurrentObjectPool<StringBuilder>(() => new StringBuilder());
		}

		public static BuilderWrapper Rent()
		{
			return new BuilderWrapper(Pool.Allocate(), Pool);
		}
	}
	internal static class ThrowHelper
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static void ThrowArgumentOutOfRangeException(string paramName, string message)
		{
			throw new ArgumentOutOfRangeException(paramName, message);
		}
	}
}
namespace YamlDotNet.Core
{
	internal struct AnchorName : IEquatable<AnchorName>
	{
		public static readonly AnchorName Empty = default(AnchorName);

		private static readonly Regex AnchorPattern = new Regex("^[^\\[\\]\\{\\},]+$", RegexOptions.Compiled);

		private readonly string? value;

		public string Value => value ?? throw new InvalidOperationException("Cannot read the Value of an empty anchor");

		public bool IsEmpty => value == null;

		public AnchorName(string value)
		{
			this.value = value ?? throw new ArgumentNullException("value");
			if (!AnchorPattern.IsMatch(value))
			{
				throw new ArgumentException("Anchor cannot be empty or contain disallowed characters: []{},\nThe value was '" + value + "'.", "value");
			}
		}

		public override string ToString()
		{
			return value ?? "[empty]";
		}

		public bool Equals(AnchorName other)
		{
			return object.Equals(value, other.value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is AnchorName other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return value?.GetHashCode() ?? 0;
		}

		public static bool operator ==(AnchorName left, AnchorName right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(AnchorName left, AnchorName right)
		{
			return !(left == right);
		}

		public static implicit operator AnchorName(string? value)
		{
			if (value != null)
			{
				return new AnchorName(value);
			}
			return Empty;
		}
	}
	internal class AnchorNotFoundException : YamlException
	{
		public AnchorNotFoundException(string message)
			: base(message)
		{
		}

		public AnchorNotFoundException(in Mark start, in Mark end, string message)
			: base(in start, in end, message)
		{
		}

		public AnchorNotFoundException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	[DebuggerStepThrough]
	internal sealed class CharacterAnalyzer<TBuffer> where TBuffer : class, ILookAheadBuffer
	{
		public TBuffer Buffer { get; }

		public bool EndOfInput => Buffer.EndOfInput;

		public CharacterAnalyzer(TBuffer buffer)
		{
			Buffer = buffer ?? throw new ArgumentNullException("buffer");
		}

		public char Peek(int offset)
		{
			return Buffer.Peek(offset);
		}

		public void Skip(int length)
		{
			Buffer.Skip(length);
		}

		public bool IsAlphaNumericDashOrUnderscore(int offset = 0)
		{
			char c = Buffer.Peek(offset);
			if ((c < '0' || c > '9') && (c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && c != '_')
			{
				return c == '-';
			}
			return true;
		}

		public bool IsAscii(int offset = 0)
		{
			return Buffer.Peek(offset) <= '\u007f';
		}

		public bool IsPrintable(int offset = 0)
		{
			char c = Buffer.Peek(offset);
			switch (c)
			{
			default:
				if (c != '\u0085' && (c < '\u00a0' || c > '\ud7ff'))
				{
					if (c >= '\ue000')
					{
						return c <= '\ufffd';
					}
					return false;
				}
				break;
			case '\t':
			case '\n':
			case '\r':
			case ' ':
			case '!':
			case '"':
			case '#':
			case '$':
			case '%':
			case '&':
			case '\'':
			case '(':
			case ')':
			case '*':
			case '+':
			case ',':
			case '-':
			case '.':
			case '/':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case ':':
			case ';':
			case '<':
			case '=':
			case '>':
			case '?':
			case '@':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '[':
			case '\\':
			case ']':
			case '^':
			case '_':
			case '`':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':
			case '{':
			case '|':
			case '}':
			case '~':
				break;
			}
			return true;
		}

		public bool IsDigit(int offset = 0)
		{
			char c = Buffer.Peek(offset);
			if (c >= '0')
			{
				return c <= '9';
			}
			return false;
		}

		public int AsDigit(int offset = 0)
		{
			return Buffer.Peek(offset) - 48;
		}

		public bool IsHex(int offset)
		{
			char c = Buffer.Peek(offset);
			if ((c < '0' || c > '9') && (c < 'A' || c > 'F'))
			{
				if (c >= 'a')
				{
					return c <= 'f';
				}
				return false;
			}
			return true;
		}

		public int AsHex(int offset)
		{
			char c = Buffer.Peek(offset);
			if (c <= '9')
			{
				return c - 48;
			}
			if (c <= 'F')
			{
				return c - 65 + 10;
			}
			return c - 97 + 10;
		}

		public bool IsSpace(int offset = 0)
		{
			return Check(' ', offset);
		}

		public bool IsZero(int offset = 0)
		{
			return Check('\0', offset);
		}

		public bool IsTab(int offset = 0)
		{
			return Check('\t', offset);
		}

		public bool IsWhite(int offset = 0)
		{
			if (!IsSpace(offset))
			{
				return IsTab(offset);
			}
			return true;
		}

		public bool IsBreak(int offset = 0)
		{
			return Check("\r\n\u0085\u2028\u2029", offset);
		}

		public bool IsCrLf(int offset = 0)
		{
			if (Check('\r', offset))
			{
				return Check('\n', offset + 1);
			}
			return false;
		}

		public bool IsBreakOrZero(int offset = 0)
		{
			if (!IsBreak(offset))
			{
				return IsZero(offset);
			}
			return true;
		}

		public bool IsWhiteBreakOrZero(int offset = 0)
		{
			if (!IsWhite(offset))
			{
				return IsBreakOrZero(offset);
			}
			return true;
		}

		public bool Check(char expected, int offset = 0)
		{
			return Buffer.Peek(offset) == expected;
		}

		public bool Check(string expectedCharacters, int offset = 0)
		{
			char value = Buffer.Peek(offset);
			return expectedCharacters.IndexOf(value) != -1;
		}
	}
	internal static class Constants
	{
		public static readonly TagDirective[] DefaultTagDirectives = new TagDirective[2]
		{
			new TagDirective("!", "!"),
			new TagDirective("!!", "tag:yaml.org,2002:")
		};

		public const int MajorVersion = 1;

		public const int MinorVersion = 3;
	}
	[DebuggerStepThrough]
	internal sealed class Cursor
	{
		public int Index { get; private set; }

		public int Line { get; private set; }

		public int LineOffset { get; private set; }

		public Cursor()
		{
			Line = 1;
		}

		public Cursor(Cursor cursor)
		{
			Index = cursor.Index;
			Line = cursor.Line;
			LineOffset = cursor.LineOffset;
		}

		public Mark Mark()
		{
			return new Mark(Index, Line, LineOffset + 1);
		}

		public void Skip()
		{
			Index++;
			LineOffset++;
		}

		public void SkipLineByOffset(int offset)
		{
			Index += offset;
			Line++;
			LineOffset = 0;
		}

		public void ForceSkipLineAfterNonBreak()
		{
			if (LineOffset != 0)
			{
				Line++;
				LineOffset = 0;
			}
		}
	}
	internal class Emitter : IEmitter
	{
		private class AnchorData
		{
			public AnchorName Anchor;

			public bool IsAlias;
		}

		private class TagData
		{
			public string? Handle;

			public string? Suffix;
		}

		private class ScalarData
		{
			public string Value = string.Empty;

			public bool IsMultiline;

			public bool IsFlowPlainAllowed;

			public bool IsBlockPlainAllowed;

			public bool IsSingleQuotedAllowed;

			public bool IsBlockAllowed;

			public bool HasSingleQuotes;

			public ScalarStyle Style;
		}

		private static readonly Regex UriReplacer = new Regex("[^0-9A-Za-z_\\-;?@=$~\\\\\\)\\]/:&+,\\.\\*\\(\\[!]", RegexOptions.Compiled | RegexOptions.Singleline);

		private static readonly string[] newLineSeparators = new string[3] { "\r\n", "\r", "\n" };

		private readonly TextWriter output;

		private readonly bool outputUsesUnicodeEncoding;

		private readonly int maxSimpleKeyLength;

		private readonly bool isCanonical;

		private readonly bool skipAnchorName;

		private readonly int bestIndent;

		private readonly int bestWidth;

		private EmitterState state;

		private readonly Stack<EmitterState> states = new Stack<EmitterState>();

		private readonly Queue<ParsingEvent> events = new Queue<ParsingEvent>();

		private readonly Stack<int> indents = new Stack<int>();

		private readonly TagDirectiveCollection tagDirectives = new TagDirectiveCollection();

		private int indent;

		private int flowLevel;

		private bool isMappingContext;

		private bool isSimpleKeyContext;

		private int column;

		private bool isWhitespace;

		private bool isIndentation;

		private readonly bool forceIndentLess;

		private readonly string newLine;

		private bool isDocumentEndWritten;

		private readonly AnchorData anchorData = new AnchorData();

		private readonly TagData tagData = new TagData();

		private readonly ScalarData scalarData = new ScalarData();

		public Emitter(TextWriter output)
			: this(output, EmitterSettings.Default)
		{
		}

		public Emitter(TextWriter output, int bestIndent)
			: this(output, bestIndent, int.MaxValue)
		{
		}

		public Emitter(TextWriter output, int bestIndent, int bestWidth)
			: this(output, bestIndent, bestWidth, isCanonical: false)
		{
		}

		public Emitter(TextWriter output, int bestIndent, int bestWidth, bool isCanonical)
			: this(output, new EmitterSettings(bestIndent, bestWidth, isCanonical, 1024))
		{
		}

		public Emitter(TextWriter output, EmitterSettings settings)
		{
			bestIndent = settings.BestIndent;
			bestWidth = settings.BestWidth;
			isCanonical = settings.IsCanonical;
			maxSimpleKeyLength = settings.MaxSimpleKeyLength;
			skipAnchorName = settings.SkipAnchorName;
			forceIndentLess = !settings.IndentSequences;
			newLine = settings.NewLine;
			this.output = output;
			outputUsesUnicodeEncoding = IsUnicode(output.Encoding);
		}

		public void Emit(ParsingEvent @event)
		{
			events.Enqueue(@event);
			while (!NeedMoreEvents())
			{
				ParsingEvent evt = events.Peek();
				try
				{
					AnalyzeEvent(evt);
					StateMachine(evt);
				}
				finally
				{
					events.Dequeue();
				}
			}
		}

		private bool NeedMoreEvents()
		{
			if (events.Count == 0)
			{
				return true;
			}
			int num;
			switch (events.Peek().Type)
			{
			case EventType.DocumentStart:
				num = 1;
				break;
			case EventType.SequenceStart:
				num = 2;
				break;
			case EventType.MappingStart:
				num = 3;
				break;
			default:
				return false;
			}
			if (events.Count > num)
			{
				return false;
			}
			int num2 = 0;
			using (Queue<ParsingEvent>.Enumerator enumerator = events.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current.Type)
					{
					case EventType.DocumentStart:
					case EventType.SequenceStart:
					case EventType.MappingStart:
						num2++;
						break;
					case EventType.DocumentEnd:
					case EventType.SequenceEnd:
					case EventType.MappingEnd:
						num2--;
						break;
					}
					if (num2 == 0)
					{
						return false;
					}
				}
			}
			return true;
		}

		private void AnalyzeEvent(ParsingEvent evt)
		{
			anchorData.Anchor = AnchorName.Empty;
			tagData.Handle = null;
			tagData.Suffix = null;
			if (evt is YamlDotNet.Core.Events.AnchorAlias anchorAlias)
			{
				AnalyzeAnchor(anchorAlias.Value, isAlias: true);
			}
			else if (evt is NodeEvent nodeEvent)
			{
				if (evt is YamlDotNet.Core.Events.Scalar scalar)
				{
					AnalyzeScalar(scalar);
				}
				AnalyzeAnchor(nodeEvent.Anchor, isAlias: false);
				if (!nodeEvent.Tag.IsEmpty && (isCanonical || nodeEvent.IsCanonical))
				{
					AnalyzeTag(nodeEvent.Tag);
				}
			}
		}

		private void AnalyzeAnchor(AnchorName anchor, bool isAlias)
		{
			anchorData.Anchor = anchor;
			anchorData.IsAlias = isAlias;
		}

		private void AnalyzeScalar(YamlDotNet.Core.Events.Scalar scalar)
		{
			string value = scalar.Value;
			scalarData.Value = value;
			if (value.Length == 0)
			{
				if (scalar.Tag == "tag:yaml.org,2002:null")
				{
					scalarData.IsMultiline = false;
					scalarData.IsFlowPlainAllowed = false;
					scalarData.IsBlockPlainAllowed = true;
					scalarData.IsSingleQuotedAllowed = false;
					scalarData.IsBlockAllowed = false;
				}
				else
				{
					scalarData.IsMultiline = false;
					scalarData.IsFlowPlainAllowed = false;
					scalarData.IsBlockPlainAllowed = false;
					scalarData.IsSingleQuotedAllowed = true;
					scalarData.IsBlockAllowed = false;
				}
				return;
			}
			bool flag = false;
			bool flag2 = false;
			if (value.StartsWith("---", StringComparison.Ordinal) || value.StartsWith("...", StringComparison.Ordinal))
			{
				flag = true;
				flag2 = true;
			}
			CharacterAnalyzer<StringLookAheadBuffer> characterAnalyzer = new CharacterAnalyzer<StringLookAheadBuffer>(new StringLookAheadBuffer(value));
			bool flag3 = true;
			bool flag4 = characterAnalyzer.IsWhiteBreakOrZero(1);
			bool flag5 = false;
			bool flag6 = false;
			bool flag7 = false;
			bool flag8 = false;
			bool flag9 = false;
			bool flag10 = false;
			bool flag11 = false;
			bool flag12 = false;
			bool flag13 = false;
			bool flag14 = false;
			bool flag15 = false;
			bool flag16 = !ValueIsRepresentableInOutputEncoding(value);
			bool flag17 = false;
			bool flag18 = false;
			bool flag19 = true;
			while (!characterAnalyzer.EndOfInput)
			{
				if (flag19)
				{
					if (characterAnalyzer.Check("#,[]{}&*!|>\\\"%@`'"))
					{
						flag = true;
						flag2 = true;
						flag9 = characterAnalyzer.Check('\'');
						flag17 |= characterAnalyzer.Check('\'');
					}
					if (characterAnalyzer.Check("?:"))
					{
						flag = true;
						if (flag4)
						{
							flag2 = true;
						}
					}
					if (characterAnalyzer.Check('-') && flag4)
					{
						flag = true;
						flag2 = true;
					}
				}
				else
				{
					if (characterAnalyzer.Check(",?[]{}"))
					{
						flag = true;
					}
					if (characterAnalyzer.Check(':'))
					{
						flag = true;
						if (flag4)
						{
							flag2 = true;
						}
					}
					if (characterAnalyzer.Check('#') && flag3)
					{
						flag = true;
						flag2 = true;
					}
					flag17 |= characterAnalyzer.Check('\'');
				}
				if (!flag16 && !characterAnalyzer.IsPrintable())
				{
					flag16 = true;
				}
				if (characterAnalyzer.IsBreak())
				{
					flag15 = true;
				}
				if (characterAnalyzer.IsSpace())
				{
					if (flag19)
					{
						flag5 = true;
					}
					if (characterAnalyzer.Buffer.Position >= characterAnalyzer.Buffer.Length - 1)
					{
						flag7 = true;
					}
					if (flag13)
					{
						flag10 = true;
						flag14 = true;
					}
					flag12 = true;
					flag13 = false;
				}
				else if (characterAnalyzer.IsBreak())
				{
					if (flag19)
					{
						flag6 = true;
					}
					if (characterAnalyzer.Buffer.Position >= characterAnalyzer.Buffer.Length - 1)
					{
						flag8 = true;
					}
					if (flag12)
					{
						flag11 = true;
					}
					if (flag14)
					{
						flag18 = true;
					}
					flag12 = false;
					flag13 = true;
				}
				else
				{
					flag12 = false;
					flag13 = false;
					flag14 = false;
				}
				flag3 = characterAnalyzer.IsWhiteBreakOrZero();
				characterAnalyzer.Skip(1);
				if (!characterAnalyzer.EndOfInput)
				{
					flag4 = characterAnalyzer.IsWhiteBreakOrZero(1);
				}
				flag19 = false;
			}
			scalarData.IsFlowPlainAllowed = true;
			scalarData.IsBlockPlainAllowed = true;
			scalarData.IsSingleQuotedAllowed = true;
			scalarData.IsBlockAllowed = true;
			if (flag5 || flag6 || flag7 || flag8 || flag9)
			{
				scalarData.IsFlowPlainAllowed = false;
				scalarData.IsBlockPlainAllowed = false;
			}
			if (flag7)
			{
				scalarData.IsBlockAllowed = false;
			}
			if (flag10)
			{
				scalarData.IsFlowPlainAllowed = false;
				scalarData.IsBlockPlainAllowed = false;
				scalarData.IsSingleQuotedAllowed = false;
			}
			if (flag11 || flag16)
			{
				scalarData.IsFlowPlainAllowed = false;
				scalarData.IsBlockPlainAllowed = false;
				scalarData.IsSingleQuotedAllowed = false;
			}
			if (flag18)
			{
				scalarData.IsBlockAllowed = false;
			}
			scalarData.IsMultiline = flag15;
			if (flag15)
			{
				scalarData.IsFlowPlainAllowed = false;
				scalarData.IsBlockPlainAllowed = false;
			}
			if (flag)
			{
				scalarData.IsFlowPlainAllowed = false;
			}
			if (flag2)
			{
				scalarData.IsBlockPlainAllowed = false;
			}
			scalarData.HasSingleQuotes = flag17;
		}

		private bool ValueIsRepresentableInOutputEncoding(string value)
		{
			if (outputUsesUnicodeEncoding)
			{
				return true;
			}
			try
			{
				byte[] bytes = output.Encoding.GetBytes(value);
				return output.Encoding.GetString(bytes, 0, bytes.Length).Equals(value);
			}
			catch (EncoderFallbackException)
			{
				return false;
			}
			catch (ArgumentOutOfRangeException)
			{
				return false;
			}
		}

		private bool IsUnicode(Encoding encoding)
		{
			if (!(encoding is UTF8Encoding) && !(encoding is UnicodeEncoding))
			{
				return encoding is UTF7Encoding;
			}
			return true;
		}

		private void AnalyzeTag(TagName tag)
		{
			tagData.Handle = tag.Value;
			foreach (TagDirective tagDirective in tagDirectives)
			{
				if (tag.Value.StartsWith(tagDirective.Prefix, StringComparison.Ordinal))
				{
					tagData.Handle = tagDirective.Handle;
					tagData.Suffix = tag.Value.Substring(tagDirective.Prefix.Length);
					break;
				}
			}
		}

		private void StateMachine(ParsingEvent evt)
		{
			if (evt is YamlDotNet.Core.Events.Comment comment)
			{
				EmitComment(comment);
				return;
			}
			switch (state)
			{
			case EmitterState.StreamStart:
				EmitStreamStart(evt);
				break;
			case EmitterState.FirstDocumentStart:
				EmitDocumentStart(evt, isFirst: true);
				break;
			case EmitterState.DocumentStart:
				EmitDocumentStart(evt, isFirst: false);
				break;
			case EmitterState.DocumentContent:
				EmitDocumentContent(evt);
				break;
			case EmitterState.DocumentEnd:
				EmitDocumentEnd(evt);
				break;
			case EmitterState.FlowSequenceFirstItem:
				EmitFlowSequenceItem(evt, isFirst: true);
				break;
			case EmitterState.FlowSequenceItem:
				EmitFlowSequenceItem(evt, isFirst: false);
				break;
			case EmitterState.FlowMappingFirstKey:
				EmitFlowMappingKey(evt, isFirst: true);
				break;
			case EmitterState.FlowMappingKey:
				EmitFlowMappingKey(evt, isFirst: false);
				break;
			case EmitterState.FlowMappingSimpleValue:
				EmitFlowMappingValue(evt, isSimple: true);
				break;
			case EmitterState.FlowMappingValue:
				EmitFlowMappingValue(evt, isSimple: false);
				break;
			case EmitterState.BlockSequenceFirstItem:
				EmitBlockSequenceItem(evt, isFirst: true);
				break;
			case EmitterState.BlockSequenceItem:
				EmitBlockSequenceItem(evt, isFirst: false);
				break;
			case EmitterState.BlockMappingFirstKey:
				EmitBlockMappingKey(evt, isFirst: true);
				break;
			case EmitterState.BlockMappingKey:
				EmitBlockMappingKey(evt, isFirst: false);
				break;
			case EmitterState.BlockMappingSimpleValue:
				EmitBlockMappingValue(evt, isSimple: true);
				break;
			case EmitterState.BlockMappingValue:
				EmitBlockMappingValue(evt, isSimple: false);
				break;
			case EmitterState.StreamEnd:
				throw new YamlException("Expected nothing after STREAM-END");
			default:
				throw new InvalidOperationException();
			}
		}

		private void EmitComment(YamlDotNet.Core.Events.Comment comment)
		{
			if (flowLevel > 0 || state == EmitterState.FlowMappingFirstKey || state == EmitterState.FlowSequenceFirstItem)
			{
				return;
			}
			string[] array = comment.Value.Split(newLineSeparators, StringSplitOptions.None);
			if (comment.IsInline)
			{
				Write(" # ");
				Write(string.Join(" ", array));
			}
			else
			{
				bool flag = state == EmitterState.BlockMappingFirstKey;
				if (flag)
				{
					IncreaseIndent(isFlow: false, isIndentless: false);
				}
				string[] array2 = array;
				foreach (string value in array2)
				{
					WriteIndent();
					Write("# ");
					Write(value);
					WriteBreak();
				}
				if (flag)
				{
					indent = indents.Pop();
				}
			}
			isIndentation = true;
		}

		private void EmitStreamStart(ParsingEvent evt)
		{
			if (!(evt is YamlDotNet.Core.Events.StreamStart))
			{
				throw new ArgumentException("Expected STREAM-START.", "evt");
			}
			indent = -1;
			column = 0;
			isWhitespace = true;
			isIndentation = true;
			state = EmitterState.FirstDocumentStart;
		}

		private void EmitDocumentStart(ParsingEvent evt, bool isFirst)
		{
			if (evt is YamlDotNet.Core.Events.DocumentStart documentStart)
			{
				bool flag = documentStart.IsImplicit && isFirst && !isCanonical;
				TagDirectiveCollection tagDirectiveCollection = NonDefaultTagsAmong(documentStart.Tags);
				if (!isFirst && !isDocumentEndWritten && (documentStart.Version != null || tagDirectiveCollection.Count > 0))
				{
					isDocumentEndWritten = false;
					WriteIndicator("...", needWhitespace: true, whitespace: false, indentation: false);
					WriteIndent();
				}
				if (documentStart.Version != null)
				{
					AnalyzeVersionDirective(documentStart.Version);
					Version version = documentStart.Version.Version;
					flag = false;
					WriteIndicator("%YAML", needWhitespace: true, whitespace: false, indentation: false);
					WriteIndicator(string.Format(CultureInfo.InvariantCulture, "{0}.{1}", version.Major, version.Minor), needWhitespace: true, whitespace: false, indentation: false);
					WriteIndent();
				}
				foreach (TagDirective item in tagDirectiveCollection)
				{
					AppendTagDirectiveTo(item, allowDuplicates: false, tagDirectives);
				}
				TagDirective[] defaultTagDirectives = Constants.DefaultTagDirectives;
				for (int i = 0; i < defaultTagDirectives.Length; i++)
				{
					AppendTagDirectiveTo(defaultTagDirectives[i], allowDuplicates: true, tagDirectives);
				}
				if (tagDirectiveCollection.Count > 0)
				{
					flag = false;
					defaultTagDirectives = Constants.DefaultTagDirectives;
					for (int i = 0; i < defaultTagDirectives.Length; i++)
					{
						AppendTagDirectiveTo(defaultTagDirectives[i], allowDuplicates: true, tagDirectiveCollection);
					}
					foreach (TagDirective item2 in tagDirectiveCollection)
					{
						WriteIndicator("%TAG", needWhitespace: true, whitespace: false, indentation: false);
						WriteTagHandle(item2.Handle);
						WriteTagContent(item2.Prefix, needsWhitespace: true);
						WriteIndent();
					}
				}
				if (CheckEmptyDocument())
				{
					flag = false;
				}
				if (!flag)
				{
					WriteIndent();
					WriteIndicator("---", needWhitespace: true, whitespace: false, indentation: false);
					if (isCanonical)
					{
						WriteIndent();
					}
				}
				state = EmitterState.DocumentContent;
			}
			else
			{
				if (!(evt is YamlDotNet.Core.Events.StreamEnd))
				{
					throw new YamlException("Expected DOCUMENT-START or STREAM-END");
				}
				state = EmitterState.StreamEnd;
			}
		}

		private TagDirectiveCollection NonDefaultTagsAmong(IEnumerable<TagDirective>? tagCollection)
		{
			TagDirectiveCollection tagDirectiveCollection = new TagDirectiveCollection();
			if (tagCollection == null)
			{
				return tagDirectiveCollection;
			}
			foreach (TagDirective item2 in tagCollection)
			{
				AppendTagDirectiveTo(item2, allowDuplicates: false, tagDirectiveCollection);
			}
			TagDirective[] defaultTagDirectives = Constants.DefaultTagDirectives;
			foreach (TagDirective item in defaultTagDirectives)
			{
				tagDirectiveCollection.Remove(item);
			}
			return tagDirectiveCollection;
		}

		private void AnalyzeVersionDirective(VersionDirective versionDirective)
		{
			if (versionDirective.Version.Major != 1 || versionDirective.Version.Minor > 3)
			{
				throw new YamlException("Incompatible %YAML directive");
			}
		}

		private static void AppendTagDirectiveTo(TagDirective value, bool allowDuplicates, TagDirectiveCollection tagDirectives)
		{
			if (tagDirectives.Contains(value))
			{
				if (!allowDuplicates)
				{
					throw new YamlException("Duplicate %TAG directive.");
				}
			}
			else
			{
				tagDirectives.Add(value);
			}
		}

		private void EmitDocumentContent(ParsingEvent evt)
		{
			states.Push(EmitterState.DocumentEnd);
			EmitNode(evt, isMapping: false, isSimpleKey: false);
		}

		private void EmitNode(ParsingEvent evt, bool isMapping, bool isSimpleKey)
		{
			isMappingContext = isMapping;
			isSimpleKeyContext = isSimpleKey;
			switch (evt.Type)
			{
			case EventType.Alias:
				EmitAlias();
				break;
			case EventType.Scalar:
				EmitScalar(evt);
				break;
			case EventType.SequenceStart:
				EmitSequenceStart(evt);
				break;
			case EventType.MappingStart:
				EmitMappingStart(evt);
				break;
			default:
				throw new YamlException($"Expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS, got {evt.Type}");
			}
		}

		private void EmitAlias()
		{
			ProcessAnchor();
			state = states.Pop();
		}

		private void EmitScalar(ParsingEvent evt)
		{
			SelectScalarStyle(evt);
			ProcessAnchor();
			ProcessTag();
			IncreaseIndent(isFlow: true, isIndentless: false);
			ProcessScalar();
			indent = indents.Pop();
			state = states.Pop();
		}

		private void SelectScalarStyle(ParsingEvent evt)
		{
			YamlDotNet.Core.Events.Scalar scalar = (YamlDotNet.Core.Events.Scalar)evt;
			ScalarStyle scalarStyle = scalar.Style;
			bool flag = tagData.Handle == null && tagData.Suffix == null;
			if (flag && !scalar.IsPlainImplicit && !scalar.IsQuotedImplicit)
			{
				throw new YamlException("Neither tag nor isImplicit flags are specified.");
			}
			if (scalarStyle == ScalarStyle.Any)
			{
				scalarStyle = ((!scalarData.IsMultiline) ? ScalarStyle.Plain : ScalarStyle.Folded);
			}
			if (isCanonical)
			{
				scalarStyle = ScalarStyle.DoubleQuoted;
			}
			if (isSimpleKeyContext && scalarData.IsMultiline)
			{
				scalarStyle = ScalarStyle.DoubleQuoted;
			}
			if (scalarStyle == ScalarStyle.Plain)
			{
				if ((flowLevel != 0 && !scalarData.IsFlowPlainAllowed) || (flowLevel == 0 && !scalarData.IsBlockPlainAllowed))
				{
					scalarStyle = ((scalarData.IsSingleQuotedAllowed && !scalarData.HasSingleQuotes) ? ScalarStyle.SingleQuoted : ScalarStyle.DoubleQuoted);
				}
				if (string.IsNullOrEmpty(scalarData.Value) && (flowLevel != 0 || isSimpleKeyContext))
				{
					scalarStyle = ScalarStyle.SingleQuoted;
				}
				if (flag && !scalar.IsPlainImplicit)
				{
					scalarStyle = ScalarStyle.SingleQuoted;
				}
			}
			if (scalarStyle == ScalarStyle.SingleQuoted && !scalarData.IsSingleQuotedAllowed)
			{
				scalarStyle = ScalarStyle.DoubleQuoted;
			}
			if ((scalarStyle == ScalarStyle.Literal || scalarStyle == ScalarStyle.Folded) && (!scalarData.IsBlockAllowed || flowLevel != 0 || isSimpleKeyContext))
			{
				scalarStyle = ScalarStyle.DoubleQuoted;
			}
			scalarData.Style = scalarStyle;
		}

		private void ProcessScalar()
		{
			switch (scalarData.Style)
			{
			case ScalarStyle.Plain:
				WritePlainScalar(scalarData.Value, !isSimpleKeyContext);
				break;
			case ScalarStyle.SingleQuoted:
				WriteSingleQuotedScalar(scalarData.Value, !isSimpleKeyContext);
				break;
			case ScalarStyle.DoubleQuoted:
				WriteDoubleQuotedScalar(scalarData.Value, !isSimpleKeyContext);
				break;
			case ScalarStyle.Literal:
				WriteLiteralScalar(scalarData.Value);
				break;
			case ScalarStyle.Folded:
				WriteFoldedScalar(scalarData.Value);
				break;
			default:
				throw new InvalidOperationException();
			}
		}

		private void WritePlainScalar(string value, bool allowBreaks)
		{
			if (!isWhitespace)
			{
				Write(' ');
			}
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < value.Length; i++)
			{
				char c = value[i];
				if (IsSpace(c))
				{
					if (allowBreaks && !flag && column > bestWidth && i + 1 < value.Length && value[i + 1] != ' ')
					{
						WriteIndent();
					}
					else
					{
						Write(c);
					}
					flag = true;
					continue;
				}
				if (IsBreak(c, out var breakChar))
				{
					if (!flag2 && c == '\n')
					{
						WriteBreak();
					}
					WriteBreak(breakChar);
					isIndentation = true;
					flag2 = true;
					continue;
				}
				if (flag2)
				{
					WriteIndent();
				}
				Write(c);
				isIndentation = false;
				flag = false;
				flag2 = false;
			}
			isWhitespace = false;
			isIndentation = false;
		}

		private void WriteSingleQuotedScalar(string value, bool allowBreaks)
		{
			WriteIndicator("'", needWhitespace: true, whitespace: false, indentation: false);
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < value.Length; i++)
			{
				char c = value[i];
				if (c == ' ')
				{
					if (allowBreaks && !flag && column > bestWidth && i != 0 && i + 1 < value.Length && value[i + 1] != ' ')
					{
						WriteIndent();
					}
					else
					{
						Write(c);
					}
					flag = true;
					continue;
				}
				if (IsBreak(c, out var breakChar))
				{
					if (!flag2 && c == '\n')
					{
						WriteBreak();
					}
					WriteBreak(breakChar);
					isIndentation = true;
					flag2 = true;
					continue;
				}
				if (flag2)
				{
					WriteIndent();
				}
				if (c == '\'')
				{
					Write(c);
				}
				Write(c);
				isIndentation = false;
				flag = false;
				flag2 = false;
			}
			WriteIndicator("'", needWhitespace: false, whitespace: false, indentation: false);
			isWhitespace = false;
			isIndentation = false;
		}

		private void WriteDoubleQuotedScalar(string value, bool allowBreaks)
		{
			WriteIndicator("\"", needWhitespace: true, whitespace: false, indentation: false);
			bool flag = false;
			for (int i = 0; i < value.Length; i++)
			{
				char c = value[i];
				if (IsPrintable(c) && !IsBreak(c, out var _))
				{
					switch (c)
					{
					case '"':
					case '\\':
						break;
					case ' ':
						if (allowBreaks && !flag && column > bestWidth && i > 0 && i + 1 < value.Length)
						{
							WriteIndent();
							if (value[i + 1] == ' ')
							{
								Write('\\');
							}
						}
						else
						{
							Write(c);
						}
						flag = true;
						continue;
					default:
						Write(c);
						flag = false;
						continue;
					}
				}
				Write('\\');
				switch (c)
				{
				case '\0':
					Write('0');
					break;
				case '\a':
					Write('a');
					break;
				case '\b':
					Write('b');
					break;
				case '\t':
					Write('t');
					break;
				case '\n':
					Write('n');
					break;
				case '\v':
					Write('v');
					break;
				case '\f':
					Write('f');
					break;
				case '\r':
					Write('r');
					break;
				case '\u001b':
					Write('e');
					break;
				case '"':
					Write('"');
					break;
				case '\\':
					Write('\\');
					break;
				case '\u0085':
					Write('N');
					break;
				case '\u00a0':
					Write('_');
					break;
				case '\u2028':
					Write('L');
					break;
				case '\u2029':
					Write('P');
					break;
				default:
				{
					ushort num = c;
					if (num <= 255)
					{
						Write('x');
						Write(num.ToString("X02", CultureInfo.InvariantCulture));
					}
					else if (IsHighSurrogate(c))
					{
						if (i + 1 >= value.Length || !IsLowSurrogate(value[i + 1]))
						{
							throw new SyntaxErrorException("While writing a quoted scalar, found an orphaned high surrogate.");
						}
						Write('U');
						Write(char.ConvertToUtf32(c, value[i + 1]).ToString("X08", CultureInfo.InvariantCulture));
						i++;
					}
					else
					{
						Write('u');
						Write(num.ToString("X04", CultureInfo.InvariantCulture));
					}
					break;
				}
				}
				flag = false;
			}
			WriteIndicator("\"", needWhitespace: false, whitespace: false, indentation: false);
			isWhitespace = false;
			isIndentation = false;
		}

		private void WriteLiteralScalar(string value)
		{
			bool flag = true;
			WriteIndicator("|", needWhitespace: true, whitespace: false, indentation: false);
			WriteBlockScalarHints(value);
			WriteBreak();
			isIndentation = true;
			isWhitespace = true;
			for (int i = 0; i < value.Length; i++)
			{
				char c = value[i];
				if (c == '\r' && i + 1 < value.Length && value[i + 1] == '\n')
				{
					continue;
				}
				if (IsBreak(c, out var breakChar))
				{
					WriteBreak(breakChar);
					isIndentation = true;
					flag = true;
					continue;
				}
				if (flag)
				{
					WriteIndent();
				}
				Write(c);
				isIndentation = false;
				flag = false;
			}
		}

		private void WriteFoldedScalar(string value)
		{
			bool flag = true;
			bool flag2 = true;
			WriteIndicator(">", needWhitespace: true, whitespace: false, indentation: false);
			WriteBlockScalarHints(value);
			WriteBreak();
			isIndentation = true;
			isWhitespace = true;
			for (int i = 0; i < value.Length; i++)
			{
				char c = value[i];
				if (IsBreak(c, out var breakChar))
				{
					if (c == '\r' && i + 1 < value.Length && value[i + 1] == '\n')
					{
						continue;
					}
					if (!flag && !flag2 && breakChar == '\n')
					{
						int j;
						char breakChar2;
						for (j = 0; i + j < value.Length && IsBreak(value[i + j], out breakChar2); j++)
						{
						}
						if (i + j < value.Length && !IsBlank(value[i + j]) && !IsBreak(value[i + j], out breakChar2))
						{
							WriteBreak();
						}
					}
					WriteBreak(breakChar);
					isIndentation = true;
					flag = true;
				}
				else
				{
					if (flag)
					{
						WriteIndent();
						flag2 = IsBlank(c);
					}
					if (!flag && c == ' ' && i + 1 < value.Length && value[i + 1] != ' ' && column > bestWidth)
					{
						WriteIndent();
					}
					else
					{
						Write(c);
					}
					isIndentation = false;
					flag = false;
				}
			}
		}

		private static bool IsSpace(char character)
		{
			return character == ' ';
		}

		private static bool IsBreak(char character, out char breakChar)
		{
			switch (character)
			{
			case '\n':
			case '\r':
			case '\u0085':
				breakChar = '\n';
				return true;
			case '\u2028':
			case '\u2029':
				breakChar = character;
				return true;
			default:
				breakChar = '\0';
				return false;
			}
		}

		private static bool IsBlank(char character)
		{
			if (character != ' ')
			{
				return character == '\t';
			}
			return true;
		}

		private static bool IsPrintable(char character)
		{
			switch (character)
			{
			default:
				if (character != '\u0085' && (character < '\u00a0' || character > '\ud7ff'))
				{
					if (character >= '\ue000')
					{
						return character <= '\ufffd';
					}
					return false;
				}
				break;
			case '\t':
			case '\n':
			case '\r':
			case ' ':
			case '!':
			case '"':
			case '#':
			case '$':
			case '%':
			case '&':
			case '\'':
			case '(':
			case ')':
			case '*':
			case '+':
			case ',':
			case '-':
			case '.':
			case '/':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case ':':
			case ';':
			case '<':
			case '=':
			case '>':
			case '?':
			case '@':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '[':
			case '\\':
			case ']':
			case '^':
			case '_':
			case '`':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':
			case '{':
			case '|':
			case '}':
			case '~':
				break;
			}
			return true;
		}

		private static bool IsHighSurrogate(char c)
		{
			if ('\ud800' <= c)
			{
				return c <= '\udbff';
			}
			return false;
		}

		private static bool IsLowSurrogate(char c)
		{
			if ('\udc00' <= c)
			{
				return c <= '\udfff';
			}
			return false;
		}

		private void EmitSequenceStart(ParsingEvent evt)
		{
			ProcessAnchor();
			ProcessTag();
			SequenceStart sequenceStart = (SequenceStart)evt;
			if (flowLevel != 0 || isCanonical || sequenceStart.Style == SequenceStyle.Flow || CheckEmptySequence())
			{
				state = EmitterState.FlowSequenceFirstItem;
			}
			else
			{
				state = EmitterState.BlockSequenceFirstItem;
			}
		}

		private void EmitMappingStart(ParsingEvent evt)
		{
			ProcessAnchor();
			ProcessTag();
			MappingStart mappingStart = (MappingStart)evt;
			if (flowLevel != 0 || isCanonical || mappingStart.Style == MappingStyle.Flow || CheckEmptyMapping())
			{
				state = EmitterState.FlowMappingFirstKey;
			}
			else
			{
				state = EmitterState.BlockMappingFirstKey;
			}
		}

		private void ProcessAnchor()
		{
			if (!anchorData.Anchor.IsEmpty && !skipAnchorName)
			{
				WriteIndicator(anchorData.IsAlias ? "*" : "&", needWhitespace: true, whitespace: false, indentation: false);
				WriteAnchor(anchorData.Anchor);
			}
		}

		private void ProcessTag()
		{
			if (tagData.Handle == null && tagData.Suffix == null)
			{
				return;
			}
			if (tagData.Handle != null)
			{
				WriteTagHandle(tagData.Handle);
				if (tagData.Suffix != null)
				{
					WriteTagContent(tagData.Suffix, needsWhitespace: false);
				}
			}
			else
			{
				WriteIndicator("!<", needWhitespace: true, whitespace: false, indentation: false);
				WriteTagContent(tagData.Suffix, needsWhitespace: false);
				WriteIndicator(">", needWhitespace: false, whitespace: false, indentation: false);
			}
		}

		private void EmitDocumentEnd(ParsingEvent evt)
		{
			if (evt is YamlDotNet.Core.Events.DocumentEnd documentEnd)
			{
				WriteIndent();
				if (!documentEnd.IsImplicit)
				{
					WriteIndicator("...", needWhitespace: true, whitespace: false, indentation: false);
					WriteIndent();
					isDocumentEndWritten = true;
				}
				state = EmitterState.DocumentStart;
				tagDirectives.Clear();
				return;
			}
			throw new YamlException("Expected DOCUMENT-END.");
		}

		private void EmitFlowSequenceItem(ParsingEvent evt, bool isFirst)
		{
			if (isFirst)
			{
				WriteIndicator("[", needWhitespace: true, whitespace: true, indentation: false);
				IncreaseIndent(isFlow: true, isIndentless: false);
				flowLevel++;
			}
			if (evt is SequenceEnd)
			{
				flowLevel--;
				indent = indents.Pop();
				if (isCanonical && !isFirst)
				{
					WriteIndicator(",", needWhitespace: false, whitespace: false, indentation: false);
					WriteIndent();
				}
				WriteIndicator("]", needWhitespace: false, whitespace: false, indentation: false);
				state = states.Pop();
			}
			else
			{
				if (!isFirst)
				{
					WriteIndicator(",", needWhitespace: false, whitespace: false, indentation: false);
				}
				if (isCanonical || column > bestWidth)
				{
					WriteIndent();
				}
				states.Push(EmitterState.FlowSequenceItem);
				EmitNode(evt, isMapping: false, isSimpleKey: false);
			}
		}

		private void EmitFlowMappingKey(ParsingEvent evt, bool isFirst)
		{
			if (isFirst)
			{
				WriteIndicator("{", needWhitespace: true, whitespace: true, indentation: false);
				IncreaseIndent(isFlow: true, isIndentless: false);
				flowLevel++;
			}
			if (evt is MappingEnd)
			{
				flowLevel--;
				indent = indents.Pop();
				if (isCanonical && !isFirst)
				{
					WriteIndicator(",", needWhitespace: false, whitespace: false, indentation: false);
					WriteIndent();
				}
				WriteIndicator("}", needWhitespace: false, whitespace: false, indentation: false);
				state = states.Pop();
				return;
			}
			if (!isFirst)
			{
				WriteIndicator(",", needWhitespace: false, whitespace: false, indentation: false);
			}
			if (isCanonical || column > bestWidth)
			{
				WriteIndent();
			}
			if (!isCanonical && CheckSimpleKey())
			{
				states.Push(EmitterState.FlowMappingSimpleValue);
				EmitNode(evt, isMapping: true, isSimpleKey: true);
			}
			else
			{
				WriteIndicator("?", needWhitespace: true, whitespace: false, indentation: false);
				states.Push(EmitterState.FlowMappingValue);
				EmitNode(evt, isMapping: true, isSimpleKey: false);
			}
		}

		private void EmitFlowMappingValue(ParsingEvent evt, bool isSimple)
		{
			if (isSimple)
			{
				WriteIndicator(":", needWhitespace: false, whitespace: false, indentation: false);
			}
			else
			{
				if (isCanonical || column > bestWidth)
				{
					WriteIndent();
				}
				WriteIndicator(":", needWhitespace: true, whitespace: false, indentation: false);
			}
			states.Push(EmitterState.FlowMappingKey);
			EmitNode(evt, isMapping: true, isSimpleKey: false);
		}

		private void EmitBlockSequenceItem(ParsingEvent evt, bool isFirst)
		{
			if (isFirst)
			{
				IncreaseIndent(isFlow: false, isMappingContext && !isIndentation);
			}
			if (evt is SequenceEnd)
			{
				indent = indents.Pop();
				state = states.Pop();
				return;
			}
			WriteIndent();
			WriteIndicator("-", needWhitespace: true, whitespace: false, indentation: true);
			states.Push(EmitterState.BlockSequenceItem);
			EmitNode(evt, isMapping: false, isSimpleKey: false);
		}

		private void EmitBlockMappingKey(ParsingEvent evt, bool isFirst)
		{
			if (isFirst)
			{
				IncreaseIndent(isFlow: false, isIndentless: false);
			}
			if (evt is MappingEnd)
			{
				indent = indents.Pop();
				state = states.Pop();
				return;
			}
			WriteIndent();
			if (CheckSimpleKey())
			{
				states.Push(EmitterState.BlockMappingSimpleValue);
				EmitNode(evt, isMapping: true, isSimpleKey: true);
				WriteIndicator(":", needWhitespace: false, whitespace: false, indentation: false);
			}
			else
			{
				WriteIndicator("?", needWhitespace: true, whitespace: false, indentation: true);
				states.Push(EmitterState.BlockMappingValue);
				EmitNode(evt, isMapping: true, isSimpleKey: false);
			}
		}

		private void EmitBlockMappingValue(ParsingEvent evt, bool isSimple)
		{
			if (!isSimple)
			{
				WriteIndent();
				WriteIndicator(":", needWhitespace: true, whitespace: false, indentation: true);
			}
			states.Push(EmitterState.BlockMappingKey);
			EmitNode(evt, isMapping: true, isSimpleKey: false);
		}

		private void IncreaseIndent(bool isFlow, bool isIndentless)
		{
			indents.Push(indent);
			if (indent < 0)
			{
				indent = (isFlow ? bestIndent : 0);
			}
			else if (!isIndentless || !forceIndentLess)
			{
				indent += bestIndent;
			}
		}

		private bool CheckEmptyDocument()
		{
			int num = 0;
			foreach (ParsingEvent @event in events)
			{
				num++;
				if (num == 2)
				{
					if (@event is YamlDotNet.Core.Events.Scalar scalar)
					{
						return string.IsNullOrEmpty(scalar.Value);
					}
					break;
				}
			}
			return false;
		}

		private bool CheckSimpleKey()
		{
			if (events.Count < 1)
			{
				return false;
			}
			int num;
			switch (events.Peek().Type)
			{
			case EventType.Alias:
				num = AnchorNameLength(anchorData.Anchor);
				break;
			case EventType.Scalar:
				if (scalarData.IsMultiline)
				{
					return false;
				}
				num = AnchorNameLength(anchorData.Anchor) + SafeStringLength(tagData.Handle) + SafeStringLength(tagData.Suffix) + SafeStringLength(scalarData.Value);
				break;
			case EventType.SequenceStart:
				if (!CheckEmptySequence())
				{
					return false;
				}
				num = AnchorNameLength(anchorData.Anchor) + SafeStringLength(tagData.Handle) + SafeStringLength(tagData.Suffix);
				break;
			case EventType.MappingStart:
				if (!CheckEmptySequence())
				{
					return false;
				}
				num = AnchorNameLength(anchorData.Anchor) + SafeStringLength(tagData.Handle) + SafeStringLength(tagData.Suffix);
				break;
			default:
				return false;
			}
			return num <= maxSimpleKeyLength;
		}

		private int AnchorNameLength(AnchorName value)
		{
			if (!value.IsEmpty)
			{
				return value.Value.Length;
			}
			return 0;
		}

		private int SafeStringLength(string? value)
		{
			return value?.Length ?? 0;
		}

		private bool CheckEmptySequence()
		{
			return CheckEmptyStructure<SequenceStart, SequenceEnd>();
		}

		private bool CheckEmptyMapping()
		{
			return CheckEmptyStructure<MappingStart, MappingEnd>();
		}

		private bool CheckEmptyStructure<TStart, TEnd>() where TStart : NodeEvent where TEnd : ParsingEvent
		{
			if (events.Count < 2)
			{
				return false;
			}
			using Queue<ParsingEvent>.Enumerator enumerator = events.GetEnumerator();
			return enumerator.MoveNext() && enumerator.Current is TStart && enumerator.MoveNext() && enumerator.Current is TEnd;
		}

		private void WriteBlockScalarHints(string value)
		{
			CharacterAnalyzer<StringLookAheadBuffer> characterAnalyzer = new CharacterAnalyzer<StringLookAheadBuffer>(new StringLookAheadBuffer(value));
			if (characterAnalyzer.IsSpace() || characterAnalyzer.IsBreak())
			{
				int num = bestIndent;
				string indicator = num.ToString(CultureInfo.InvariantCulture);
				WriteIndicator(indicator, needWhitespace: false, whitespace: false, indentation: false);
			}
			string text = null;
			if (value.Length == 0 || !characterAnalyzer.IsBreak(value.Length - 1))
			{
				text = "-";
			}
			else if (value.Length >= 2 && characterAnalyzer.IsBreak(value.Length - 2))
			{
				text = "+";
			}
			if (text != null)
			{
				WriteIndicator(text, needWhitespace: false, whitespace: false, indentation: false);
			}
		}

		private void WriteIndicator(string indicator, bool needWhitespace, bool whitespace, bool indentation)
		{
			if (needWhitespace && !isWhitespace)
			{
				Write(' ');
			}
			Write(indicator);
			isWhitespace = whitespace;
			isIndentation &= indentation;
		}

		private void WriteIndent()
		{
			int num = Math.Max(indent, 0);
			if (!isIndentation || column > num || (column == num && !isWhitespace))
			{
				WriteBreak();
			}
			while (column < num)
			{
				Write(' ');
			}
			isWhitespace = true;
			isIndentation = true;
		}

		private void WriteAnchor(AnchorName value)
		{
			Write(value.Value);
			isWhitespace = false;
			isIndentation = false;
		}

		private void WriteTagHandle(string value)
		{
			if (!isWhitespace)
			{
				Write(' ');
			}
			Write(value);
			isWhitespace = false;
			isIndentation = false;
		}

		private void WriteTagContent(string value, bool needsWhitespace)
		{
			if (needsWhitespace && !isWhitespace)
			{
				Write(' ');
			}
			Write(UrlEncode(value));
			isWhitespace = false;
			isIndentation = false;
		}

		private static string UrlEncode(string text)
		{
			return UriReplacer.Replace(text, delegate(Match match)
			{
				StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
				try
				{
					StringBuilder builder = builderWrapper.Builder;
					byte[] bytes = Encoding.UTF8.GetBytes(match.Value);
					foreach (byte b in bytes)
					{
						builder.AppendFormat("%{0:X02}", b);
					}
					return builder.ToString();
				}
				finally
				{
					((IDisposable)builderWrapper).Dispose();
				}
			});
		}

		private void Write(char value)
		{
			output.Write(value);
			column++;
		}

		private void Write(string value)
		{
			output.Write(value);
			column += value.Length;
		}

		private void WriteBreak(char breakCharacter = '\n')
		{
			if (breakCharacter == '\n')
			{
				output.Write(newLine);
			}
			else
			{
				output.Write(breakCharacter);
			}
			column = 0;
		}
	}
	internal sealed class EmitterSettings
	{
		public static readonly EmitterSettings Default = new EmitterSettings();

		public int BestIndent { get; } = 2;


		public int BestWidth { get; } = int.MaxValue;


		public string NewLine { get; } = Environment.NewLine;


		public bool IsCanonical { get; }

		public bool SkipAnchorName { get; private set; }

		public int MaxSimpleKeyLength { get; } = 1024;


		public bool IndentSequences { get; }

		public EmitterSettings()
		{
		}

		public EmitterSettings(int bestIndent, int bestWidth, bool isCanonical, int maxSimpleKeyLength, bool skipAnchorName = false, bool indentSequences = false, string? newLine = null)
		{
			if (bestIndent < 2 || bestIndent > 9)
			{
				throw new ArgumentOutOfRangeException("bestIndent", "BestIndent must be between 2 and 9, inclusive");
			}
			if (bestWidth <= bestIndent * 2)
			{
				throw new ArgumentOutOfRangeException("bestWidth", "BestWidth must be greater than BestIndent x 2.");
			}
			if (maxSimpleKeyLength < 0)
			{
				throw new ArgumentOutOfRangeException("maxSimpleKeyLength", "MaxSimpleKeyLength must be >= 0");
			}
			BestIndent = bestIndent;
			BestWidth = bestWidth;
			IsCanonical = isCanonical;
			MaxSimpleKeyLength = maxSimpleKeyLength;
			SkipAnchorName = skipAnchorName;
			IndentSequences = indentSequences;
			NewLine = newLine ?? Environment.NewLine;
		}

		public EmitterSettings WithBestIndent(int bestIndent)
		{
			return new EmitterSettings(bestIndent, BestWidth, IsCanonical, MaxSimpleKeyLength, SkipAnchorName, IndentSequences, NewLine);
		}

		public EmitterSettings WithBestWidth(int bestWidth)
		{
			return new EmitterSettings(BestIndent, bestWidth, IsCanonical, MaxSimpleKeyLength, SkipAnchorName, IndentSequences, NewLine);
		}

		public EmitterSettings WithMaxSimpleKeyLength(int maxSimpleKeyLength)
		{
			return new EmitterSettings(BestIndent, BestWidth, IsCanonical, maxSimpleKeyLength, SkipAnchorName, IndentSequences, NewLine);
		}

		public EmitterSettings WithNewLine(string newLine)
		{
			return new EmitterSettings(BestIndent, BestWidth, IsCanonical, MaxSimpleKeyLength, SkipAnchorName, IndentSequences, newLine);
		}

		public EmitterSettings Canonical()
		{
			return new EmitterSettings(BestIndent, BestWidth, isCanonical: true, MaxSimpleKeyLength, SkipAnchorName);
		}

		public EmitterSettings WithoutAnchorName()
		{
			return new EmitterSettings(BestIndent, BestWidth, IsCanonical, MaxSimpleKeyLength, skipAnchorName: true, IndentSequences, NewLine);
		}

		public EmitterSettings WithIndentedSequences()
		{
			return new EmitterSettings(BestIndent, BestWidth, IsCanonical, MaxSimpleKeyLength, SkipAnchorName, indentSequences: true, NewLine);
		}
	}
	internal enum EmitterState
	{
		StreamStart,
		StreamEnd,
		FirstDocumentStart,
		DocumentStart,
		DocumentContent,
		DocumentEnd,
		FlowSequenceFirstItem,
		FlowSequenceItem,
		FlowMappingFirstKey,
		FlowMappingKey,
		FlowMappingSimpleValue,
		FlowMappingValue,
		BlockSequenceFirstItem,
		BlockSequenceItem,
		BlockMappingFirstKey,
		BlockMappingKey,
		BlockMappingSimpleValue,
		BlockMappingValue
	}
	internal sealed class ForwardAnchorNotSupportedException : YamlException
	{
		public ForwardAnchorNotSupportedException(string message)
			: base(message)
		{
		}

		public ForwardAnchorNotSupportedException(in Mark start, in Mark end, string message)
			: base(in start, in end, message)
		{
		}

		public ForwardAnchorNotSupportedException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	internal static class HashCode
	{
		public static int CombineHashCodes(int h1, int h2)
		{
			return ((h1 << 5) + h1) ^ h2;
		}

		public static int CombineHashCodes(int h1, object? o2)
		{
			return CombineHashCodes(h1, GetHashCode(o2));
		}

		private static int GetHashCode(object? obj)
		{
			return obj?.GetHashCode() ?? 0;
		}
	}
	internal interface IEmitter
	{
		void Emit(ParsingEvent @event);
	}
	internal interface ILookAheadBuffer
	{
		bool EndOfInput { get; }

		char Peek(int offset);

		void Skip(int length);
	}
	internal sealed class InsertionQueue<T> : IEnumerable<T>, IEnumerable
	{
		private const int DefaultInitialCapacity = 128;

		private T[] items;

		private int readPtr;

		private int writePtr;

		private int mask;

		private int count;

		public int Count => count;

		public int Capacity => items.Length;

		public InsertionQueue(int initialCapacity = 128)
		{
			if (initialCapacity <= 0)
			{
				throw new ArgumentOutOfRangeException("initialCapacity", "The initial capacity must be a positive number.");
			}
			if (!initialCapacity.IsPowerOfTwo())
			{
				throw new ArgumentException("The initial capacity must be a power of 2.", "initialCapacity");
			}
			items = new T[initialCapacity];
			readPtr = initialCapacity / 2;
			writePtr = initialCapacity / 2;
			mask = initialCapacity - 1;
		}

		public void Enqueue(T item)
		{
			ResizeIfNeeded();
			items[writePtr] = item;
			writePtr = (writePtr - 1) & mask;
			count++;
		}

		public T Dequeue()
		{
			if (count == 0)
			{
				throw new InvalidOperationException("The queue is empty");
			}
			T result = items[readPtr];
			readPtr = (readPtr - 1) & mask;
			count--;
			return result;
		}

		public void Insert(int index, T item)
		{
			if (index > count)
			{
				throw new InvalidOperationException("Cannot insert outside of the bounds of the queue");
			}
			ResizeIfNeeded();
			CalculateInsertionParameters(mask, count, index, ref readPtr, ref writePtr, out var insertPtr, out var copyIndex, out var copyOffset, out var copyLength);
			if (copyLength != 0)
			{
				Array.Copy(items, copyIndex, items, copyIndex + copyOffset, copyLength);
			}
			items[insertPtr] = item;
			count++;
		}

		private void ResizeIfNeeded()
		{
			int num = items.Length;
			if (count == num)
			{
				T[] destinationArray = new T[num * 2];
				int num2 = readPtr + 1;
				if (num2 > 0)
				{
					Array.Copy(items, 0, destinationArray, 0, num2);
				}
				writePtr += num;
				int num3 = num - num2;
				if (num3 > 0)
				{
					Array.Copy(items, readPtr + 1, destinationArray, writePtr + 1, num3);
				}
				items = destinationArray;
				mask = mask * 2 + 1;
			}
		}

		internal static void CalculateInsertionParameters(int mask, int count, int index, ref int readPtr, ref int writePtr, out int insertPtr, out int copyIndex, out int copyOffset, out int copyLength)
		{
			int num = (readPtr + 1) & mask;
			if (index == 0)
			{
				insertPtr = (readPtr = num);
				copyIndex = 0;
				copyOffset = 0;
				copyLength = 0;
				return;
			}
			insertPtr = (readPtr - index) & mask;
			if (index == count)
			{
				writePtr = (writePtr - 1) & mask;
				copyIndex = 0;
				copyOffset = 0;
				copyLength = 0;
				return;
			}
			int num2 = ((num >= insertPtr) ? (readPtr - insertPtr) : int.MaxValue);
			int num3 = ((writePtr <= insertPtr) ? (insertPtr - writePtr) : int.MaxValue);
			if (num2 <= num3)
			{
				insertPtr++;
				readPtr++;
				copyIndex = insertPtr;
				copyOffset = 1;
				copyLength = num2;
			}
			else
			{
				copyIndex = writePtr + 1;
				copyOffset = -1;
				copyLength = num3;
				writePtr = (writePtr - 1) & mask;
			}
		}

		public IEnumerator<T> GetEnumerator()
		{
			int ptr = readPtr;
			for (int i = 0; i < Count; i++)
			{
				yield return items[ptr];
				ptr = (ptr - 1) & mask;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal interface IParser
	{
		ParsingEvent? Current { get; }

		bool MoveNext();
	}
	internal interface IScanner
	{
		Mark CurrentPosition { get; }

		Token? Current { get; }

		bool MoveNext();

		bool MoveNextWithoutConsuming();

		void ConsumeCurrent();
	}
	[DebuggerStepThrough]
	internal sealed class LookAheadBuffer : ILookAheadBuffer
	{
		private readonly TextReader input;

		private readonly char[] buffer;

		private readonly int blockSize;

		private readonly int mask;

		private int firstIndex;

		private int writeOffset;

		private int count;

		private bool endOfInput;

		public bool EndOfInput
		{
			get
			{
				if (endOfInput)
				{
					return count == 0;
				}
				return false;
			}
		}

		public LookAheadBuffer(TextReader input, int capacity)
		{
			if (capacity < 1)
			{
				throw new ArgumentOutOfRangeException("capacity", "The capacity must be positive.");
			}
			if (!capacity.IsPowerOfTwo())
			{
				throw new ArgumentException("The capacity must be a power of 2.", "capacity");
			}
			this.input = input ?? throw new ArgumentNullException("input");
			blockSize = capacity;
			buffer = new char[capacity * 2];
			mask = capacity * 2 - 1;
		}

		private int GetIndexForOffset(int offset)
		{
			return (firstIndex + offset) & mask;
		}

		public char Peek(int offset)
		{
			if (offset >= count)
			{
				FillBuffer();
			}
			if (offset < count)
			{
				return buffer[(firstIndex + offset) & mask];
			}
			return '\0';
		}

		public void Cache(int length)
		{
			if (length >= count)
			{
				FillBuffer();
			}
		}

		private void FillBuffer()
		{
			if (endOfInput)
			{
				return;
			}
			int num = blockSize;
			do
			{
				int num2 = input.Read(buffer, writeOffset, num);
				if (num2 == 0)
				{
					endOfInput = true;
					return;
				}
				num -= num2;
				writeOffset += num2;
				count += num2;
			}
			while (num > 0);
			if (writeOffset == buffer.Length)
			{
				writeOffset = 0;
			}
		}

		public void Skip(int length)
		{
			if (length < 1 || length > blockSize)
			{
				throw new ArgumentOutOfRangeException("length", "The length must be between 1 and the number of characters in the buffer. Use the Peek() and / or Cache() methods to fill the buffer.");
			}
			firstIndex = GetIndexForOffset(length);
			count -= length;
		}
	}
	internal readonly struct Mark : IEquatable<Mark>, IComparable<Mark>, IComparable
	{
		public static readonly Mark Empty = new Mark(0, 1, 1);

		public int Index { get; }

		public int Line { get; }

		public int Column { get; }

		public Mark(int index, int line, int column)
		{
			if (index < 0)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException("index", "Index must be greater than or equal to zero.");
			}
			if (line < 1)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException("line", "Line must be greater than or equal to 1.");
			}
			if (column < 1)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException("column", "Column must be greater than or equal to 1.");
			}
			Index = index;
			Line = line;
			Column = column;
		}

		public override string ToString()
		{
			return $"Line: {Line}, Col: {Column}, Idx: {Index}";
		}

		public override bool Equals(object? obj)
		{
			return Equals((Mark)(obj ?? ((object)Empty)));
		}

		public bool Equals(Mark other)
		{
			if (Index == other.Index && Line == other.Line)
			{
				return Column == other.Column;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.CombineHashCodes(Index.GetHashCode(), HashCode.CombineHashCodes(Line.GetHashCode(), Column.GetHashCode()));
		}

		public int CompareTo(object? obj)
		{
			return CompareTo((Mark)(obj ?? ((object)Empty)));
		}

		public int CompareTo(Mark other)
		{
			int num = Line.CompareTo(other.Line);
			if (num == 0)
			{
				num = Column.CompareTo(other.Column);
			}
			return num;
		}
	}
	internal sealed class MaximumRecursionLevelReachedException : YamlException
	{
		public MaximumRecursionLevelReachedException(string message)
			: base(message)
		{
		}

		public MaximumRecursionLevelReachedException(in Mark start, in Mark end, string message)
			: base(in start, in end, message)
		{
		}

		public MaximumRecursionLevelReachedException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	internal sealed class MergingParser : IParser
	{
		private sealed class ParsingEventCollection : IEnumerable<LinkedListNode<ParsingEvent>>, IEnumerable
		{
			private readonly LinkedList<ParsingEvent> events;

			private readonly HashSet<LinkedListNode<ParsingEvent>> deleted;

			private readonly Dictionary<AnchorName, LinkedListNode<ParsingEvent>> references;

			public ParsingEventCollection()
			{
				events = new LinkedList<ParsingEvent>();
				deleted = new HashSet<LinkedListNode<ParsingEvent>>();
				references = new Dictionary<AnchorName, LinkedListNode<ParsingEvent>>();
			}

			public void AddAfter(LinkedListNode<ParsingEvent> node, IEnumerable<ParsingEvent> items)
			{
				foreach (ParsingEvent item in items)
				{
					node = events.AddAfter(node, item);
				}
			}

			public void Add(ParsingEvent item)
			{
				LinkedListNode<ParsingEvent> node = events.AddLast(item);
				AddReference(item, node);
			}

			public void MarkDeleted(LinkedListNode<ParsingEvent> node)
			{
				deleted.Add(node);
			}

			public bool IsDeleted(LinkedListNode<ParsingEvent> node)
			{
				return deleted.Contains(node);
			}

			public void CleanMarked()
			{
				foreach (LinkedListNode<ParsingEvent> item in deleted)
				{
					events.Remove(item);
				}
			}

			public IEnumerable<LinkedListNode<ParsingEvent>> FromAnchor(AnchorName anchor)
			{
				LinkedListNode<ParsingEvent> next = references[anchor].Next;
				return Enumerate(next);
			}

			public IEnumerator<LinkedListNode<ParsingEvent>> GetEnumerator()
			{
				return Enumerate(events.First).GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			private IEnumerable<LinkedListNode<ParsingEvent>> Enumerate(LinkedListNode<ParsingEvent>? node)
			{
				while (node != null)
				{
					yield return node;
					node = node.Next;
				}
			}

			private void AddReference(ParsingEvent item, LinkedListNode<ParsingEvent> node)
			{
				if (item is MappingStart mappingStart)
				{
					AnchorName anchor = mappingStart.Anchor;
					if (!anchor.IsEmpty)
					{
						references[anchor] = node;
					}
				}
			}
		}

		private sealed class ParsingEventCloner : IParsingEventVisitor
		{
			private ParsingEvent? clonedEvent;

			public ParsingEvent Clone(ParsingEvent e)
			{
				e.Accept(this);
				if (clonedEvent == null)
				{
					throw new InvalidOperationException($"Could not clone event of type '{e.Type}'");
				}
				return clonedEvent;
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.AnchorAlias e)
			{
				clonedEvent = new YamlDotNet.Core.Events.AnchorAlias(e.Value, e.Start, e.End);
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.StreamStart e)
			{
				throw new NotSupportedException();
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.StreamEnd e)
			{
				throw new NotSupportedException();
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.DocumentStart e)
			{
				throw new NotSupportedException();
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.DocumentEnd e)
			{
				throw new NotSupportedException();
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.Scalar e)
			{
				clonedEvent = new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, e.Tag, e.Value, e.Style, e.IsPlainImplicit, e.IsQuotedImplicit, e.Start, e.End);
			}

			void IParsingEventVisitor.Visit(SequenceStart e)
			{
				clonedEvent = new SequenceStart(AnchorName.Empty, e.Tag, e.IsImplicit, e.Style, e.Start, e.End);
			}

			void IParsingEventVisitor.Visit(SequenceEnd e)
			{
				Mark start = e.Start;
				Mark end = e.End;
				clonedEvent = new SequenceEnd(in start, in end);
			}

			void IParsingEventVisitor.Visit(MappingStart e)
			{
				clonedEvent = new MappingStart(AnchorName.Empty, e.Tag, e.IsImplicit, e.Style, e.Start, e.End);
			}

			void IParsingEventVisitor.Visit(MappingEnd e)
			{
				Mark start = e.Start;
				Mark end = e.End;
				clonedEvent = new MappingEnd(in start, in end);
			}

			void IParsingEventVisitor.Visit(YamlDotNet.Core.Events.Comment e)
			{
				throw new NotSupportedException();
			}
		}

		private readonly ParsingEventCollection events;

		private readonly IParser innerParser;

		private IEnumerator<LinkedListNode<ParsingEvent>> iterator;

		private bool merged;

		public ParsingEvent? Current => iterator.Current?.Value;

		public MergingParser(IParser innerParser)
		{
			events = new ParsingEventCollection();
			merged = false;
			iterator = events.GetEnumerator();
			this.innerParser = innerParser;
		}

		public bool MoveNext()
		{
			if (!merged)
			{
				Merge();
				events.CleanMarked();
				iterator = events.GetEnumerator();
				merged = true;
			}
			return iterator.MoveNext();
		}

		private void Merge()
		{
			while (innerParser.MoveNext())
			{
				events.Add(innerParser.Current);
			}
			foreach (LinkedListNode<ParsingEvent> @event in events)
			{
				if (IsMergeToken(@event))
				{
					events.MarkDeleted(@event);
					if (!HandleMerge(@event.Next))
					{
						Mark start = @event.Value.Start;
						Mark end = @event.Value.End;
						throw new SemanticErrorException(in start, in end, "Unrecognized merge key pattern");
					}
				}
			}
		}

		private bool HandleMerge(LinkedListNode<ParsingEvent>? node)
		{
			if (node == null)
			{
				return false;
			}
			if (node.Value is YamlDotNet.Core.Events.AnchorAlias anchorAlias)
			{
				return HandleAnchorAlias(node, node, anchorAlias);
			}
			if (node.Value is SequenceStart)
			{
				return HandleSequence(node);
			}
			return false;
		}

		private bool HandleMergeSequence(LinkedListNode<ParsingEvent> sequenceStart, LinkedListNode<ParsingEvent>? node)
		{
			if (node == null)
			{
				return false;
			}
			if (node.Value is YamlDotNet.Core.Events.AnchorAlias anchorAlias)
			{
				return HandleAnchorAlias(sequenceStart, node, anchorAlias);
			}
			if (node.Value is SequenceStart)
			{
				return HandleSequence(node);
			}
			return false;
		}

		private bool IsMergeToken(LinkedListNode<ParsingEvent> node)
		{
			if (node.Value is YamlDotNet.Core.Events.Scalar scalar)
			{
				return scalar.Value == "<<";
			}
			return false;
		}

		private bool HandleAnchorAlias(LinkedListNode<ParsingEvent> node, LinkedListNode<ParsingEvent> anchorNode, YamlDotNet.Core.Events.AnchorAlias anchorAlias)
		{
			IEnumerable<ParsingEvent> mappingEvents = GetMappingEvents(anchorAlias.Value);
			events.AddAfter(node, mappingEvents);
			events.MarkDeleted(anchorNode);
			return true;
		}

		private bool HandleSequence(LinkedListNode<ParsingEvent> node)
		{
			events.MarkDeleted(node);
			LinkedListNode<ParsingEvent> linkedListNode = node;
			while (linkedListNode != null)
			{
				if (linkedListNode.Value is SequenceEnd)
				{
					events.MarkDeleted(linkedListNode);
					return true;
				}
				LinkedListNode<ParsingEvent> next = linkedListNode.Next;
				HandleMergeSequence(node, next);
				linkedListNode = next;
			}
			return true;
		}

		private IEnumerable<ParsingEvent> GetMappingEvents(AnchorName anchor)
		{
			ParsingEventCloner cloner = new ParsingEventCloner();
			int nesting = 0;
			return from e in (from e in events.FromAnchor(anchor)
					where !events.IsDeleted(e)
					select e.Value).TakeWhile((ParsingEvent e) => (nesting += e.NestingIncrease) >= 0)
				select cloner.Clone(e);
		}
	}
	internal class Parser : IParser
	{
		private class EventQueue
		{
			private readonly Queue<ParsingEvent> highPriorityEvents = new Queue<ParsingEvent>();

			private readonly Queue<ParsingEvent> normalPriorityEvents = new Queue<ParsingEvent>();

			public int Count => highPriorityEvents.Count + normalPriorityEvents.Count;

			public void Enqueue(ParsingEvent @event)
			{
				EventType type = @event.Type;
				if (type == EventType.StreamStart || type == EventType.DocumentStart)
				{
					highPriorityEvents.Enqueue(@event);
				}
				else
				{
					normalPriorityEvents.Enqueue(@event);
				}
			}

			public ParsingEvent Dequeue()
			{
				if (highPriorityEvents.Count <= 0)
				{
					return normalPriorityEvents.Dequeue();
				}
				return highPriorityEvents.Dequeue();
			}
		}

		private readonly Stack<ParserState> states = new Stack<ParserState>();

		private readonly TagDirectiveCollection tagDirectives = new TagDirectiveCollection();

		private ParserState state;

		private readonly IScanner scanner;

		private Token? currentToken;

		private VersionDirective? version;

		private readonly EventQueue pendingEvents = new EventQueue();

		public ParsingEvent? Current { get; private set; }

		private Token? GetCurrentToken()
		{
			if (currentToken == null)
			{
				while (scanner.MoveNextWithoutConsuming())
				{
					currentToken = scanner.Current;
					if (!(currentToken is YamlDotNet.Core.Tokens.Comment comment))
					{
						break;
					}
					pendingEvents.Enqueue(new YamlDotNet.Core.Events.Comment(comment.Value, comment.IsInline, comment.Start, comment.End));
					scanner.ConsumeCurrent();
				}
			}
			return currentToken;
		}

		public Parser(TextReader input)
			: this(new Scanner(input))
		{
		}

		public Parser(IScanner scanner)
		{
			this.scanner = scanner;
		}

		public bool MoveNext()
		{
			if (state == ParserState.StreamEnd)
			{
				Current = null;
				return false;
			}
			if (pendingEvents.Count == 0)
			{
				pendingEvents.Enqueue(StateMachine());
			}
			Current = pendingEvents.Dequeue();
			return true;
		}

		private ParsingEvent StateMachine()
		{
			return state switch
			{
				ParserState.StreamStart => ParseStreamStart(), 
				ParserState.ImplicitDocumentStart => ParseDocumentStart(isImplicit: true), 
				ParserState.DocumentStart => ParseDocumentStart(isImplicit: false), 
				ParserState.DocumentContent => ParseDocumentContent(), 
				ParserState.DocumentEnd => ParseDocumentEnd(), 
				ParserState.BlockNode => ParseNode(isBlock: true, isIndentlessSequence: false), 
				ParserState.BlockNodeOrIndentlessSequence => ParseNode(isBlock: true, isIndentlessSequence: true), 
				ParserState.FlowNode => ParseNode(isBlock: false, isIndentlessSequence: false), 
				ParserState.BlockSequenceFirstEntry => ParseBlockSequenceEntry(isFirst: true), 
				ParserState.BlockSequenceEntry => ParseBlockSequenceEntry(isFirst: false), 
				ParserState.IndentlessSequenceEntry => ParseIndentlessSequenceEntry(), 
				ParserState.BlockMappingFirstKey => ParseBlockMappingKey(isFirst: true), 
				ParserState.BlockMappingKey => ParseBlockMappingKey(isFirst: false), 
				ParserState.BlockMappingValue => ParseBlockMappingValue(), 
				ParserState.FlowSequenceFirstEntry => ParseFlowSequenceEntry(isFirst: true), 
				ParserState.FlowSequenceEntry => ParseFlowSequenceEntry(isFirst: false), 
				ParserState.FlowSequenceEntryMappingKey => ParseFlowSequenceEntryMappingKey(), 
				ParserState.FlowSequenceEntryMappingValue => ParseFlowSequenceEntryMappingValue(), 
				ParserState.FlowSequenceEntryMappingEnd => ParseFlowSequenceEntryMappingEnd(), 
				ParserState.FlowMappingFirstKey => ParseFlowMappingKey(isFirst: true), 
				ParserState.FlowMappingKey => ParseFlowMappingKey(isFirst: false), 
				ParserState.FlowMappingValue => ParseFlowMappingValue(isEmpty: false), 
				ParserState.FlowMappingEmptyValue => ParseFlowMappingValue(isEmpty: true), 
				_ => throw new InvalidOperationException(), 
			};
		}

		private void Skip()
		{
			if (currentToken != null)
			{
				currentToken = null;
				scanner.ConsumeCurrent();
			}
		}

		private ParsingEvent ParseStreamStart()
		{
			Token token = GetCurrentToken();
			Mark start;
			Mark end;
			if (!(token is YamlDotNet.Core.Tokens.StreamStart streamStart))
			{
				start = token?.Start ?? Mark.Empty;
				end = token?.End ?? Mark.Empty;
				throw new SemanticErrorException(in start, in end, "Did not find expected <stream-start>.");
			}
			Skip();
			state = ParserState.ImplicitDocumentStart;
			start = streamStart.Start;
			end = streamStart.End;
			return new YamlDotNet.Core.Events.StreamStart(in start, in end);
		}

		private ParsingEvent ParseDocumentStart(bool isImplicit)
		{
			if (currentToken is VersionDirective)
			{
				throw new SyntaxErrorException("While parsing a document start node, could not find document end marker before version directive.");
			}
			Token token = GetCurrentToken();
			if (!isImplicit)
			{
				while (token is YamlDotNet.Core.Tokens.DocumentEnd)
				{
					Skip();
					token = GetCurrentToken();
				}
			}
			if (token == null)
			{
				throw new SyntaxErrorException("Reached the end of the stream while parsing a document start.");
			}
			if (token is YamlDotNet.Core.Tokens.Scalar && (state == ParserState.ImplicitDocumentStart || state == ParserState.DocumentStart))
			{
				isImplicit = true;
			}
			if ((isImplicit && !(token is VersionDirective) && !(token is TagDirective) && !(token is YamlDotNet.Core.Tokens.DocumentStart) && !(token is YamlDotNet.Core.Tokens.StreamEnd) && !(token is YamlDotNet.Core.Tokens.DocumentEnd)) || token is BlockMappingStart)
			{
				TagDirectiveCollection tags = new TagDirectiveCollection();
				ProcessDirectives(tags);
				states.Push(ParserState.DocumentEnd);
				state = ParserState.BlockNode;
				return new YamlDotNet.Core.Events.DocumentStart(null, tags, isImplicit: true, token.Start, token.End);
			}
			Mark start2;
			Mark end;
			if (!(token is YamlDotNet.Core.Tokens.StreamEnd) && !(token is YamlDotNet.Core.Tokens.DocumentEnd))
			{
				Mark start = token.Start;
				TagDirectiveCollection tags2 = new TagDirectiveCollection();
				VersionDirective? versionDirective = ProcessDirectives(tags2);
				token = GetCurrentToken() ?? throw new SemanticErrorException("Reached the end of the stream while parsing a document start");
				if (!(token is YamlDotNet.Core.Tokens.DocumentStart))
				{
					start2 = token.Start;
					end = token.End;
					throw new SemanticErrorException(in start2, in end, "Did not find expected <document start>.");
				}
				states.Push(ParserState.DocumentEnd);
				state = ParserState.DocumentContent;
				Mark end2 = token.End;
				Skip();
				return new YamlDotNet.Core.Events.DocumentStart(versionDirective, tags2, isImplicit: false, start, end2);
			}
			if (token is YamlDotNet.Core.Tokens.DocumentEnd)
			{
				Skip();
			}
			state = ParserState.StreamEnd;
			token = GetCurrentToken() ?? throw new SemanticErrorException("Reached the end of the stream while parsing a document start");
			start2 = token.Start;
			end = token.End;
			YamlDotNet.Core.Events.StreamEnd result = new YamlDotNet.Core.Events.StreamEnd(in start2, in end);
			if (scanner.MoveNextWithoutConsuming())
			{
				throw new InvalidOperationException("The scanner should contain no more tokens.");
			}
			return result;
		}

		private VersionDirective? ProcessDirectives(TagDirectiveCollection tags)
		{
			bool flag = false;
			VersionDirective result = null;
			while (true)
			{
				if (GetCurrentToken() is VersionDirective versionDirective)
				{
					if (version != null)
					{
						Mark start = versionDirective.Start;
						Mark end = versionDirective.End;
						throw new SemanticErrorException(in start, in end, "Found duplicate %YAML directive.");
					}
					if (versionDirective.Version.Major != 1 || versionDirective.Version.Minor > 3)
					{
						Mark start = versionDirective.Start;
						Mark end = versionDirective.End;
						throw new SemanticErrorException(in start, in end, "Found incompatible YAML document.");
					}
					result = (version = versionDirective);
					flag = true;
				}
				else
				{
					if (!(GetCurrentToken() is TagDirective tagDirective))
					{
						break;
					}
					if (tags.Contains(tagDirective.Handle))
					{
						Mark start = tagDirective.Start;
						Mark end = tagDirective.End;
						throw new SemanticErrorException(in start, in end, "Found duplicate %TAG directive.");
					}
					tags.Add(tagDirective);
					flag = true;
				}
				Skip();
			}
			if (GetCurrentToken() is YamlDotNet.Core.Tokens.DocumentStart && (version == null || (version.Version.Major == 1 && version.Version.Minor > 1)))
			{
				if (GetCurrentToken() is YamlDotNet.Core.Tokens.DocumentStart && version == null)
				{
					version = new VersionDirective(new Version(1, 2));
				}
				flag = true;
			}
			AddTagDirectives(tags, Constants.DefaultTagDirectives);
			if (flag)
			{
				tagDirectives.Clear();
			}
			AddTagDirectives(tagDirectives, tags);
			return result;
		}

		private static void AddTagDirectives(TagDirectiveCollection directives, IEnumerable<TagDirective> source)
		{
			foreach (TagDirective item in source)
			{
				if (!directives.Contains(item))
				{
					directives.Add(item);
				}
			}
		}

		private ParsingEvent ParseDocumentContent()
		{
			if (GetCurrentToken() is VersionDirective || GetCurrentToken() is TagDirective || GetCurrentToken() is YamlDotNet.Core.Tokens.DocumentStart || GetCurrentToken() is YamlDotNet.Core.Tokens.DocumentEnd || GetCurrentToken() is YamlDotNet.Core.Tokens.StreamEnd)
			{
				state = states.Pop();
				Mark position = scanner.CurrentPosition;
				return ProcessEmptyScalar(in position);
			}
			return ParseNode(isBlock: true, isIndentlessSequence: false);
		}

		private static ParsingEvent ProcessEmptyScalar(in Mark position)
		{
			return new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, TagName.Empty, string.Empty, ScalarStyle.Plain, isPlainImplicit: true, isQuotedImplicit: false, position, position);
		}

		private ParsingEvent ParseNode(bool isBlock, bool isIndentlessSequence)
		{
			Mark start;
			Mark end;
			if (GetCurrentToken() is Error error)
			{
				start = error.Start;
				end = error.End;
				throw new SemanticErrorException(in start, in end, error.Value);
			}
			Token token = GetCurrentToken() ?? throw new SemanticErrorException("Reached the end of the stream while parsing a node");
			if (token is YamlDotNet.Core.Tokens.AnchorAlias anchorAlias)
			{
				state = states.Pop();
				YamlDotNet.Core.Events.AnchorAlias result = new YamlDotNet.Core.Events.AnchorAlias(anchorAlias.Value, anchorAlias.Start, anchorAlias.End);
				Skip();
				return result;
			}
			Mark start2 = token.Start;
			AnchorName anchor = AnchorName.Empty;
			TagName tag = TagName.Empty;
			Anchor anchor2 = null;
			Tag tag2 = null;
			while (true)
			{
				if (anchor.IsEmpty && token is Anchor anchor3)
				{
					anchor2 = anchor3;
					anchor = anchor3.Value;
					Skip();
				}
				else
				{
					if (!tag.IsEmpty || !(token is Tag tag3))
					{
						if (token is Anchor anchor4)
						{
							start = anchor4.Start;
							end = anchor4.End;
							throw new SemanticErrorException(in start, in end, "While parsing a node, found more than one anchor.");
						}
						if (token is YamlDotNet.Core.Tokens.AnchorAlias anchorAlias2)
						{
							start = anchorAlias2.Start;
							end = anchorAlias2.End;
							throw new SemanticErrorException(in start, in end, "While parsing a node, did not find expected token.");
						}
						if (!(token is Error error2))
						{
							break;
						}
						if (tag2 != null && anchor2 != null && !anchor.IsEmpty)
						{
							return new YamlDotNet.Core.Events.Scalar(anchor, default(TagName), string.Empty, ScalarStyle.Any, isPlainImplicit: false, isQuotedImplicit: false, anchor2.Start, anchor2.End);
						}
						start = error2.Start;
						end = error2.End;
						throw new SemanticErrorException(in start, in end, error2.Value);
					}
					tag2 = tag3;
					if (string.IsNullOrEmpty(tag3.Handle))
					{
						tag = new TagName(tag3.Suffix);
					}
					else
					{
						if (!tagDirectives.Contains(tag3.Handle))
						{
							start = tag3.Start;
							end = tag3.End;
							throw new SemanticErrorException(in start, in end, "While parsing a node, found undefined tag handle.");
						}
						tag = new TagName(tagDirectives[tag3.Handle].Prefix + tag3.Suffix);
					}
					Skip();
				}
				token = GetCurrentToken() ?? throw new SemanticErrorException("Reached the end of the stream while parsing a node");
			}
			bool isEmpty = tag.IsEmpty;
			if (isIndentlessSequence && GetCurrentToken() is BlockEntry)
			{
				state = ParserState.IndentlessSequenceEntry;
				return new SequenceStart(anchor, tag, isEmpty, SequenceStyle.Block, start2, token.End);
			}
			if (token is YamlDotNet.Core.Tokens.Scalar scalar)
			{
				bool isPlainImplicit = false;
				bool isQuotedImplicit = false;
				if ((scalar.Style == ScalarStyle.Plain && tag.IsEmpty) || tag.IsNonSpecific)
				{
					isPlainImplicit = true;
				}
				else if (tag.IsEmpty)
				{
					isQuotedImplicit = true;
				}
				state = states.Pop();
				Skip();
				YamlDotNet.Core.Events.Scalar result2 = new YamlDotNet.Core.Events.Scalar(anchor, tag, scalar.Value, scalar.Style, isPlainImplicit, isQuotedImplicit, start2, scalar.End, scalar.IsKey);
				if (!anchor.IsEmpty && scanner.MoveNextWithoutConsuming())
				{
					currentToken = scanner.Current;
					if (currentToken is Error)
					{
						Error error3 = currentToken as Error;
						start = error3.Start;
						end = error3.End;
						throw new SemanticErrorException(in start, in end, error3.Value);
					}
				}
				if (state == ParserState.FlowMappingKey && scanner.MoveNextWithoutConsuming())
				{
					currentToken = scanner.Current;
					if (currentToken != null && !(currentToken is FlowEntry) && !(currentToken is FlowMappingEnd))
					{
						start = currentToken.Start;
						end = currentToken.End;
						throw new SemanticErrorException(in start, in end, "While parsing a flow mapping, did not find expected ',' or '}'.");
					}
				}
				return result2;
			}
			if (token is FlowSequenceStart flowSequenceStart)
			{
				state = ParserState.FlowSequenceFirstEntry;
				return new SequenceStart(anchor, tag, isEmpty, SequenceStyle.Flow, start2, flowSequenceStart.End);
			}
			if (token is FlowMappingStart flowMappingStart)
			{
				state = ParserState.FlowMappingFirstKey;
				return new MappingStart(anchor, tag, isEmpty, MappingStyle.Flow, start2, flowMappingStart.End);
			}
			if (isBlock)
			{
				if (token is BlockSequenceStart blockSequenceStart)
				{
					state = ParserState.BlockSequenceFirstEntry;
					return new SequenceStart(anchor, tag, isEmpty, SequenceStyle.Block, start2, blockSequenceStart.End);
				}
				if (token is BlockMappingStart blockMappingStart)
				{
					state = ParserState.BlockMappingFirstKey;
					return new MappingStart(anchor, tag, isEmpty, MappingStyle.Block, start2, blockMappingStart.End);
				}
			}
			if (!anchor.IsEmpty || !tag.IsEmpty)
			{
				state = states.Pop();
				return new YamlDotNet.Core.Events.Scalar(anchor, tag, string.Empty, ScalarStyle.Plain, isEmpty, isQuotedImplicit: false, start2, token.End);
			}
			start = token.Start;
			end = token.End;
			throw new SemanticErrorException(in start, in end, "While parsing a node, did not find expected node content.");
		}

		private ParsingEvent ParseDocumentEnd()
		{
			Token token = GetCurrentToken() ?? throw new SemanticErrorException("Reached the end of the stream while parsing a document end");
			bool isImplicit = true;
			Mark start = token.Start;
			Mark end = start;
			if (token is YamlDotNet.Core.Tokens.DocumentEnd)
			{
				end = token.End;
				Skip();
				isImplicit = false;
			}
			else if (!(currentToken is YamlDotNet.Core.Tokens.StreamEnd) && !(currentToken is YamlDotNet.Core.Tokens.DocumentStart) && !(currentToken is FlowSequenceEnd) && !(currentToken is VersionDirective) && (!(Current is YamlDotNet.Core.Events.Scalar) || !(currentToken is Error)))
			{
				throw new SemanticErrorException(in start, in end, "Did not find expected <document end>.");
			}
			if (version != null && version.Version.Major == 1 && version.Version.Minor > 1)
			{
				version = null;
			}
			state = ParserState.DocumentStart;
			return new YamlDotNet.Core.Events.DocumentEnd(isImplicit, start, end);
		}

		private ParsingEvent ParseBlockSequenceEntry(bool isFirst)
		{
			if (isFirst)
			{
				GetCurrentToken();
				Skip();
			}
			Token token = GetCurrentToken();
			if (token is BlockEntry blockEntry)
			{
				Mark position = blockEntry.End;
				Skip();
				token = GetCurrentToken();
				if (!(token is BlockEntry) && !(token is BlockEnd))
				{
					states.Push(ParserState.BlockSequenceEntry);
					return ParseNode(isBlock: true, isIndentlessSequence: false);
				}
				state = ParserState.BlockSequenceEntry;
				return ProcessEmptyScalar(in position);
			}
			Mark start;
			Mark end;
			if (token is BlockEnd blockEnd)
			{
				state = states.Pop();
				start = blockEnd.Start;
				end = blockEnd.End;
				SequenceEnd result = new SequenceEnd(in start, in end);
				Skip();
				return result;
			}
			start = token?.Start ?? Mark.Empty;
			end = token?.End ?? Mark.Empty;
			throw new SemanticErrorException(in start, in end, "While parsing a block collection, did not find expected '-' indicator.");
		}

		private ParsingEvent ParseIndentlessSequenceEntry()
		{
			Token token = GetCurrentToken();
			if (token is BlockEntry blockEntry)
			{
				Mark position = blockEntry.End;
				Skip();
				token = GetCurrentToken();
				if (!(token is BlockEntry) && !(token is Key) && !(token is Value) && !(token is BlockEnd))
				{
					states.Push(ParserState.IndentlessSequenceEntry);
					return ParseNode(isBlock: true, isIndentlessSequence: false);
				}
				state = ParserState.IndentlessSequenceEntry;
				return ProcessEmptyScalar(in position);
			}
			state = states.Pop();
			Mark start = token?.Start ?? Mark.Empty;
			Mark end = token?.End ?? Mark.Empty;
			return new SequenceEnd(in start, in end);
		}

		private ParsingEvent ParseBlockMappingKey(bool isFirst)
		{
			if (isFirst)
			{
				GetCurrentToken();
				Skip();
			}
			Token token = GetCurrentToken();
			if (token is Key key)
			{
				Mark position = key.End;
				Skip();
				token = GetCurrentToken();
				if (!(token is Key) && !(token is Value) && !(token is BlockEnd))
				{
					states.Push(ParserState.BlockMappingValue);
					return ParseNode(isBlock: true, isIndentlessSequence: true);
				}
				state = ParserState.BlockMappingValue;
				return ProcessEmptyScalar(in position);
			}
			Mark position2;
			if (token is Value value)
			{
				Skip();
				position2 = value.End;
				return ProcessEmptyScalar(in position2);
			}
			if (token is YamlDotNet.Core.Tokens.AnchorAlias anchorAlias)
			{
				Skip();
				return new YamlDotNet.Core.Events.AnchorAlias(anchorAlias.Value, anchorAlias.Start, anchorAlias.End);
			}
			Mark end;
			if (token is BlockEnd blockEnd)
			{
				state = states.Pop();
				position2 = blockEnd.Start;
				end = blockEnd.End;
				MappingEnd result = new MappingEnd(in position2, in end);
				Skip();
				return result;
			}
			if (GetCurrentToken() is Error error)
			{
				position2 = error.Start;
				end = error.End;
				throw new SyntaxErrorException(in position2, in end, error.Value);
			}
			position2 = token?.Start ?? Mark.Empty;
			end = token?.End ?? Mark.Empty;
			throw new SemanticErrorException(in position2, in end, "While parsing a block mapping, did not find expected key.");
		}

		private ParsingEvent ParseBlockMappingValue()
		{
			Token token = GetCurrentToken();
			if (token is Value value)
			{
				Mark position = value.End;
				Skip();
				token = GetCurrentToken();
				if (!(token is Key) && !(token is Value) && !(token is BlockEnd))
				{
					states.Push(ParserState.BlockMappingKey);
					return ParseNode(isBlock: true, isIndentlessSequence: true);
				}
				state = ParserState.BlockMappingKey;
				return ProcessEmptyScalar(in position);
			}
			Mark start;
			if (token is Error error)
			{
				start = error.Start;
				Mark end = error.End;
				throw new SemanticErrorException(in start, in end, error.Value);
			}
			state = ParserState.BlockMappingKey;
			start = token?.Start ?? Mark.Empty;
			return ProcessEmptyScalar(in start);
		}

		private ParsingEvent ParseFlowSequenceEntry(bool isFirst)
		{
			if (isFirst)
			{
				GetCurrentToken();
				Skip();
			}
			Token token = GetCurrentToken();
			Mark start;
			Mark end;
			if (!(token is FlowSequenceEnd))
			{
				if (!isFirst)
				{
					if (!(token is FlowEntry))
					{
						start = token?.Start ?? Mark.Empty;
						end = token?.End ?? Mark.Empty;
						throw new SemanticErrorException(in start, in end, "While parsing a flow sequence, did not find expected ',' or ']'.");
					}
					Skip();
					token = GetCurrentToken();
				}
				if (token is Key)
				{
					state = ParserState.FlowSequenceEntryMappingKey;
					MappingStart result = new MappingStart(AnchorName.Empty, TagName.Empty, isImplicit: true, MappingStyle.Flow);
					Skip();
					return result;
				}
				if (!(token is FlowSequenceEnd))
				{
					states.Push(ParserState.FlowSequenceEntry);
					return ParseNode(isBlock: false, isIndentlessSequence: false);
				}
			}
			state = states.Pop();
			start = token?.Start ?? Mark.Empty;
			end = token?.End ?? Mark.Empty;
			SequenceEnd result2 = new SequenceEnd(in start, in end);
			Skip();
			return result2;
		}

		private ParsingEvent ParseFlowSequenceEntryMappingKey()
		{
			Token token = GetCurrentToken();
			if (!(token is Value) && !(token is FlowEntry) && !(token is FlowSequenceEnd))
			{
				states.Push(ParserState.FlowSequenceEntryMappingValue);
				return ParseNode(isBlock: false, isIndentlessSequence: false);
			}
			Mark position = token?.End ?? Mark.Empty;
			Skip();
			state = ParserState.FlowSequenceEntryMappingValue;
			return ProcessEmptyScalar(in position);
		}

		private ParsingEvent ParseFlowSequenceEntryMappingValue()
		{
			Token token = GetCurrentToken();
			if (token is Value)
			{
				Skip();
				token = GetCurrentToken();
				if (!(token is FlowEntry) && !(token is FlowSequenceEnd))
				{
					states.Push(ParserState.FlowSequenceEntryMappingEnd);
					return ParseNode(isBlock: false, isIndentlessSequence: false);
				}
			}
			state = ParserState.FlowSequenceEntryMappingEnd;
			Mark position = token?.Start ?? Mark.Empty;
			return ProcessEmptyScalar(in position);
		}

		private ParsingEvent ParseFlowSequenceEntryMappingEnd()
		{
			state = ParserState.FlowSequenceEntry;
			Token token = GetCurrentToken();
			Mark start = token?.Start ?? Mark.Empty;
			Mark end = token?.End ?? Mark.Empty;
			return new MappingEnd(in start, in end);
		}

		private ParsingEvent ParseFlowMappingKey(bool isFirst)
		{
			if (isFirst)
			{
				GetCurrentToken();
				Skip();
			}
			Token token = GetCurrentToken();
			Mark start;
			Mark end;
			if (!(token is FlowMappingEnd))
			{
				if (!isFirst)
				{
					if (token is FlowEntry)
					{
						Skip();
						token = GetCurrentToken();
					}
					else if (!(token is YamlDotNet.Core.Tokens.Scalar))
					{
						start = token?.Start ?? Mark.Empty;
						end = token?.End ?? Mark.Empty;
						throw new SemanticErrorException(in start, in end, "While parsing a flow mapping,  did not find expected ',' or '}'.");
					}
				}
				if (token is Key)
				{
					Skip();
					token = GetCurrentToken();
					if (!(token is Value) && !(token is FlowEntry) && !(token is FlowMappingEnd))
					{
						states.Push(ParserState.FlowMappingValue);
						return ParseNode(isBlock: false, isIndentlessSequence: false);
					}
					state = ParserState.FlowMappingValue;
					start = token?.Start ?? Mark.Empty;
					return ProcessEmptyScalar(in start);
				}
				if (token is YamlDotNet.Core.Tokens.Scalar)
				{
					states.Push(ParserState.FlowMappingValue);
					return ParseNode(isBlock: false, isIndentlessSequence: false);
				}
				if (!(token is FlowMappingEnd))
				{
					states.Push(ParserState.FlowMappingEmptyValue);
					return ParseNode(isBlock: false, isIndentlessSequence: false);
				}
			}
			state = states.Pop();
			Skip();
			start = token?.Start ?? Mark.Empty;
			end = token?.End ?? Mark.Empty;
			return new MappingEnd(in start, in end);
		}

		private ParsingEvent ParseFlowMappingValue(bool isEmpty)
		{
			Token token = GetCurrentToken();
			if (!isEmpty && token is Value)
			{
				Skip();
				token = GetCurrentToken();
				if (!(token is FlowEntry) && !(token is FlowMappingEnd))
				{
					states.Push(ParserState.FlowMappingKey);
					return ParseNode(isBlock: false, isIndentlessSequence: false);
				}
			}
			state = ParserState.FlowMappingKey;
			if (!isEmpty && token is YamlDotNet.Core.Tokens.Scalar scalar)
			{
				Skip();
				return new YamlDotNet.Core.Events.Scalar(AnchorName.Empty, TagName.Empty, scalar.Value, scalar.Style, isPlainImplicit: false, isQuotedImplicit: false, token.Start, scalar.End);
			}
			Mark position = token?.Start ?? Mark.Empty;
			return ProcessEmptyScalar(in position);
		}
	}
	internal static class ParserExtensions
	{
		public static T Consume<T>(this IParser parser) where T : ParsingEvent
		{
			T result = parser.Require<T>();
			parser.MoveNext();
			return result;
		}

		public static bool TryConsume<T>(this IParser parser, [MaybeNullWhen(false)] out T @event) where T : ParsingEvent
		{
			if (parser.Accept<T>(out @event))
			{
				parser.MoveNext();
				return true;
			}
			return false;
		}

		public static T Require<T>(this IParser parser) where T : ParsingEvent
		{
			if (!parser.Accept<T>(out var @event))
			{
				ParsingEvent current = parser.Current;
				if (current == null)
				{
					throw new YamlException("Expected '" + typeof(T).Name + "', got nothing.");
				}
				Mark start = current.Start;
				Mark end = current.End;
				throw new YamlException(in start, in end, $"Expected '{typeof(T).Name}', got '{current.GetType().Name}' (at {current.Start}).");
			}
			return @event;
		}

		public static bool Accept<T>(this IParser parser, [MaybeNullWhen(false)] out T @event) where T : ParsingEvent
		{
			if (parser.Current == null && !parser.MoveNext())
			{
				throw new EndOfStreamException();
			}
			if (parser.Current is T val)
			{
				@event = val;
				return true;
			}
			@event = null;
			return false;
		}

		public static void SkipThisAndNestedEvents(this IParser parser)
		{
			int num = 0;
			do
			{
				ParsingEvent parsingEvent = parser.Consume<ParsingEvent>();
				num += parsingEvent.NestingIncrease;
			}
			while (num > 0);
		}

		[Obsolete("Please use Consume<T>() instead")]
		public static T Expect<T>(this IParser parser) where T : ParsingEvent
		{
			return parser.Consume<T>();
		}

		[Obsolete("Please use TryConsume<T>(out var evt) instead")]
		[return: MaybeNull]
		public static T? Allow<T>(this IParser parser) where T : ParsingEvent
		{
			if (!parser.TryConsume<T>(out var @event))
			{
				return null;
			}
			return @event;
		}

		[Obsolete("Please use Accept<T>(out var evt) instead")]
		[return: MaybeNull]
		public static T? Peek<T>(this IParser parser) where T : ParsingEvent
		{
			if (!parser.Accept<T>(out var @event))
			{
				return null;
			}
			return @event;
		}

		[Obsolete("Please use TryConsume<T>(out var evt) or Accept<T>(out var evt) instead")]
		public static bool Accept<T>(this IParser parser) where T : ParsingEvent
		{
			T @event;
			return parser.Accept<T>(out @event);
		}

		public static bool TryFindMappingEntry(this IParser parser, Func<YamlDotNet.Core.Events.Scalar, bool> selector, [MaybeNullWhen(false)] out YamlDotNet.Core.Events.Scalar? key, [MaybeNullWhen(false)] out ParsingEvent? value)
		{
			if (parser.TryConsume<MappingStart>(out var _))
			{
				while (parser.Current != null)
				{
					ParsingEvent current = parser.Current;
					if (!(current is YamlDotNet.Core.Events.Scalar scalar))
					{
						if (current is MappingStart || current is SequenceStart)
						{
							parser.SkipThisAndNestedEvents();
						}
						else
						{
							parser.MoveNext();
						}
						continue;
					}
					bool num = selector(scalar);
					parser.MoveNext();
					if (num)
					{
						value = parser.Current;
						key = scalar;
						return true;
					}
					parser.SkipThisAndNestedEvents();
				}
			}
			key = null;
			value = null;
			return false;
		}
	}
	internal enum ParserState
	{
		StreamStart,
		StreamEnd,
		ImplicitDocumentStart,
		DocumentStart,
		DocumentContent,
		DocumentEnd,
		BlockNode,
		BlockNodeOrIndentlessSequence,
		FlowNode,
		BlockSequenceFirstEntry,
		BlockSequenceEntry,
		IndentlessSequenceEntry,
		BlockMappingFirstKey,
		BlockMappingKey,
		BlockMappingValue,
		FlowSequenceFirstEntry,
		FlowSequenceEntry,
		FlowSequenceEntryMappingKey,
		FlowSequenceEntryMappingValue,
		FlowSequenceEntryMappingEnd,
		FlowMappingFirstKey,
		FlowMappingKey,
		FlowMappingValue,
		FlowMappingEmptyValue
	}
	internal sealed class RecursionLevel
	{
		private int current;

		public int Maximum { get; }

		public RecursionLevel(int maximum)
		{
			Maximum = maximum;
		}

		public void Increment()
		{
			if (!TryIncrement())
			{
				throw new MaximumRecursionLevelReachedException("Maximum level of recursion reached");
			}
		}

		public bool TryIncrement()
		{
			if (current < Maximum)
			{
				current++;
				return true;
			}
			return false;
		}

		public void Decrement()
		{
			if (current == 0)
			{
				throw new InvalidOperationException("Attempted to decrement RecursionLevel to a negative value");
			}
			current--;
		}
	}
	internal enum ScalarStyle
	{
		Any,
		Plain,
		SingleQuoted,
		DoubleQuoted,
		Literal,
		Folded
	}
	internal class Scanner : IScanner
	{
		private const int MaxVersionNumberLength = 9;

		private static readonly SortedDictionary<char, char> SimpleEscapeCodes = new SortedDictionary<char, char>
		{
			{ '0', '\0' },
			{ 'a', '\a' },
			{ 'b', '\b' },
			{ 't', '\t' },
			{ '\t', '\t' },
			{ 'n', '\n' },
			{ 'v', '\v' },
			{ 'f', '\f' },
			{ 'r', '\r' },
			{ 'e', '\u001b' },
			{ ' ', ' ' },
			{ '"', '"' },
			{ '\\', '\\' },
			{ '/', '/' },
			{ 'N', '\u0085' },
			{ '_', '\u00a0' },
			{ 'L', '\u2028' },
			{ 'P', '\u2029' }
		};

		private readonly Stack<int> indents = new Stack<int>();

		private readonly InsertionQueue<Token> tokens = new InsertionQueue<Token>();

		private readonly Stack<SimpleKey> simpleKeys = new Stack<SimpleKey>();

		private readonly CharacterAnalyzer<LookAheadBuffer> analyzer;

		private readonly Cursor cursor;

		private bool streamStartProduced;

		private bool streamEndProduced;

		private bool plainScalarFollowedByComment;

		private int flowSequenceStartLine;

		private bool flowCollectionFetched;

		private bool startFlowCollectionFetched;

		private int indent = -1;

		private bool flowScalarFetched;

		private bool simpleKeyAllowed;

		private int flowLevel;

		private int tokensParsed;

		private bool tokenAvailable;

		private Token? previous;

		private Anchor? previousAnchor;

		private YamlDotNet.Core.Tokens.Scalar? lastScalar;

		private static readonly byte[] EmptyBytes = new byte[0];

		public bool SkipComments { get; private set; }

		public Token? Current { get; private set; }

		public Mark CurrentPosition => cursor.Mark();

		private bool IsDocumentStart()
		{
			if (!analyzer.EndOfInput && cursor.LineOffset == 0 && analyzer.Check('-') && analyzer.Check('-', 1) && analyzer.Check('-', 2))
			{
				return analyzer.IsWhiteBreakOrZero(3);
			}
			return false;
		}

		private bool IsDocumentEnd()
		{
			if (!analyzer.EndOfInput && cursor.LineOffset == 0 && analyzer.Check('.') && analyzer.Check('.', 1) && analyzer.Check('.', 2))
			{
				return analyzer.IsWhiteBreakOrZero(3);
			}
			return false;
		}

		private bool IsDocumentIndicator()
		{
			if (!IsDocumentStart())
			{
				return IsDocumentEnd();
			}
			return true;
		}

		public Scanner(TextReader input, bool skipComments = true)
		{
			analyzer = new CharacterAnalyzer<LookAheadBuffer>(new LookAheadBuffer(input, 1024));
			cursor = new Cursor();
			SkipComments = skipComments;
		}

		public bool MoveNext()
		{
			if (Current != null)
			{
				ConsumeCurrent();
			}
			return MoveNextWithoutConsuming();
		}

		public bool MoveNextWithoutConsuming()
		{
			if (!tokenAvailable && !streamEndProduced)
			{
				FetchMoreTokens();
			}
			if (tokens.Count > 0)
			{
				Current = tokens.Dequeue();
				tokenAvailable = false;
				return true;
			}
			Current = null;
			return false;
		}

		public void ConsumeCurrent()
		{
			tokensParsed++;
			tokenAvailable = false;
			previous = Current;
			Current = null;
		}

		private char ReadCurrentCharacter()
		{
			char result = analyzer.Peek(0);
			Skip();
			return result;
		}

		private char ReadLine()
		{
			if (analyzer.Check("\r\n\u0085"))
			{
				SkipLine();
				return '\n';
			}
			char result = analyzer.Peek(0);
			SkipLine();
			return result;
		}

		private void FetchMoreTokens()
		{
			while (true)
			{
				bool flag = false;
				if (tokens.Count == 0)
				{
					flag = true;
				}
				else
				{
					foreach (SimpleKey simpleKey in simpleKeys)
					{
						if (simpleKey.IsPossible && simpleKey.TokenNumber == tokensParsed)
						{
							flag = true;
							break;
						}
					}
				}
				if (!flag)
				{
					break;
				}
				FetchNextToken();
			}
			tokenAvailable = true;
		}

		private static bool StartsWith(StringBuilder what, char start)
		{
			if (what.Length > 0)
			{
				return what[0] == start;
			}
			return false;
		}

		private void StaleSimpleKeys()
		{
			foreach (SimpleKey simpleKey in simpleKeys)
			{
				if (simpleKey.IsPossible && (simpleKey.Line < cursor.Line || simpleKey.Index + 1024 < cursor.Index))
				{
					if (simpleKey.IsRequired)
					{
						Mark mark = cursor.Mark();
						tokens.Enqueue(new Error("While scanning a simple key, could not find expected ':'.", mark, mark));
					}
					simpleKey.MarkAsImpossible();
				}
			}
		}

		private void FetchNextToken()
		{
			if (!streamStartProduced)
			{
				FetchStreamStart();
				return;
			}
			ScanToNextToken();
			StaleSimpleKeys();
			UnrollIndent(cursor.LineOffset);
			analyzer.Buffer.Cache(4);
			if (analyzer.Buffer.EndOfInput)
			{
				lastScalar = null;
				FetchStreamEnd();
			}
			if (cursor.LineOffset == 0 && analyzer.Check('%'))
			{
				lastScalar = null;
				FetchDirective();
				return;
			}
			if (IsDocumentStart())
			{
				lastScalar = null;
				FetchDocumentIndicator(isStartToken: true);
				return;
			}
			if (IsDocumentEnd())
			{
				lastScalar = null;
				FetchDocumentIndicator(isStartToken: false);
				return;
			}
			if (analyzer.Check('['))
			{
				lastScalar = null;
				FetchFlowCollectionStart(isSequenceToken: true);
				return;
			}
			if (analyzer.Check('{'))
			{
				lastScalar = null;
				FetchFlowCollectionStart(isSequenceToken: false);
				return;
			}
			if (analyzer.Check(']'))
			{
				lastScalar = null;
				FetchFlowCollectionEnd(isSequenceToken: true);
				return;
			}
			if (analyzer.Check('}'))
			{
				lastScalar = null;
				FetchFlowCollectionEnd(isSequenceToken: false);
				return;
			}
			if (analyzer.Check(','))
			{
				lastScalar = null;
				FetchFlowEntry();
				return;
			}
			if (analyzer.Check('-'))
			{
				if (analyzer.IsWhiteBreakOrZero(1))
				{
					FetchBlockEntry();
					return;
				}
				if (flowLevel > 0 && analyzer.Check(",[]{}", 1))
				{
					tokens.Enqueue(new Error("Invalid key indicator format.", cursor.Mark(), cursor.Mark()));
				}
			}
			if (analyzer.Check('?') && (flowLevel > 0 || analyzer.IsWhiteBreakOrZero(1)) && analyzer.IsWhiteBreakOrZero(1))
			{
				FetchKey();
			}
			else if (analyzer.Check(':') && (flowLevel > 0 || analyzer.IsWhiteBreakOrZero(1)) && (!simpleKeyAllowed || flowLevel <= 0) && (!flowScalarFetched || !analyzer.Check(':', 1)) && (analyzer.IsWhiteBreakOrZero(1) || analyzer.Check(',', 1) || flowScalarFetched || flowCollectionFetched || startFlowCollectionFetched))
			{
				if (lastScalar != null)
				{
					lastScalar.IsKey = true;
					lastScalar = null;
				}
				FetchValue();
			}
			else if (analyzer.Check('*'))
			{
				FetchAnchor(isAlias: true);
			}
			else if (analyzer.Check('&'))
			{
				FetchAnchor(isAlias: false);
			}
			else if (analyzer.Check('!'))
			{
				FetchTag();
			}
			else if (analyzer.Check('|') && flowLevel == 0)
			{
				FetchBlockScalar(isLiteral: true);
			}
			else if (analyzer.Check('>') && flowLevel == 0)
			{
				FetchBlockScalar(isLiteral: false);
			}
			else if (analyzer.Check('\''))
			{
				FetchQuotedScalar(isSingleQuoted: true);
			}
			else if (analyzer.Check('"'))
			{
				FetchQuotedScalar(isSingleQuoted: false);
			}
			else if ((!analyzer.IsWhiteBreakOrZero() && !analyzer.Check("-?:,[]{}#&*!|>'\"%@`")) || (analyzer.Check('-') && !analyzer.IsWhite(1)) || (analyzer.Check("?:") && !analyzer.IsWhiteBreakOrZero(1)) || (simpleKeyAllowed && flowLevel > 0))
			{
				if (plainScalarFollowedByComment)
				{
					Mark mark = cursor.Mark();
					tokens.Enqueue(new Error("While scanning plain scalar, found a comment between adjacent scalars.", mark, mark));
				}
				if ((flowScalarFetched || (flowCollectionFetched && !startFlowCollectionFetched)) && analyzer.Check(':'))
				{
					Skip();
				}
				flowScalarFetched = false;
				flowCollectionFetched = false;
				startFlowCollectionFetched = false;
				plainScalarFollowedByComment = false;
				FetchPlainScalar();
			}
			else
			{
				if (simpleKeyAllowed && indent >= cursor.LineOffset && analyzer.IsTab())
				{
					throw new SyntaxErrorException("While scanning a mapping, found invalid tab as indentation.");
				}
				if (!analyzer.IsWhiteBreakOrZero())
				{
					Mark start = cursor.Mark();
					Skip();
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning for the next token, found character that cannot start any token.");
				}
				Skip();
			}
		}

		private bool CheckWhiteSpace()
		{
			if (!analyzer.Check(' '))
			{
				if (flowLevel > 0 || !simpleKeyAllowed)
				{
					return analyzer.Check('\t');
				}
				return false;
			}
			return true;
		}

		private void Skip()
		{
			cursor.Skip();
			analyzer.Buffer.Skip(1);
		}

		private void SkipLine()
		{
			if (analyzer.IsCrLf())
			{
				cursor.SkipLineByOffset(2);
				analyzer.Buffer.Skip(2);
			}
			else if (analyzer.IsBreak())
			{
				cursor.SkipLineByOffset(1);
				analyzer.Buffer.Skip(1);
			}
			else if (!analyzer.IsZero())
			{
				throw new InvalidOperationException("Not at a break.");
			}
		}

		private void ScanToNextToken()
		{
			while (true)
			{
				if (CheckWhiteSpace())
				{
					Skip();
					continue;
				}
				ProcessComment();
				if (analyzer.IsBreak())
				{
					SkipLine();
					if (flowLevel == 0)
					{
						simpleKeyAllowed = true;
					}
					continue;
				}
				break;
			}
		}

		private void ProcessComment()
		{
			if (!analyzer.Check('#'))
			{
				return;
			}
			Mark start = cursor.Mark();
			Skip();
			while (analyzer.IsSpace())
			{
				Skip();
			}
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				while (!analyzer.IsBreakOrZero())
				{
					builder.Append(ReadCurrentCharacter());
				}
				if (!SkipComments)
				{
					bool isInline = previous != null && previous.End.Line == start.Line && previous.End.Column != 1 && !(previous is YamlDotNet.Core.Tokens.StreamStart);
					tokens.Enqueue(new YamlDotNet.Core.Tokens.Comment(builder.ToString(), isInline, start, cursor.Mark()));
				}
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private void FetchStreamStart()
		{
			simpleKeys.Push(new SimpleKey());
			simpleKeyAllowed = true;
			streamStartProduced = true;
			Mark start = cursor.Mark();
			tokens.Enqueue(new YamlDotNet.Core.Tokens.StreamStart(in start, in start));
		}

		private void UnrollIndent(int column)
		{
			if (flowLevel == 0)
			{
				while (indent > column)
				{
					Mark start = cursor.Mark();
					tokens.Enqueue(new BlockEnd(in start, in start));
					indent = indents.Pop();
				}
			}
		}

		private void FetchStreamEnd()
		{
			cursor.ForceSkipLineAfterNonBreak();
			UnrollIndent(-1);
			RemoveSimpleKey();
			simpleKeyAllowed = false;
			streamEndProduced = true;
			Mark start = cursor.Mark();
			tokens.Enqueue(new YamlDotNet.Core.Tokens.StreamEnd(in start, in start));
		}

		private void FetchDirective()
		{
			UnrollIndent(-1);
			RemoveSimpleKey();
			simpleKeyAllowed = false;
			Token token = ScanDirective();
			if (token != null)
			{
				tokens.Enqueue(token);
			}
		}

		private Token? ScanDirective()
		{
			Mark start = cursor.Mark();
			Skip();
			string text = ScanDirectiveName(in start);
			Token result;
			if (!(text == "YAML"))
			{
				if (!(text == "TAG"))
				{
					while (!analyzer.EndOfInput && !analyzer.Check('#') && !analyzer.IsBreak())
					{
						Skip();
					}
					return null;
				}
				result = ScanTagDirectiveValue(in start);
			}
			else
			{
				if (!(previous is YamlDotNet.Core.Tokens.DocumentStart) && !(previous is YamlDotNet.Core.Tokens.StreamStart) && !(previous is YamlDotNet.Core.Tokens.DocumentEnd))
				{
					Mark end = cursor.Mark();
					throw new SemanticErrorException(in start, in end, "While scanning a version directive, did not find preceding <document end>.");
				}
				result = ScanVersionDirectiveValue(in start);
			}
			while (analyzer.IsWhite())
			{
				Skip();
			}
			ProcessComment();
			if (!analyzer.IsBreakOrZero())
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a directive, did not find expected comment or line break.");
			}
			if (analyzer.IsBreak())
			{
				SkipLine();
			}
			return result;
		}

		private void FetchDocumentIndicator(bool isStartToken)
		{
			UnrollIndent(-1);
			RemoveSimpleKey();
			simpleKeyAllowed = false;
			Mark end = cursor.Mark();
			Skip();
			Skip();
			Skip();
			if (isStartToken)
			{
				InsertionQueue<Token> insertionQueue = tokens;
				Mark end2 = cursor.Mark();
				insertionQueue.Enqueue(new YamlDotNet.Core.Tokens.DocumentStart(in end, in end2));
				return;
			}
			Token token = null;
			while (!analyzer.EndOfInput && !analyzer.IsBreak() && !analyzer.Check('#'))
			{
				if (!analyzer.IsWhite())
				{
					token = new Error("While scanning a document end, found invalid content after '...' marker.", end, cursor.Mark());
					break;
				}
				Skip();
			}
			tokens.Enqueue(new YamlDotNet.Core.Tokens.DocumentEnd(in end, in end));
			if (token != null)
			{
				tokens.Enqueue(token);
			}
		}

		private void FetchFlowCollectionStart(bool isSequenceToken)
		{
			SaveSimpleKey();
			IncreaseFlowLevel();
			simpleKeyAllowed = true;
			Mark start = cursor.Mark();
			Skip();
			Token token;
			if (isSequenceToken)
			{
				token = new FlowSequenceStart(in start, in start);
				flowSequenceStartLine = token.Start.Line;
			}
			else
			{
				token = new FlowMappingStart(in start, in start);
			}
			tokens.Enqueue(token);
			startFlowCollectionFetched = true;
		}

		private void IncreaseFlowLevel()
		{
			simpleKeys.Push(new SimpleKey());
			flowLevel++;
		}

		private void FetchFlowCollectionEnd(bool isSequenceToken)
		{
			RemoveSimpleKey();
			DecreaseFlowLevel();
			simpleKeyAllowed = false;
			Mark start = cursor.Mark();
			Skip();
			Token token = null;
			Token item;
			if (isSequenceToken)
			{
				if (analyzer.Check('#'))
				{
					token = new Error("While scanning a flow sequence end, found invalid comment after ']'.", start, start);
				}
				item = new FlowSequenceEnd(in start, in start);
			}
			else
			{
				item = new FlowMappingEnd(in start, in start);
			}
			tokens.Enqueue(item);
			if (token != null)
			{
				tokens.Enqueue(token);
			}
			flowCollectionFetched = true;
		}

		private void DecreaseFlowLevel()
		{
			if (flowLevel > 0)
			{
				flowLevel--;
				simpleKeys.Pop();
			}
		}

		private void FetchFlowEntry()
		{
			RemoveSimpleKey();
			simpleKeyAllowed = true;
			Mark start = cursor.Mark();
			Skip();
			Mark end = cursor.Mark();
			if (analyzer.Check('#'))
			{
				tokens.Enqueue(new Error("While scanning a flow entry, found invalid comment after comma.", start, end));
			}
			else
			{
				tokens.Enqueue(new FlowEntry(in start, in end));
			}
		}

		private void FetchBlockEntry()
		{
			Mark start;
			if (flowLevel == 0)
			{
				if (!simpleKeyAllowed)
				{
					if (previousAnchor != null && previousAnchor.End.Line == cursor.Line)
					{
						start = previousAnchor.Start;
						Mark end = previousAnchor.End;
						throw new SemanticErrorException(in start, in end, "Anchor before sequence entry on same line is not allowed.");
					}
					Mark mark = cursor.Mark();
					tokens.Enqueue(new Error("Block sequence entries are not allowed in this context.", mark, mark));
				}
				RollIndent(cursor.LineOffset, -1, isSequence: true, cursor.Mark());
			}
			RemoveSimpleKey();
			simpleKeyAllowed = true;
			Mark start2 = cursor.Mark();
			Skip();
			InsertionQueue<Token> insertionQueue = tokens;
			start = cursor.Mark();
			insertionQueue.Enqueue(new BlockEntry(in start2, in start));
		}

		private void FetchKey()
		{
			if (flowLevel == 0)
			{
				if (!simpleKeyAllowed)
				{
					Mark start = cursor.Mark();
					throw new SyntaxErrorException(in start, in start, "Mapping keys are not allowed in this context.");
				}
				RollIndent(cursor.LineOffset, -1, isSequence: false, cursor.Mark());
			}
			RemoveSimpleKey();
			simpleKeyAllowed = flowLevel == 0;
			Mark start2 = cursor.Mark();
			Skip();
			InsertionQueue<Token> insertionQueue = tokens;
			Mark end = cursor.Mark();
			insertionQueue.Enqueue(new Key(in start2, in end));
		}

		private void FetchValue()
		{
			SimpleKey simpleKey = simpleKeys.Peek();
			Mark start;
			if (simpleKey.IsPossible)
			{
				InsertionQueue<Token> insertionQueue = tokens;
				int index = simpleKey.TokenNumber - tokensParsed;
				start = simpleKey.Mark;
				Mark end = simpleKey.Mark;
				insertionQueue.Insert(index, new Key(in start, in end));
				RollIndent(simpleKey.LineOffset, simpleKey.TokenNumber, isSequence: false, simpleKey.Mark);
				simpleKey.MarkAsImpossible();
				simpleKeyAllowed = false;
			}
			else
			{
				bool flag = flowLevel == 0;
				if (flag)
				{
					if (!simpleKeyAllowed)
					{
						Mark mark = cursor.Mark();
						tokens.Enqueue(new Error("Mapping values are not allowed in this context.", mark, mark));
						return;
					}
					RollIndent(cursor.LineOffset, -1, isSequence: false, cursor.Mark());
					if (cursor.LineOffset == 0 && simpleKey.LineOffset == 0)
					{
						InsertionQueue<Token> insertionQueue2 = tokens;
						int count = tokens.Count;
						start = simpleKey.Mark;
						Mark end = simpleKey.Mark;
						insertionQueue2.Insert(count, new Key(in start, in end));
						flag = false;
					}
				}
				simpleKeyAllowed = flag;
			}
			Mark start2 = cursor.Mark();
			Skip();
			InsertionQueue<Token> insertionQueue3 = tokens;
			start = cursor.Mark();
			insertionQueue3.Enqueue(new Value(in start2, in start));
		}

		private void RollIndent(int column, int number, bool isSequence, Mark position)
		{
			if (flowLevel <= 0 && indent < column)
			{
				indents.Push(indent);
				indent = column;
				Token item = ((!isSequence) ? ((Token)new BlockMappingStart(in position, in position)) : ((Token)new BlockSequenceStart(in position, in position)));
				if (number == -1)
				{
					tokens.Enqueue(item);
				}
				else
				{
					tokens.Insert(number - tokensParsed, item);
				}
			}
		}

		private void FetchAnchor(bool isAlias)
		{
			SaveSimpleKey();
			simpleKeyAllowed = false;
			tokens.Enqueue(ScanAnchor(isAlias));
		}

		private Token ScanAnchor(bool isAlias)
		{
			Mark start = cursor.Mark();
			Skip();
			bool flag = false;
			if (isAlias)
			{
				SimpleKey simpleKey = simpleKeys.Peek();
				flag = simpleKey.IsRequired && simpleKey.IsPossible;
			}
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				while (!analyzer.IsWhiteBreakOrZero() && !analyzer.Check("[]{},") && (!flag || !analyzer.Check(':') || !analyzer.IsWhiteBreakOrZero(1)))
				{
					builder.Append(ReadCurrentCharacter());
				}
				if (builder.Length == 0 || (!analyzer.IsWhiteBreakOrZero() && !analyzer.Check("?:,]}%@`")))
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning an anchor or alias, found value containing disallowed: []{},");
				}
				AnchorName value = new AnchorName(builder.ToString());
				if (isAlias)
				{
					return new YamlDotNet.Core.Tokens.AnchorAlias(value, start, cursor.Mark());
				}
				return previousAnchor = new Anchor(value, start, cursor.Mark());
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private void FetchTag()
		{
			SaveSimpleKey();
			simpleKeyAllowed = false;
			tokens.Enqueue(ScanTag());
		}

		private Token ScanTag()
		{
			Mark start = cursor.Mark();
			string text;
			string text2;
			if (analyzer.Check('<', 1))
			{
				text = string.Empty;
				Skip();
				Skip();
				text2 = ScanTagUri(null, start);
				if (!analyzer.Check('>'))
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a tag, did not find the expected '>'.");
				}
				Skip();
			}
			else
			{
				string text3 = ScanTagHandle(isDirective: false, start);
				if (text3.Length > 1 && text3[0] == '!' && text3[text3.Length - 1] == '!')
				{
					text = text3;
					text2 = ScanTagUri(null, start);
				}
				else
				{
					text2 = ScanTagUri(text3, start);
					text = "!";
					if (text2.Length == 0)
					{
						text2 = text;
						text = string.Empty;
					}
				}
			}
			if (!analyzer.IsWhiteBreakOrZero() && !analyzer.Check(','))
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a tag, did not find expected whitespace, comma or line break.");
			}
			return new Tag(text, text2, start, cursor.Mark());
		}

		private void FetchBlockScalar(bool isLiteral)
		{
			SaveSimpleKey();
			simpleKeyAllowed = true;
			tokens.Enqueue(ScanBlockScalar(isLiteral));
		}

		private Token ScanBlockScalar(bool isLiteral)
		{
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				StringBuilderPool.BuilderWrapper builderWrapper2 = StringBuilderPool.Rent();
				try
				{
					StringBuilder builder2 = builderWrapper2.Builder;
					StringBuilderPool.BuilderWrapper builderWrapper3 = StringBuilderPool.Rent();
					try
					{
						StringBuilder builder3 = builderWrapper3.Builder;
						int num = 0;
						int num2 = 0;
						int currentIndent = 0;
						bool flag = false;
						bool? isFirstLine = null;
						Mark start = cursor.Mark();
						Skip();
						if (analyzer.Check("+-"))
						{
							num = (analyzer.Check('+') ? 1 : (-1));
							Skip();
							if (analyzer.IsDigit())
							{
								if (analyzer.Check('0'))
								{
									Mark end = cursor.Mark();
									throw new SyntaxErrorException(in start, in end, "While scanning a block scalar, found an indentation indicator equal to 0.");
								}
								num2 = analyzer.AsDigit();
								Skip();
							}
						}
						else if (analyzer.IsDigit())
						{
							if (analyzer.Check('0'))
							{
								Mark end = cursor.Mark();
								throw new SyntaxErrorException(in start, in end, "While scanning a block scalar, found an indentation indicator equal to 0.");
							}
							num2 = analyzer.AsDigit();
							Skip();
							if (analyzer.Check("+-"))
							{
								num = (analyzer.Check('+') ? 1 : (-1));
								Skip();
							}
						}
						if (analyzer.Check('#'))
						{
							Mark end = cursor.Mark();
							throw new SyntaxErrorException(in start, in end, "While scanning a block scalar, found a comment without whtespace after '>' indicator.");
						}
						while (analyzer.IsWhite())
						{
							Skip();
						}
						ProcessComment();
						if (!analyzer.IsBreakOrZero())
						{
							Mark end = cursor.Mark();
							throw new SyntaxErrorException(in start, in end, "While scanning a block scalar, did not find expected comment or line break.");
						}
						if (analyzer.IsBreak())
						{
							SkipLine();
							if (!isFirstLine.HasValue)
							{
								isFirstLine = true;
							}
							else if (isFirstLine == true)
							{
								isFirstLine = false;
							}
						}
						Mark end2 = cursor.Mark();
						if (num2 != 0)
						{
							currentIndent = ((indent >= 0) ? (indent + num2) : num2);
						}
						currentIndent = ScanBlockScalarBreaks(currentIndent, builder3, isLiteral, ref end2, ref isFirstLine);
						isFirstLine = false;
						while (cursor.LineOffset == currentIndent && !analyzer.IsZero() && !IsDocumentEnd())
						{
							bool flag2 = analyzer.IsWhite();
							if (!isLiteral && StartsWith(builder2, '\n') && !flag && !flag2)
							{
								if (builder3.Length == 0)
								{
									builder.Append(' ');
								}
								builder2.Length = 0;
							}
							else
							{
								builder.Append(builder2.ToString());
								builder2.Length = 0;
							}
							builder.Append(builder3.ToString());
							builder3.Length = 0;
							flag = analyzer.IsWhite();
							while (!analyzer.IsBreakOrZero())
							{
								builder.Append(ReadCurrentCharacter());
							}
							char c = ReadLine();
							if (c != 0)
							{
								builder2.Append(c);
							}
							currentIndent = ScanBlockScalarBreaks(currentIndent, builder3, isLiteral, ref end2, ref isFirstLine);
						}
						if (num != -1)
						{
							builder.Append((object?)builder2);
						}
						if (num == 1)
						{
							builder.Append((object?)builder3);
						}
						ScalarStyle style = (isLiteral ? ScalarStyle.Literal : ScalarStyle.Folded);
						return new YamlDotNet.Core.Tokens.Scalar(builder.ToString(), style, start, end2);
					}
					finally
					{
						((IDisposable)builderWrapper3).Dispose();
					}
				}
				finally
				{
					((IDisposable)builderWrapper2).Dispose();
				}
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private int ScanBlockScalarBreaks(int currentIndent, StringBuilder breaks, bool isLiteral, ref Mark end, ref bool? isFirstLine)
		{
			int num = 0;
			int num2 = -1;
			end = cursor.Mark();
			while (true)
			{
				if ((currentIndent == 0 || cursor.LineOffset < currentIndent) && analyzer.IsSpace())
				{
					Skip();
					continue;
				}
				if (cursor.LineOffset > num)
				{
					num = cursor.LineOffset;
				}
				if (!analyzer.IsBreak())
				{
					break;
				}
				if (isFirstLine == true)
				{
					isFirstLine = false;
					num2 = cursor.LineOffset;
				}
				breaks.Append(ReadLine());
				end = cursor.Mark();
			}
			if (isLiteral && isFirstLine == true)
			{
				int num3 = cursor.LineOffset;
				int num4 = 0;
				while (!analyzer.IsBreak(num4) && analyzer.IsSpace(num4))
				{
					num4++;
					num3++;
				}
				if (analyzer.IsBreak(num4) && num3 > cursor.LineOffset)
				{
					isFirstLine = false;
					num2 = num3;
				}
			}
			if (isLiteral && num2 > 1 && currentIndent < num2 - 1)
			{
				Mark end2 = cursor.Mark();
				throw new SemanticErrorException(in end, in end2, "While scanning a literal block scalar, found extra spaces in first line.");
			}
			if (!isLiteral && num > cursor.LineOffset && num2 > -1)
			{
				Mark end2 = cursor.Mark();
				throw new SemanticErrorException(in end, in end2, "While scanning a literal block scalar, found more spaces in lines above first content line.");
			}
			if (currentIndent == 0 && (cursor.LineOffset > 0 || indent > -1))
			{
				currentIndent = Math.Max(num, Math.Max(indent + 1, 1));
			}
			return currentIndent;
		}

		private void FetchQuotedScalar(bool isSingleQuoted)
		{
			SaveSimpleKey();
			simpleKeyAllowed = false;
			flowScalarFetched = flowLevel > 0;
			YamlDotNet.Core.Tokens.Scalar item = ScanFlowScalar(isSingleQuoted);
			tokens.Enqueue(item);
			lastScalar = item;
			if (!isSingleQuoted && analyzer.Check('#'))
			{
				Mark mark = cursor.Mark();
				tokens.Enqueue(new Error("While scanning a flow sequence end, found invalid comment after double-quoted scalar.", mark, mark));
			}
		}

		private YamlDotNet.Core.Tokens.Scalar ScanFlowScalar(bool isSingleQuoted)
		{
			Mark start = cursor.Mark();
			Skip();
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				StringBuilderPool.BuilderWrapper builderWrapper2 = StringBuilderPool.Rent();
				try
				{
					StringBuilder builder2 = builderWrapper2.Builder;
					StringBuilderPool.BuilderWrapper builderWrapper3 = StringBuilderPool.Rent();
					try
					{
						StringBuilder builder3 = builderWrapper3.Builder;
						StringBuilderPool.BuilderWrapper builderWrapper4 = StringBuilderPool.Rent();
						try
						{
							StringBuilder builder4 = builderWrapper4.Builder;
							bool flag = false;
							while (true)
							{
								if (IsDocumentIndicator())
								{
									Mark end = cursor.Mark();
									throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, found unexpected document indicator.");
								}
								if (analyzer.IsZero())
								{
									Mark end = cursor.Mark();
									throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, found unexpected end of stream.");
								}
								if (flag && !isSingleQuoted && indent >= cursor.LineOffset)
								{
									Mark end = cursor.Mark();
									throw new SyntaxErrorException(in start, in end, "While scanning a multi-line double-quoted scalar, found wrong indentation.");
								}
								flag = false;
								while (!analyzer.IsWhiteBreakOrZero())
								{
									if (isSingleQuoted && analyzer.Check('\'') && analyzer.Check('\'', 1))
									{
										builder.Append('\'');
										Skip();
										Skip();
										continue;
									}
									if (analyzer.Check(isSingleQuoted ? '\'' : '"'))
									{
										break;
									}
									if (!isSingleQuoted && analyzer.Check('\\') && analyzer.IsBreak(1))
									{
										Skip();
										SkipLine();
										flag = true;
										break;
									}
									if (!isSingleQuoted && analyzer.Check('\\'))
									{
										int num = 0;
										char c = analyzer.Peek(1);
										switch (c)
										{
										case 'x':
											num = 2;
											break;
										case 'u':
											num = 4;
											break;
										case 'U':
											num = 8;
											break;
										default:
										{
											if (SimpleEscapeCodes.TryGetValue(c, out var value))
											{
												builder.Append(value);
												break;
											}
											Mark end = cursor.Mark();
											throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, found unknown escape character.");
										}
										}
										Skip();
										Skip();
										if (num <= 0)
										{
											continue;
										}
										int num2 = 0;
										for (int i = 0; i < num; i++)
										{
											if (!analyzer.IsHex(i))
											{
												Mark end = cursor.Mark();
												throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, did not find expected hexadecimal number.");
											}
											num2 = (num2 << 4) + analyzer.AsHex(i);
										}
										if (num2 >= 55296 && num2 <= 57343)
										{
											for (int j = 0; j < num; j++)
											{
												Skip();
											}
											if (analyzer.Peek(0) != '\\' || (analyzer.Peek(1) != 'u' && analyzer.Peek(1) != 'U'))
											{
												Mark end = cursor.Mark();
												throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, found invalid Unicode surrogates.");
											}
											Skip();
											num = ((analyzer.Peek(0) != 'u') ? 8 : 4);
											Skip();
											int num3 = 0;
											for (int k = 0; k < num; k++)
											{
												if (!analyzer.IsHex(0))
												{
													Mark end = cursor.Mark();
													throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, did not find expected hexadecimal number.");
												}
												num3 = (num3 << 4) + analyzer.AsHex(k);
											}
											for (int l = 0; l < num; l++)
											{
												Skip();
											}
											num2 = char.ConvertToUtf32((char)num2, (char)num3);
										}
										else
										{
											if (num2 > 1114111)
											{
												Mark end = cursor.Mark();
												throw new SyntaxErrorException(in start, in end, "While scanning a quoted scalar, found invalid Unicode character escape code.");
											}
											for (int m = 0; m < num; m++)
											{
												Skip();
											}
										}
										builder.Append(char.ConvertFromUtf32(num2));
									}
									else
									{
										builder.Append(ReadCurrentCharacter());
									}
								}
								if (analyzer.Check(isSingleQuoted ? '\'' : '"'))
								{
									break;
								}
								while (analyzer.IsWhite() || analyzer.IsBreak())
								{
									if (analyzer.IsWhite())
									{
										if (!flag)
										{
											builder2.Append(ReadCurrentCharacter());
										}
										else
										{
											Skip();
										}
									}
									else if (!flag)
									{
										builder2.Length = 0;
										builder3.Append(ReadLine());
										flag = true;
									}
									else
									{
										builder4.Append(ReadLine());
									}
								}
								if (flag)
								{
									if (StartsWith(builder3, '\n'))
									{
										if (builder4.Length == 0)
										{
											builder.Append(' ');
										}
										else
										{
											builder.Append(builder4.ToString());
										}
									}
									else
									{
										builder.Append(builder3.ToString());
										builder.Append(builder4.ToString());
									}
									builder3.Length = 0;
									builder4.Length = 0;
								}
								else
								{
									builder.Append(builder2.ToString());
									builder2.Length = 0;
								}
							}
							Skip();
							return new YamlDotNet.Core.Tokens.Scalar(builder.ToString(), isSingleQuoted ? ScalarStyle.SingleQuoted : ScalarStyle.DoubleQuoted, start, cursor.Mark());
						}
						finally
						{
							((IDisposable)builderWrapper4).Dispose();
						}
					}
					finally
					{
						((IDisposable)builderWrapper3).Dispose();
					}
				}
				finally
				{
					((IDisposable)builderWrapper2).Dispose();
				}
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private void FetchPlainScalar()
		{
			SaveSimpleKey();
			simpleKeyAllowed = false;
			bool isMultiline = false;
			YamlDotNet.Core.Tokens.Scalar item = (lastScalar = ScanPlainScalar(ref isMultiline));
			if (isMultiline && analyzer.Check(':') && flowLevel == 0 && indent < cursor.LineOffset)
			{
				tokens.Enqueue(new Error("While scanning a multiline plain scalar, found invalid mapping.", cursor.Mark(), cursor.Mark()));
			}
			tokens.Enqueue(item);
		}

		private YamlDotNet.Core.Tokens.Scalar ScanPlainScalar(ref bool isMultiline)
		{
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				StringBuilderPool.BuilderWrapper builderWrapper2 = StringBuilderPool.Rent();
				try
				{
					StringBuilder builder2 = builderWrapper2.Builder;
					StringBuilderPool.BuilderWrapper builderWrapper3 = StringBuilderPool.Rent();
					try
					{
						StringBuilder builder3 = builderWrapper3.Builder;
						StringBuilderPool.BuilderWrapper builderWrapper4 = StringBuilderPool.Rent();
						try
						{
							StringBuilder builder4 = builderWrapper4.Builder;
							bool flag = false;
							int num = indent + 1;
							Mark start = cursor.Mark();
							Mark end = start;
							SimpleKey simpleKey = simpleKeys.Peek();
							while (!IsDocumentIndicator())
							{
								if (analyzer.Check('#'))
								{
									if (indent < 0 && flowLevel == 0)
									{
										plainScalarFollowedByComment = true;
									}
									break;
								}
								bool flag2 = analyzer.Check('*') && (!simpleKey.IsPossible || !simpleKey.IsRequired);
								while (!analyzer.IsWhiteBreakOrZero())
								{
									if ((analyzer.Check(':') && !flag2 && (analyzer.IsWhiteBreakOrZero(1) || (flowLevel > 0 && analyzer.Check(',', 1)))) || (flowLevel > 0 && analyzer.Check(",[]{}")))
									{
										if (flowLevel == 0 && !simpleKey.IsPossible)
										{
											tokens.Enqueue(new Error("While scanning a plain scalar value, found invalid mapping.", cursor.Mark(), cursor.Mark()));
										}
										break;
									}
									if (flag || builder2.Length > 0)
									{
										if (flag)
										{
											if (StartsWith(builder3, '\n'))
											{
												if (builder4.Length == 0)
												{
													builder.Append(' ');
												}
												else
												{
													builder.Append((object?)builder4);
												}
											}
											else
											{
												builder.Append((object?)builder3);
												builder.Append((object?)builder4);
											}
											builder3.Length = 0;
											builder4.Length = 0;
											flag = false;
										}
										else
										{
											builder.Append((object?)builder2);
											builder2.Length = 0;
										}
									}
									if (flowLevel > 0 && cursor.LineOffset < num)
									{
										throw new Exception();
									}
									builder.Append(ReadCurrentCharacter());
									end = cursor.Mark();
								}
								if (!analyzer.IsWhite() && !analyzer.IsBreak())
								{
									break;
								}
								while (analyzer.IsWhite() || analyzer.IsBreak())
								{
									if (analyzer.IsWhite())
									{
										if (flag && cursor.LineOffset < num && analyzer.IsTab())
										{
											Mark end2 = cursor.Mark();
											throw new SyntaxErrorException(in start, in end2, "While scanning a plain scalar, found a tab character that violate indentation.");
										}
										if (!flag)
										{
											builder2.Append(ReadCurrentCharacter());
										}
										else
										{
											Skip();
										}
									}
									else
									{
										isMultiline = true;
										if (!flag)
										{
											builder2.Length = 0;
											builder3.Append(ReadLine());
											flag = true;
										}
										else
										{
											builder4.Append(ReadLine());
										}
									}
								}
								if (flowLevel == 0 && cursor.LineOffset < num)
								{
									break;
								}
							}
							if (flag)
							{
								simpleKeyAllowed = true;
							}
							return new YamlDotNet.Core.Tokens.Scalar(builder.ToString(), ScalarStyle.Plain, start, end);
						}
						finally
						{
							((IDisposable)builderWrapper4).Dispose();
						}
					}
					finally
					{
						((IDisposable)builderWrapper3).Dispose();
					}
				}
				finally
				{
					((IDisposable)builderWrapper2).Dispose();
				}
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private void RemoveSimpleKey()
		{
			SimpleKey simpleKey = simpleKeys.Peek();
			if (simpleKey.IsPossible && simpleKey.IsRequired)
			{
				Mark start = simpleKey.Mark;
				Mark end = simpleKey.Mark;
				throw new SyntaxErrorException(in start, in end, "While scanning a simple key, could not find expected ':'.");
			}
			simpleKey.MarkAsImpossible();
		}

		private string ScanDirectiveName(in Mark start)
		{
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				while (analyzer.IsAlphaNumericDashOrUnderscore())
				{
					builder.Append(ReadCurrentCharacter());
				}
				if (builder.Length == 0)
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a directive, could not find expected directive name.");
				}
				if (analyzer.EndOfInput)
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a directive, found unexpected end of stream.");
				}
				if (!analyzer.IsWhiteBreakOrZero())
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a directive, found unexpected non-alphabetical character.");
				}
				return builder.ToString();
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private void SkipWhitespaces()
		{
			while (analyzer.IsWhite())
			{
				Skip();
			}
		}

		private Token ScanVersionDirectiveValue(in Mark start)
		{
			SkipWhitespaces();
			int major = ScanVersionDirectiveNumber(in start);
			if (!analyzer.Check('.'))
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a %YAML directive, did not find expected digit or '.' character.");
			}
			Skip();
			int minor = ScanVersionDirectiveNumber(in start);
			return new VersionDirective(new Version(major, minor), start, start);
		}

		private Token ScanTagDirectiveValue(in Mark start)
		{
			SkipWhitespaces();
			string handle = ScanTagHandle(isDirective: true, start);
			if (!analyzer.IsWhite())
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a %TAG directive, did not find expected whitespace.");
			}
			SkipWhitespaces();
			string prefix = ScanTagUri(null, start);
			if (!analyzer.IsWhiteBreakOrZero())
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a %TAG directive, did not find expected whitespace or line break.");
			}
			return new TagDirective(handle, prefix, start, start);
		}

		private string ScanTagUri(string? head, Mark start)
		{
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				if (head != null && head.Length > 1)
				{
					builder.Append(head.Substring(1));
				}
				while (analyzer.IsAlphaNumericDashOrUnderscore() || analyzer.Check(";/?:@&=+$.!~*'()[]%") || (analyzer.Check(',') && !analyzer.IsBreak(1)))
				{
					if (analyzer.Check('%'))
					{
						builder.Append(ScanUriEscapes(in start));
					}
					else if (analyzer.Check('+'))
					{
						builder.Append(' ');
						Skip();
					}
					else
					{
						builder.Append(ReadCurrentCharacter());
					}
				}
				if (builder.Length == 0)
				{
					return string.Empty;
				}
				string text = builder.ToString();
				if (text.EndsWith(","))
				{
					Mark start2 = cursor.Mark();
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start2, in end, "Unexpected comma at end of tag");
				}
				return text;
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private string ScanUriEscapes(in Mark start)
		{
			byte[] array = EmptyBytes;
			int count = 0;
			int num = 0;
			do
			{
				if (!analyzer.Check('%') || !analyzer.IsHex(1) || !analyzer.IsHex(2))
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a tag, did not find URI escaped octet.");
				}
				int num2 = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);
				if (num == 0)
				{
					num = (((num2 & 0x80) == 0) ? 1 : (((num2 & 0xE0) == 192) ? 2 : (((num2 & 0xF0) == 224) ? 3 : (((num2 & 0xF8) == 240) ? 4 : 0))));
					if (num == 0)
					{
						Mark end = cursor.Mark();
						throw new SyntaxErrorException(in start, in end, "While scanning a tag, found an incorrect leading UTF-8 octet.");
					}
					array = new byte[num];
				}
				else if ((num2 & 0xC0) != 128)
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a tag, found an incorrect trailing UTF-8 octet.");
				}
				array[count++] = (byte)num2;
				Skip();
				Skip();
				Skip();
			}
			while (--num > 0);
			string @string = Encoding.UTF8.GetString(array, 0, count);
			if (@string.Length == 0 || @string.Length > 2)
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a tag, found an incorrect UTF-8 sequence.");
			}
			return @string;
		}

		private string ScanTagHandle(bool isDirective, Mark start)
		{
			if (!analyzer.Check('!'))
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a tag, did not find expected '!'.");
			}
			StringBuilderPool.BuilderWrapper builderWrapper = StringBuilderPool.Rent();
			try
			{
				StringBuilder builder = builderWrapper.Builder;
				builder.Append(ReadCurrentCharacter());
				while (analyzer.IsAlphaNumericDashOrUnderscore())
				{
					builder.Append(ReadCurrentCharacter());
				}
				if (analyzer.Check('!'))
				{
					builder.Append(ReadCurrentCharacter());
				}
				else if (isDirective && (builder.Length != 1 || builder[0] != '!'))
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a tag directive, did not find expected '!'.");
				}
				return builder.ToString();
			}
			finally
			{
				((IDisposable)builderWrapper).Dispose();
			}
		}

		private int ScanVersionDirectiveNumber(in Mark start)
		{
			int num = 0;
			int num2 = 0;
			while (analyzer.IsDigit())
			{
				if (++num2 > 9)
				{
					Mark end = cursor.Mark();
					throw new SyntaxErrorException(in start, in end, "While scanning a %YAML directive, found extremely long version number.");
				}
				num = num * 10 + analyzer.AsDigit();
				Skip();
			}
			if (num2 == 0)
			{
				Mark end = cursor.Mark();
				throw new SyntaxErrorException(in start, in end, "While scanning a %YAML directive, did not find expected version number.");
			}
			return num;
		}

		private void SaveSimpleKey()
		{
			bool isRequired = flowLevel == 0 && indent == cursor.LineOffset;
			if (simpleKeyAllowed)
			{
				SimpleKey item = new SimpleKey(isRequired, tokensParsed + tokens.Count, cursor);
				RemoveSimpleKey();
				simpleKeys.Pop();
				simpleKeys.Push(item);
			}
		}
	}
	internal class SemanticErrorException : YamlException
	{
		public SemanticErrorException(string message)
			: base(message)
		{
		}

		public SemanticErrorException(in Mark start, in Mark end, string message)
			: base(in start, in end, message)
		{
		}

		public SemanticErrorException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	internal sealed class SimpleKey
	{
		private readonly Cursor cursor;

		public bool IsPossible { get; private set; }

		public bool IsRequired { get; }

		public int TokenNumber { get; }

		public int Index => cursor.Index;

		public int Line => cursor.Line;

		public int LineOffset => cursor.LineOffset;

		public Mark Mark => cursor.Mark();

		public void MarkAsImpossible()
		{
			IsPossible = false;
		}

		public SimpleKey()
		{
			cursor = new Cursor();
		}

		public SimpleKey(bool isRequired, int tokenNumber, Cursor cursor)
		{
			IsPossible = true;
			IsRequired = isRequired;
			TokenNumber = tokenNumber;
			this.cursor = new Cursor(cursor);
		}
	}
	internal sealed class StringLookAheadBuffer : ILookAheadBuffer
	{
		private readonly string value;

		public int Position { get; private set; }

		public int Length => value.Length;

		public bool EndOfInput => IsOutside(Position);

		public StringLookAheadBuffer(string value)
		{
			this.value = value;
		}

		public char Peek(int offset)
		{
			int index = Position + offset;
			if (!IsOutside(index))
			{
				return value[index];
			}
			return '\0';
		}

		private bool IsOutside(int index)
		{
			return index >= value.Length;
		}

		public void Skip(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "The length must be positive.");
			}
			Position += length;
		}
	}
	internal sealed class SyntaxErrorException : YamlException
	{
		public SyntaxErrorException(string message)
			: base(message)
		{
		}

		public SyntaxErrorException(in Mark start, in Mark end, string message)
			: base(in start, in end, message)
		{
		}

		public SyntaxErrorException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	internal sealed class TagDirectiveCollection : KeyedCollection<string, TagDirective>
	{
		public TagDirectiveCollection()
		{
		}

		public TagDirectiveCollection(IEnumerable<TagDirective> tagDirectives)
		{
			foreach (TagDirective tagDirective in tagDirectives)
			{
				Add(tagDirective);
			}
		}

		protected override string GetKeyForItem(TagDirective item)
		{
			return item.Handle;
		}

		public new bool Contains(TagDirective directive)
		{
			return Contains(GetKeyForItem(directive));
		}
	}
	internal readonly struct TagName : IEquatable<TagName>
	{
		public static readonly TagName Empty;

		private readonly string? value;

		public string Value => value ?? throw new InvalidOperationException("Cannot read the Value of a non-specific tag");

		public bool IsEmpty => value == null;

		public bool IsNonSpecific
		{
			get
			{
				if (!IsEmpty)
				{
					if (!(value == "!"))
					{
						return value == "?";
					}
					return true;
				}
				return false;
			}
		}

		public bool IsLocal
		{
			get
			{
				if (!IsEmpty)
				{
					return Value[0] == '!';
				}
				return false;
			}
		}

		public bool IsGlobal
		{
			get
			{
				if (!IsEmpty)
				{
					return !IsLocal;
				}
				return false;
			}
		}

		public TagName(string value)
		{
			this.value = value ?? throw new ArgumentNullException("value");
			if (value.Length == 0)
			{
				throw new ArgumentException("Tag value must not be empty.", "value");
			}
			if (IsGlobal && !Uri.IsWellFormedUriString(value, UriKind.RelativeOrAbsolute))
			{
				throw new ArgumentException("Global tags must be valid URIs.", "value");
			}
		}

		public override string ToString()
		{
			return value ?? "?";
		}

		public bool Equals(TagName other)
		{
			return object.Equals(value, other.value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is TagName other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return value?.GetHashCode() ?? 0;
		}

		public static bool operator ==(TagName left, TagName right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(TagName left, TagName right)
		{
			return !(left == right);
		}

		public static bool operator ==(TagName left, string right)
		{
			return object.Equals(left.value, right);
		}

		public static bool operator !=(TagName left, string right)
		{
			return !(left == right);
		}

		public static implicit operator TagName(string? value)
		{
			if (value != null)
			{
				return new TagName(value);
			}
			return Empty;
		}
	}
	internal sealed class Version
	{
		public int Major { get; }

		public int Minor { get; }

		public Version(int major, int minor)
		{
			if (major < 0)
			{
				throw new ArgumentOutOfRangeException("major", $"{major} should be >= 0");
			}
			Major = major;
			if (minor < 0)
			{
				throw new ArgumentOutOfRangeException("minor", $"{minor} should be >= 0");
			}
			Minor = minor;
		}

		public override bool Equals(object? obj)
		{
			if (obj is Version version && Major == version.Major)
			{
				return Minor == version.Minor;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.CombineHashCodes(Major.GetHashCode(), Minor.GetHashCode());
		}
	}
	internal class YamlException : Exception
	{
		public Mark Start { get; }

		public Mark End { get; }

		public YamlException(string message)
			: this(in Mark.Empty, in Mark.Empty, message)
		{
		}

		public YamlException(in Mark start, in Mark end, string message)
			: this(in start, in end, message, null)
		{
		}

		public YamlException(in Mark start, in Mark end, string message, Exception? innerException)
			: base(message, innerException)
		{
			Start = start;
			End = end;
		}

		public YamlException(string message, Exception inner)
			: this(in Mark.Empty, in Mark.Empty, message, inner)
		{
		}

		public override string ToString()
		{
			return $"({Start}) - ({End}): {Message}";
		}
	}
}
namespace YamlDotNet.Core.Tokens
{
	internal class Anchor : Token
	{
		public AnchorName Value { get; }

		public Anchor(AnchorName value)
			: this(value, Mark.Empty, Mark.Empty)
		{
		}

		public Anchor(AnchorName value, Mark start, Mark end)
			: base(in start, in end)
		{
			if (value.IsEmpty)
			{
				throw new ArgumentNullException("value");
			}
			Value = value;
		}
	}
	internal sealed class AnchorAlias : Token
	{
		public AnchorName Value { get; }

		public AnchorAlias(AnchorName value)
			: this(value, Mark.Empty, Mark.Empty)
		{
		}

		public AnchorAlias(AnchorName value, Mark start, Mark end)
			: base(in start, in end)
		{
			if (value.IsEmpty)
			{
				throw new ArgumentNullException("value");
			}
			Value = value;
		}
	}
	internal sealed class BlockEnd : Token
	{
		public BlockEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public BlockEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class BlockEntry : Token
	{
		public BlockEntry()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public BlockEntry(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class BlockMappingStart : Token
	{
		public BlockMappingStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public BlockMappingStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class BlockSequenceStart : Token
	{
		public BlockSequenceStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public BlockSequenceStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class Comment : Token
	{
		public string Value { get; }

		public bool IsInline { get; }

		public Comment(string value, bool isInline)
			: this(value, isInline, Mark.Empty, Mark.Empty)
		{
		}

		public Comment(string value, bool isInline, Mark start, Mark end)
			: base(in start, in end)
		{
			Value = value ?? throw new ArgumentNullException("value");
			IsInline = isInline;
		}
	}
	internal sealed class DocumentEnd : Token
	{
		public DocumentEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public DocumentEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class DocumentStart : Token
	{
		public DocumentStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public DocumentStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal class Error : Token
	{
		public string Value { get; }

		public Error(string value, Mark start, Mark end)
			: base(in start, in end)
		{
			Value = value;
		}
	}
	internal sealed class FlowEntry : Token
	{
		public FlowEntry()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public FlowEntry(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class FlowMappingEnd : Token
	{
		public FlowMappingEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public FlowMappingEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class FlowMappingStart : Token
	{
		public FlowMappingStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public FlowMappingStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class FlowSequenceEnd : Token
	{
		public FlowSequenceEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public FlowSequenceEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class FlowSequenceStart : Token
	{
		public FlowSequenceStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public FlowSequenceStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class Key : Token
	{
		public Key()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public Key(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class Scalar : Token
	{
		public bool IsKey { get; set; }

		public string Value { get; }

		public ScalarStyle Style { get; }

		public Scalar(string value)
			: this(value, ScalarStyle.Any)
		{
		}

		public Scalar(string value, ScalarStyle style)
			: this(value, style, Mark.Empty, Mark.Empty)
		{
		}

		public Scalar(string value, ScalarStyle style, Mark start, Mark end)
			: base(in start, in end)
		{
			Value = value ?? throw new ArgumentNullException("value");
			Style = style;
		}
	}
	internal sealed class StreamEnd : Token
	{
		public StreamEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public StreamEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class StreamStart : Token
	{
		public StreamStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public StreamStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class Tag : Token
	{
		public string Handle { get; }

		public string Suffix { get; }

		public Tag(string handle, string suffix)
			: this(handle, suffix, Mark.Empty, Mark.Empty)
		{
		}

		public Tag(string handle, string suffix, Mark start, Mark end)
			: base(in start, in end)
		{
			Handle = handle ?? throw new ArgumentNullException("handle");
			Suffix = suffix ?? throw new ArgumentNullException("suffix");
		}
	}
	internal class TagDirective : Token
	{
		private static readonly Regex TagHandlePattern = new Regex("^!([0-9A-Za-z_\\-]*!)?$", RegexOptions.Compiled);

		public string Handle { get; }

		public string Prefix { get; }

		public TagDirective(string handle, string prefix)
			: this(handle, prefix, Mark.Empty, Mark.Empty)
		{
		}

		public TagDirective(string handle, string prefix, Mark start, Mark end)
			: base(in start, in end)
		{
			if (string.IsNullOrEmpty(handle))
			{
				throw new ArgumentNullException("handle", "Tag handle must not be empty.");
			}
			if (!TagHandlePattern.IsMatch(handle))
			{
				throw new ArgumentException("Tag handle must start and end with '!' and contain alphanumerical characters only.", "handle");
			}
			Handle = handle;
			if (string.IsNullOrEmpty(prefix))
			{
				throw new ArgumentNullException("prefix", "Tag prefix must not be empty.");
			}
			Prefix = prefix;
		}

		public override bool Equals(object? obj)
		{
			if (obj is TagDirective tagDirective && Handle.Equals(tagDirective.Handle))
			{
				return Prefix.Equals(tagDirective.Prefix);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return Handle.GetHashCode() ^ Prefix.GetHashCode();
		}

		public override string ToString()
		{
			return Handle + " => " + Prefix;
		}
	}
	internal abstract class Token
	{
		public Mark Start { get; }

		public Mark End { get; }

		protected Token(in Mark start, in Mark end)
		{
			Start = start;
			End = end;
		}
	}
	internal sealed class Value : Token
	{
		public Value()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public Value(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}
	}
	internal sealed class VersionDirective : Token
	{
		public Version Version { get; }

		public VersionDirective(Version version)
			: this(version, Mark.Empty, Mark.Empty)
		{
		}

		public VersionDirective(Version version, Mark start, Mark end)
			: base(in start, in end)
		{
			Version = version;
		}

		public override bool Equals(object? obj)
		{
			if (obj is VersionDirective versionDirective)
			{
				return Version.Equals(versionDirective.Version);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return Version.GetHashCode();
		}
	}
}
namespace YamlDotNet.Core.Events
{
	internal sealed class AnchorAlias : ParsingEvent
	{
		internal override EventType Type => EventType.Alias;

		public AnchorName Value { get; }

		public AnchorAlias(AnchorName value, Mark start, Mark end)
			: base(in start, in end)
		{
			if (value.IsEmpty)
			{
				throw new YamlException(in start, in end, "Anchor value must not be empty.");
			}
			Value = value;
		}

		public AnchorAlias(AnchorName value)
			: this(value, Mark.Empty, Mark.Empty)
		{
		}

		public override string ToString()
		{
			return $"Alias [value = {Value}]";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class Comment : ParsingEvent
	{
		public string Value { get; }

		public bool IsInline { get; }

		internal override EventType Type => EventType.Comment;

		public Comment(string value, bool isInline)
			: this(value, isInline, Mark.Empty, Mark.Empty)
		{
		}

		public Comment(string value, bool isInline, Mark start, Mark end)
			: base(in start, in end)
		{
			Value = value;
			IsInline = isInline;
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}

		public override string ToString()
		{
			return (IsInline ? "Inline" : "Block") + " Comment [" + Value + "]";
		}
	}
	internal sealed class DocumentEnd : ParsingEvent
	{
		public override int NestingIncrease => -1;

		internal override EventType Type => EventType.DocumentEnd;

		public bool IsImplicit { get; }

		public DocumentEnd(bool isImplicit, Mark start, Mark end)
			: base(in start, in end)
		{
			IsImplicit = isImplicit;
		}

		public DocumentEnd(bool isImplicit)
			: this(isImplicit, Mark.Empty, Mark.Empty)
		{
		}

		public override string ToString()
		{
			return $"Document end [isImplicit = {IsImplicit}]";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class DocumentStart : ParsingEvent
	{
		public override int NestingIncrease => 1;

		internal override EventType Type => EventType.DocumentStart;

		public TagDirectiveCollection? Tags { get; }

		public VersionDirective? Version { get; }

		public bool IsImplicit { get; }

		public DocumentStart(VersionDirective? version, TagDirectiveCollection? tags, bool isImplicit, Mark start, Mark end)
			: base(in start, in end)
		{
			Version = version;
			Tags = tags;
			IsImplicit = isImplicit;
		}

		public DocumentStart(VersionDirective? version, TagDirectiveCollection? tags, bool isImplicit)
			: this(version, tags, isImplicit, Mark.Empty, Mark.Empty)
		{
		}

		public DocumentStart(in Mark start, in Mark end)
			: this(null, null, isImplicit: true, start, end)
		{
		}

		public DocumentStart()
			: this(null, null, isImplicit: true, Mark.Empty, Mark.Empty)
		{
		}

		public override string ToString()
		{
			return $"Document start [isImplicit = {IsImplicit}]";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal enum EventType
	{
		None,
		StreamStart,
		StreamEnd,
		DocumentStart,
		DocumentEnd,
		Alias,
		Scalar,
		SequenceStart,
		SequenceEnd,
		MappingStart,
		MappingEnd,
		Comment
	}
	internal interface IParsingEventVisitor
	{
		void Visit(AnchorAlias e);

		void Visit(StreamStart e);

		void Visit(StreamEnd e);

		void Visit(DocumentStart e);

		void Visit(DocumentEnd e);

		void Visit(Scalar e);

		void Visit(SequenceStart e);

		void Visit(SequenceEnd e);

		void Visit(MappingStart e);

		void Visit(MappingEnd e);

		void Visit(Comment e);
	}
	internal class MappingEnd : ParsingEvent
	{
		public override int NestingIncrease => -1;

		internal override EventType Type => EventType.MappingEnd;

		public MappingEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}

		public MappingEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public override string ToString()
		{
			return "Mapping end";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class MappingStart : NodeEvent
	{
		public override int NestingIncrease => 1;

		internal override EventType Type => EventType.MappingStart;

		public bool IsImplicit { get; }

		public override bool IsCanonical => !IsImplicit;

		public MappingStyle Style { get; }

		public MappingStart(AnchorName anchor, TagName tag, bool isImplicit, MappingStyle style, Mark start, Mark end)
			: base(anchor, tag, start, end)
		{
			IsImplicit = isImplicit;
			Style = style;
		}

		public MappingStart(AnchorName anchor, TagName tag, bool isImplicit, MappingStyle style)
			: this(anchor, tag, isImplicit, style, Mark.Empty, Mark.Empty)
		{
		}

		public MappingStart()
			: this(AnchorName.Empty, TagName.Empty, isImplicit: true, MappingStyle.Any, Mark.Empty, Mark.Empty)
		{
		}

		public override string ToString()
		{
			return $"Mapping start [anchor = {base.Anchor}, tag = {base.Tag}, isImplicit = {IsImplicit}, style = {Style}]";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal enum MappingStyle
	{
		Any,
		Block,
		Flow
	}
	internal abstract class NodeEvent : ParsingEvent
	{
		public AnchorName Anchor { get; }

		public TagName Tag { get; }

		public abstract bool IsCanonical { get; }

		protected NodeEvent(AnchorName anchor, TagName tag, Mark start, Mark end)
			: base(in start, in end)
		{
			Anchor = anchor;
			Tag = tag;
		}

		protected NodeEvent(AnchorName anchor, TagName tag)
			: this(anchor, tag, Mark.Empty, Mark.Empty)
		{
		}
	}
	internal abstract class ParsingEvent
	{
		public virtual int NestingIncrease => 0;

		internal abstract EventType Type { get; }

		public Mark Start { get; }

		public Mark End { get; }

		public abstract void Accept(IParsingEventVisitor visitor);

		internal ParsingEvent(in Mark start, in Mark end)
		{
			Start = start;
			End = end;
		}
	}
	internal sealed class Scalar : NodeEvent
	{
		internal override EventType Type => EventType.Scalar;

		public string Value { get; }

		public ScalarStyle Style { get; }

		public bool IsPlainImplicit { get; }

		public bool IsQuotedImplicit { get; }

		public override bool IsCanonical
		{
			get
			{
				if (!IsPlainImplicit)
				{
					return !IsQuotedImplicit;
				}
				return false;
			}
		}

		public bool IsKey { get; }

		public Scalar(AnchorName anchor, TagName tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit, Mark start, Mark end, bool isKey = false)
			: base(anchor, tag, start, end)
		{
			Value = value;
			Style = style;
			IsPlainImplicit = isPlainImplicit;
			IsQuotedImplicit = isQuotedImplicit;
			IsKey = isKey;
		}

		public Scalar(AnchorName anchor, TagName tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit)
			: this(anchor, tag, value, style, isPlainImplicit, isQuotedImplicit, Mark.Empty, Mark.Empty)
		{
		}

		public Scalar(string value)
			: this(AnchorName.Empty, TagName.Empty, value, ScalarStyle.Any, isPlainImplicit: true, isQuotedImplicit: true, Mark.Empty, Mark.Empty)
		{
		}

		public Scalar(TagName tag, string value)
			: this(AnchorName.Empty, tag, value, ScalarStyle.Any, isPlainImplicit: true, isQuotedImplicit: true, Mark.Empty, Mark.Empty)
		{
		}

		public Scalar(AnchorName anchor, TagName tag, string value)
			: this(anchor, tag, value, ScalarStyle.Any, isPlainImplicit: true, isQuotedImplicit: true, Mark.Empty, Mark.Empty)
		{
		}

		public override string ToString()
		{
			return $"Scalar [anchor = {base.Anchor}, tag = {base.Tag}, value = {Value}, style = {Style}, isPlainImplicit = {IsPlainImplicit}, isQuotedImplicit = {IsQuotedImplicit}]";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class SequenceEnd : ParsingEvent
	{
		public override int NestingIncrease => -1;

		internal override EventType Type => EventType.SequenceEnd;

		public SequenceEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}

		public SequenceEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public override string ToString()
		{
			return "Sequence end";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class SequenceStart : NodeEvent
	{
		public override int NestingIncrease => 1;

		internal override EventType Type => EventType.SequenceStart;

		public bool IsImplicit { get; }

		public override bool IsCanonical => !IsImplicit;

		public SequenceStyle Style { get; }

		public SequenceStart(AnchorName anchor, TagName tag, bool isImplicit, SequenceStyle style, Mark start, Mark end)
			: base(anchor, tag, start, end)
		{
			IsImplicit = isImplicit;
			Style = style;
		}

		public SequenceStart(AnchorName anchor, TagName tag, bool isImplicit, SequenceStyle style)
			: this(anchor, tag, isImplicit, style, Mark.Empty, Mark.Empty)
		{
		}

		public override string ToString()
		{
			return $"Sequence start [anchor = {base.Anchor}, tag = {base.Tag}, isImplicit = {IsImplicit}, style = {Style}]";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal enum SequenceStyle
	{
		Any,
		Block,
		Flow
	}
	internal sealed class StreamEnd : ParsingEvent
	{
		public override int NestingIncrease => -1;

		internal override EventType Type => EventType.StreamEnd;

		public StreamEnd(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}

		public StreamEnd()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public override string ToString()
		{
			return "Stream end";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
	internal sealed class StreamStart : ParsingEvent
	{
		public override int NestingIncrease => 1;

		internal override EventType Type => EventType.StreamStart;

		public StreamStart()
			: this(in Mark.Empty, in Mark.Empty)
		{
		}

		public StreamStart(in Mark start, in Mark end)
			: base(in start, in end)
		{
		}

		public override string ToString()
		{
			return "Stream start";
		}

		public override void Accept(IParsingEventVisitor visitor)
		{
			visitor.Visit(this);
		}
	}
}
namespace System.Diagnostics.CodeAnalysis
{
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class AllowNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class DisallowNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class DoesNotReturnAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class DoesNotReturnIfAttribute : Attribute
	{
		public bool ParameterValue { get; }

		public DoesNotReturnIfAttribute(bool parameterValue)
		{
			ParameterValue = parameterValue;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class MaybeNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class MaybeNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public MaybeNullWhenAttribute(bool returnValue)
		{
			ReturnValue = returnValue;
		}
	}
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class MemberNotNullAttribute : Attribute
	{
		public string[] Members { get; }

		public MemberNotNullAttribute(string member)
		{
			Members = new string[1] { member };
		}

		public MemberNotNullAttribute(params string[] members)
		{
			Members = members;
		}
	}
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class MemberNotNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public string[] Members { get; }

		public MemberNotNullWhenAttribute(bool returnValue, string member)
		{
			ReturnValue = returnValue;
			Members = new string[1] { member };
		}

		public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
		{
			ReturnValue = returnValue;
			Members = members;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class NotNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class NotNullIfNotNullAttribute : Attribute
	{
		public string ParameterName { get; }

		public NotNullIfNotNullAttribute(string parameterName)
		{
			ParameterName = parameterName;
		}
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal sealed class NotNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public NotNullWhenAttribute(bool returnValue)
		{
			ReturnValue = returnValue;
		}
	}
}
